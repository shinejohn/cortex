#!/bin/bash

#===============================================================================
# RAILWAY DIAGNOSTIC ANALYZER
# Analyzes a project dump and generates specific fix recommendations
#
# Usage: ./railway-diagnose.sh [dump-directory]
# Output: diagnosis.json and recommended-fixes.sh in the dump directory
#===============================================================================

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Find dump directory
if [ -n "$1" ]; then
    DUMP_DIR="$1"
elif [ -f "./.latest-dump-dir" ]; then
    DUMP_DIR=$(cat ./.latest-dump-dir)
else
    DUMP_DIR=$(ls -td ./railway-dump_* 2>/dev/null | head -1)
fi

if [ -z "$DUMP_DIR" ] || [ ! -d "$DUMP_DIR" ]; then
    echo -e "${RED}ERROR: No dump directory found${NC}"
    echo "Run ./railway-dump.sh first, or specify: ./railway-diagnose.sh <dump-dir>"
    exit 1
fi

echo ""
echo "╔══════════════════════════════════════════════════════════════╗"
echo "║              RAILWAY DIAGNOSTIC ANALYZER                     ║"
echo "╚══════════════════════════════════════════════════════════════╝"
echo ""
echo "Analyzing: $DUMP_DIR"
echo ""

#===============================================================================
# Initialize Output Files
#===============================================================================

DIAGNOSIS_FILE="$DUMP_DIR/diagnosis.txt"
FIX_SCRIPT="$DUMP_DIR/recommended-fixes.sh"
ISSUES_FOUND=0

cat > "$DIAGNOSIS_FILE" << EOF
================================================================================
                    RAILWAY DIAGNOSTIC REPORT
================================================================================
Generated: $(date)
Dump: $DUMP_DIR

EOF

cat > "$FIX_SCRIPT" << 'HEADER'
#!/bin/bash
#===============================================================================
# RECOMMENDED FIXES
# Auto-generated by railway-diagnose.sh
# Review before running!
#===============================================================================

set -e

echo "Applying recommended fixes..."
echo ""

HEADER

#===============================================================================
# Diagnosis Functions
#===============================================================================

diagnose_pgdata_conflict() {
    local SERVICE="$1"
    local LOG="$2"
    
    if grep -qi "lost+found\|directory.*not empty\|initdb.*error" "$LOG" 2>/dev/null; then
        echo -e "  ${RED}✗ PGDATA CONFLICT${NC}"
        
        cat >> "$DIAGNOSIS_FILE" << EOF

ISSUE: PGDATA_CONFLICT
SERVICE: $SERVICE
DESCRIPTION: PostgreSQL fails to initialize because volume mount point contains lost+found
ERROR: "directory exists but is not empty"
FIX: Change PGDATA to use a subdirectory
COMMAND: railway variables -s "$SERVICE" --set "PGDATA=/var/lib/postgresql/data/pgdata"

EOF

        cat >> "$FIX_SCRIPT" << EOF
# Fix PGDATA for $SERVICE
echo "Fixing PGDATA for $SERVICE..."
railway variables -s "$SERVICE" --set "PGDATA=/var/lib/postgresql/data/pgdata"
railway redeploy -s "$SERVICE"
echo "Waiting 30s for $SERVICE..."
sleep 30

EOF
        ISSUES_FOUND=$((ISSUES_FOUND + 1))
        return 0
    fi
    return 1
}

diagnose_db_connection() {
    local SERVICE="$1"
    local LOG="$2"
    
    if grep -qi "SQLSTATE\[08006\]\|connection refused.*5432\|could not connect.*database\|Connection refused.*pgsql" "$LOG" 2>/dev/null; then
        echo -e "  ${RED}✗ DATABASE CONNECTION FAILED${NC}"
        
        cat >> "$DIAGNOSIS_FILE" << EOF

ISSUE: DB_CONNECTION_FAILED
SERVICE: $SERVICE
DESCRIPTION: Cannot connect to PostgreSQL database
ERROR: "connection refused" or "could not connect"
POSSIBLE CAUSES:
  1. PostgreSQL service not running
  2. Wrong DB_HOST or DATABASE_URL
  3. Network configuration issue
FIX:
  1. Ensure Postgres service is Online first
  2. Check that DB_HOST uses Railway private domain
  3. Redeploy this service after database is healthy

EOF

        cat >> "$FIX_SCRIPT" << EOF
# Fix DB connection for $SERVICE
echo "Redeploying $SERVICE (ensure databases are running first)..."
railway redeploy -s "$SERVICE"

EOF
        ISSUES_FOUND=$((ISSUES_FOUND + 1))
        return 0
    fi
    return 1
}

diagnose_redis_connection() {
    local SERVICE="$1"
    local LOG="$2"
    
    if grep -qi "redis.*connection\|redis.*refused\|NOAUTH\|predis.*exception" "$LOG" 2>/dev/null; then
        echo -e "  ${RED}✗ REDIS CONNECTION FAILED${NC}"
        
        cat >> "$DIAGNOSIS_FILE" << EOF

ISSUE: REDIS_CONNECTION_FAILED
SERVICE: $SERVICE
DESCRIPTION: Cannot connect to Redis/Valkey
ERROR: "connection refused" or "NOAUTH"
FIX: Ensure Valkey is running and REDIS_URL is correct

EOF

        cat >> "$FIX_SCRIPT" << EOF
# Note: Check Valkey is running before redeploying $SERVICE
echo "Redeploying $SERVICE..."
railway redeploy -s "$SERVICE"

EOF
        ISSUES_FOUND=$((ISSUES_FOUND + 1))
        return 0
    fi
    return 1
}

diagnose_missing_app_key() {
    local SERVICE="$1"
    local LOG="$2"
    
    if grep -qi "No application encryption key\|APP_KEY.*not set\|cipher.*invalid" "$LOG" 2>/dev/null; then
        echo -e "  ${RED}✗ MISSING APP_KEY${NC}"
        
        cat >> "$DIAGNOSIS_FILE" << EOF

ISSUE: MISSING_APP_KEY
SERVICE: $SERVICE
DESCRIPTION: Laravel APP_KEY is not set or invalid
FIX: Generate and set a new APP_KEY

EOF

        cat >> "$FIX_SCRIPT" << EOF
# Generate APP_KEY for $SERVICE
echo "Generating APP_KEY for $SERVICE..."
NEW_KEY="base64:\$(openssl rand -base64 32)"
railway variables -s "$SERVICE" --set "APP_KEY=\$NEW_KEY"
railway redeploy -s "$SERVICE"

EOF
        ISSUES_FOUND=$((ISSUES_FOUND + 1))
        return 0
    fi
    return 1
}

diagnose_npm_error() {
    local SERVICE="$1"
    local LOG="$2"
    
    if grep -qi "npm ERR\|ENOENT.*package.json\|npm.*WARN\|npm.*error" "$LOG" 2>/dev/null; then
        echo -e "  ${RED}✗ NPM BUILD ERROR${NC}"
        
        # Get specific error
        local NPM_ERROR=$(grep -i "npm ERR" "$LOG" 2>/dev/null | head -3 || echo "Unknown npm error")
        
        cat >> "$DIAGNOSIS_FILE" << EOF

ISSUE: NPM_BUILD_ERROR
SERVICE: $SERVICE
DESCRIPTION: NPM failed during build
ERROR SAMPLE: 
$NPM_ERROR
POSSIBLE CAUSES:
  1. Missing package.json
  2. Node version incompatibility
  3. Missing dependencies
  4. Network timeout during npm install
FIX: Check package.json, ensure Node 18+, redeploy

EOF
        ISSUES_FOUND=$((ISSUES_FOUND + 1))
        return 0
    fi
    return 1
}

diagnose_vite_error() {
    local SERVICE="$1"
    local LOG="$2"
    
    if grep -qi "vite.*error\|vite.*failed\|rollup.*error\|Build failed\|could not resolve" "$LOG" 2>/dev/null; then
        echo -e "  ${RED}✗ VITE BUILD ERROR${NC}"
        
        cat >> "$DIAGNOSIS_FILE" << EOF

ISSUE: VITE_BUILD_ERROR
SERVICE: $SERVICE
DESCRIPTION: Vite/frontend build failed
POSSIBLE CAUSES:
  1. Syntax error in JS/TS/Vue/JSX files
  2. Missing imports
  3. Incorrect vite.config.js
FIX: Check build logs for specific file and line number

EOF
        ISSUES_FOUND=$((ISSUES_FOUND + 1))
        return 0
    fi
    return 1
}

diagnose_composer_error() {
    local SERVICE="$1"
    local LOG="$2"
    
    if grep -qi "composer.*fail\|composer.*error\|Your requirements could not be resolved\|Class.*not found" "$LOG" 2>/dev/null; then
        echo -e "  ${RED}✗ COMPOSER/PHP ERROR${NC}"
        
        cat >> "$DIAGNOSIS_FILE" << EOF

ISSUE: COMPOSER_ERROR
SERVICE: $SERVICE
DESCRIPTION: PHP/Composer installation or autoload failed
POSSIBLE CAUSES:
  1. PHP version mismatch
  2. Missing PHP extensions
  3. Conflicting dependencies
FIX: Check composer.json PHP version requirement

EOF
        ISSUES_FOUND=$((ISSUES_FOUND + 1))
        return 0
    fi
    return 1
}

diagnose_memory_error() {
    local SERVICE="$1"
    local LOG="$2"
    
    if grep -qi "out of memory\|memory exhausted\|Killed\|OOMKilled" "$LOG" 2>/dev/null; then
        echo -e "  ${RED}✗ MEMORY EXHAUSTED${NC}"
        
        cat >> "$DIAGNOSIS_FILE" << EOF

ISSUE: MEMORY_EXHAUSTED
SERVICE: $SERVICE
DESCRIPTION: Service ran out of memory during build or runtime
FIX: Increase memory limit in Railway service settings (Dashboard)

EOF
        ISSUES_FOUND=$((ISSUES_FOUND + 1))
        return 0
    fi
    return 1
}

diagnose_build_failed() {
    local SERVICE="$1"
    local LOG="$2"
    
    if grep -qi "Build failed\|error: exit status\|build error" "$LOG" 2>/dev/null; then
        # Only flag if we haven't caught a more specific error
        if ! grep -qi "npm ERR\|vite.*error\|composer.*fail" "$LOG" 2>/dev/null; then
            echo -e "  ${RED}✗ BUILD FAILED (unspecified)${NC}"
            
            cat >> "$DIAGNOSIS_FILE" << EOF

ISSUE: BUILD_FAILED
SERVICE: $SERVICE
DESCRIPTION: Build failed (check logs for details)
LOG FILE: $LOG
FIX: Review full build log: cat $LOG

EOF
            ISSUES_FOUND=$((ISSUES_FOUND + 1))
            return 0
        fi
    fi
    return 1
}

check_healthy() {
    local SERVICE="$1"
    local LOG="$2"
    
    if grep -qi "ready to accept connections\|listening on\|Application ready\|started successfully\|HTTP server running" "$LOG" 2>/dev/null; then
        echo -e "  ${GREEN}✓ HEALTHY${NC}"
        return 0
    fi
    return 1
}

#===============================================================================
# Run Diagnosis on Each Service
#===============================================================================

echo -e "${BLUE}Analyzing services...${NC}"
echo ""

if [ ! -f "$DUMP_DIR/service-list.txt" ]; then
    echo -e "${RED}ERROR: service-list.txt not found${NC}"
    exit 1
fi

while IFS= read -r SERVICE; do
    [ -z "$SERVICE" ] && continue
    
    SAFE_NAME=$(echo "$SERVICE" | tr ' ' '-' | tr '[:upper:]' '[:lower:]')
    BUILD_LOG="$DUMP_DIR/build-logs/${SAFE_NAME}.log"
    RUNTIME_LOG="$DUMP_DIR/runtime-logs/${SAFE_NAME}.log"
    
    echo -e "${CYAN}$SERVICE${NC}"
    
    FOUND_ISSUE=false
    
    # Run all diagnostics
    diagnose_pgdata_conflict "$SERVICE" "$RUNTIME_LOG" && FOUND_ISSUE=true
    diagnose_db_connection "$SERVICE" "$RUNTIME_LOG" && FOUND_ISSUE=true
    diagnose_redis_connection "$SERVICE" "$RUNTIME_LOG" && FOUND_ISSUE=true
    diagnose_missing_app_key "$SERVICE" "$RUNTIME_LOG" && FOUND_ISSUE=true
    diagnose_npm_error "$SERVICE" "$BUILD_LOG" && FOUND_ISSUE=true
    diagnose_vite_error "$SERVICE" "$BUILD_LOG" && FOUND_ISSUE=true
    diagnose_composer_error "$SERVICE" "$BUILD_LOG" && FOUND_ISSUE=true
    diagnose_memory_error "$SERVICE" "$BUILD_LOG" && FOUND_ISSUE=true
    diagnose_memory_error "$SERVICE" "$RUNTIME_LOG" && FOUND_ISSUE=true
    diagnose_build_failed "$SERVICE" "$BUILD_LOG" && FOUND_ISSUE=true
    
    if [ "$FOUND_ISSUE" = false ]; then
        if check_healthy "$SERVICE" "$RUNTIME_LOG"; then
            : # Already printed healthy
        else
            echo -e "  ${YELLOW}? STATUS UNCLEAR${NC} - review logs manually"
        fi
    fi
    
    echo ""
done < "$DUMP_DIR/service-list.txt"

#===============================================================================
# Finalize Fix Script
#===============================================================================

cat >> "$FIX_SCRIPT" << 'FOOTER'

echo ""
echo "Fixes applied. Waiting for services to stabilize..."
sleep 60

echo ""
echo "Checking status..."
railway status

echo ""
echo "Done! Run ./railway-dump.sh again to verify."
FOOTER

chmod +x "$FIX_SCRIPT"

#===============================================================================
# Summary
#===============================================================================

echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo ""

if [ $ISSUES_FOUND -eq 0 ]; then
    echo -e "${GREEN}NO ISSUES DETECTED${NC}"
else
    echo -e "${YELLOW}FOUND $ISSUES_FOUND ISSUES${NC}"
fi

echo ""
echo "Reports:"
echo "  $DIAGNOSIS_FILE"
echo "  $FIX_SCRIPT"
echo ""

if [ $ISSUES_FOUND -gt 0 ]; then
    echo "To apply fixes:"
    echo "  cat $FIX_SCRIPT   # Review first!"
    echo "  $FIX_SCRIPT        # Then run"
fi

echo ""

# Save issue count for other scripts
echo "$ISSUES_FOUND" > "$DUMP_DIR/.issue-count"
