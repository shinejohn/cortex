# Laravel Discovery: Multisite
Generated: Sun Dec 28 16:46:40 EST 2025
Path: /Users/johnshine/Dropbox/Fibonacco/Day-News/Multisite

---
## Models

### AccountManager
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\SoftDeletes;

final class AccountManager extends Model
{
    /** @use HasFactory<\Database\Factories\AccountManagerFactory> */
    use HasFactory, HasUuid, SoftDeletes;

    protected $fillable = [
        'tenant_id',
        'user_id',
        'first_name',
        'last_name',
        'email',
        'phone',
        'is_active',
        'max_accounts',
        'current_account_count',
        'metadata',
    ];

    protected function casts(): array
    {
        return [
            'is_active' => 'boolean',
            'metadata' => 'array',
        ];
    }

    public function tenant(): BelongsTo
    {
        return $this->belongsTo(Tenant::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function getFullNameAttribute(): string
    {
        return "{$this->first_name} {$this->last_name}";
    }

    public function hasCapacity(): bool
    {
        return $this->current_account_count < $this->max_accounts;
    }
}
```

### Achievement
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\SoftDeletes;

final class Achievement extends Model
{
    use HasFactory, HasUuid, SoftDeletes;

    protected $fillable = [
        'business_id',
        'title',
        'description',
        'source_name',
        'source_url',
        'achievement_type',
        'achievement_date',
        'expiration_date',
        'icon',
        'badge_image_url',
        'is_verified',
        'display_order',
        'is_featured',
    ];

    protected function casts(): array
    {
        return [
            'achievement_date' => 'date',
            'expiration_date' => 'date',
            'is_verified' => 'boolean',
            'is_featured' => 'boolean',
        ];
    }

    public function business(): BelongsTo
    {
        return $this->belongsTo(Business::class);
    }

    public function scopeFeatured($query)
    {
        return $query->where('is_featured', true);
    }

    public function scopeVerified($query)
    {
        return $query->where('is_verified', true);
    }

    public function scopeActive($query)
    {
        return $query->where(function ($q) {
            $q->whereNull('expiration_date')
              ->orWhere('expiration_date', '>=', now());
        });
    }
}
```

### AdCampaign
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Support\Str;

final class AdCampaign extends Model
{
    use HasFactory, SoftDeletes;

    protected $fillable = [
        'uuid',
        'advertiser_id',
        'name',
        'description',
        'status',
        'type',
        'budget',
        'spent',
        'daily_budget',
        'start_date',
        'end_date',
        'targeting',
        'platforms',
    ];

    protected $casts = [
        'budget' => 'decimal:2',
        'spent' => 'decimal:2',
        'daily_budget' => 'decimal:2',
        'start_date' => 'date',
        'end_date' => 'date',
        'targeting' => 'array',
        'platforms' => 'array',
    ];

    protected static function boot(): void
    {
        parent::boot();

        static::creating(function ($model): void {
            $model->uuid = $model->uuid ?? Str::uuid()->toString();
        });
    }

    public function advertiser(): BelongsTo
    {
        return $this->belongsTo(Business::class, 'advertiser_id');
    }

    public function creatives(): HasMany
    {
        return $this->hasMany(AdCreative::class, 'campaign_id');
    }

    public function isActive(): bool
    {
        return $this->status === 'active'
            && $this->start_date <= now()
            && $this->end_date >= now()
            && $this->spent < $this->budget;
    }

    public function getRemainingBudgetAttribute(): float
    {
        return max(0, (float) $this->budget - (float) $this->spent);
    }
}
```

### AdClick
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class AdClick extends Model
{
    use HasFactory;
    protected $fillable = [
        'impression_id',
        'creative_id',
        'ip_hash',
        'cost',
        'clicked_at',
    ];

    protected $casts = [
        'cost' => 'decimal:4',
        'clicked_at' => 'datetime',
    ];

    public function impression(): BelongsTo
    {
        return $this->belongsTo(AdImpression::class, 'impression_id');
    }

    public function creative(): BelongsTo
    {
        return $this->belongsTo(AdCreative::class, 'creative_id');
    }
}
```

### AdCreative
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Support\Str;

final class AdCreative extends Model
{
    use HasFactory, SoftDeletes;

    protected $fillable = [
        'uuid',
        'campaign_id',
        'name',
        'format',
        'headline',
        'body',
        'image_url',
        'video_url',
        'audio_url',
        'click_url',
        'cta_text',
        'status',
        'width',
        'height',
    ];

    protected static function boot(): void
    {
        parent::boot();

        static::creating(function ($model): void {
            $model->uuid = $model->uuid ?? Str::uuid()->toString();
        });
    }

    public function campaign(): BelongsTo
    {
        return $this->belongsTo(AdCampaign::class, 'campaign_id');
    }

    public function impressions(): HasMany
    {
        return $this->hasMany(AdImpression::class, 'creative_id');
    }

    public function clicks(): HasMany
    {
        return $this->hasMany(AdClick::class, 'creative_id');
    }

    public function getCtrAttribute(): float
    {
        $impressions = $this->impressions()->count();
        if ($impressions === 0) {
            return 0.0;
        }

        return round(($this->clicks()->count() / $impressions) * 100, 2);
    }
}
```

### AdImpression
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasOne;

final class AdImpression extends Model
{
    use HasFactory;
    // Timestamps are enabled in migration

    protected $fillable = [
        'creative_id',
        'placement_id',
        'community_id',
        'session_id',
        'ip_hash',
        'user_agent',
        'referrer',
        'cost',
        'impressed_at',
    ];

    protected $casts = [
        'cost' => 'decimal:4',
        'impressed_at' => 'datetime',
    ];

    public function creative(): BelongsTo
    {
        return $this->belongsTo(AdCreative::class, 'creative_id');
    }

    public function placement(): BelongsTo
    {
        return $this->belongsTo(AdPlacement::class, 'placement_id');
    }

    public function community(): BelongsTo
    {
        return $this->belongsTo(Community::class, 'community_id');
    }

    public function click(): HasOne
    {
        return $this->hasOne(AdClick::class, 'impression_id');
    }
}
```

### AdInventory
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class AdInventory extends Model
{
    use HasFactory;

    protected $table = 'ad_inventory';

    protected $fillable = [
        'placement_id',
        'community_id',
        'date',
        'total_impressions',
        'sold_impressions',
        'delivered_impressions',
        'revenue',
    ];

    protected $casts = [
        'date' => 'date',
        'revenue' => 'decimal:2',
    ];

    public function placement(): BelongsTo
    {
        return $this->belongsTo(AdPlacement::class, 'placement_id');
    }

    public function community(): BelongsTo
    {
        return $this->belongsTo(Community::class, 'community_id');
    }
}
```

### AdPlacement
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class AdPlacement extends Model
{
    use HasFactory;

    protected $fillable = [
        'platform',
        'slot',
        'name',
        'description',
        'format',
        'width',
        'height',
        'base_cpm',
        'base_cpc',
        'is_active',
        'priority',
    ];

    protected $casts = [
        'base_cpm' => 'decimal:2',
        'base_cpc' => 'decimal:2',
        'is_active' => 'boolean',
    ];

    public function inventory(): HasMany
    {
        return $this->hasMany(AdInventory::class, 'placement_id');
    }

    public function impressions(): HasMany
    {
        return $this->hasMany(AdImpression::class, 'placement_id');
    }
}
```

### Advertisement
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\MorphTo;

final class Advertisement extends Model
{
    /** @use HasFactory<\Database\Factories\AdvertisementFactory> */
    use HasFactory, \App\Traits\RelatableToOrganizations;

    protected $fillable = [
        'platform',
        'advertable_type',
        'advertable_id',
        'placement',
        'regions',
        'impressions_count',
        'clicks_count',
        'starts_at',
        'expires_at',
        'is_active',
    ];

    public function advertable(): MorphTo
    {
        return $this->morphTo();
    }

    public function scopeActive($query)
    {
        return $query->where('is_active', true)
            ->where('starts_at', '<=', now())
            ->where('expires_at', '>', now());
    }

    public function scopeForPlatform($query, string $platform)
    {
        return $query->where('platform', $platform);
    }

    public function scopeForPlacement($query, string $placement)
    {
        return $query->where('placement', $placement);
    }

    public function scopeForRegion($query, string $regionId)
    {
        return $query->whereJsonContains('regions', $regionId);
    }

    public function scopeExpired($query)
    {
        return $query->where('expires_at', '<=', now());
    }

    public function incrementImpressions(): void
    {
        $this->increment('impressions_count');
    }

    public function incrementClicks(): void
    {
        $this->increment('clicks_count');
    }

    public function markAsInactive(): void
    {
        $this->update(['is_active' => false]);
    }

    public function isExpired(): bool
    {
        return $this->expires_at->isPast();
    }

    public function getClickThroughRate(): float
    {
        if ($this->impressions_count === 0) {
            return 0.0;
        }

        return ($this->clicks_count / $this->impressions_count) * 100;
    }

    public function getCTR(): string
    {
        return number_format($this->getClickThroughRate(), 2);
    }

    protected function casts(): array
    {
        return [
            'regions' => 'array',
            'starts_at' => 'datetime',
            'expires_at' => 'datetime',
            'is_active' => 'boolean',
            'impressions_count' => 'integer',
            'clicks_count' => 'integer',
        ];
    }
}
```

### AlphaSiteCommunity
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class AlphaSiteCommunity extends Model
{
    use HasFactory, HasUuid;

    protected $table = 'alphasite_communities';

    protected $fillable = [
        'city',
        'state',
        'country',
        'slug',
        'name',
        'description',
        'hero_image_url',
        'logo_url',
        'total_businesses',
        'premium_businesses',
        'total_categories',
        'seo_title',
        'seo_description',
        'featured_categories',
        'is_active',
        'launched_at',
    ];

    protected function casts(): array
    {
        return [
            'featured_categories' => 'array',
            'is_active' => 'boolean',
            'launched_at' => 'datetime',
        ];
    }

    public function businesses(): HasMany
    {
        return $this->hasMany(Business::class, 'city', 'city')
            ->where('state', $this->state)
            ->where('status', 'active');
    }

    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }
}
```

### Announcement
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use App\Traits\HasReviewsAndRatings;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\MorphMany;

final class Announcement extends Model
{
    use HasFactory, HasUuid, HasReviewsAndRatings, \App\Traits\RelatableToOrganizations;

    protected $fillable = [
        'user_id',
        'workspace_id',
        'type',
        'title',
        'content',
        'image',
        'location',
        'event_date',
        'status',
        'published_at',
        'expires_at',
        'views_count',
        'reactions_count',
        'comments_count',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function workspace(): BelongsTo
    {
        return $this->belongsTo(Workspace::class);
    }

    public function regions(): BelongsToMany
    {
        return $this->belongsToMany(Region::class, 'announcement_region')
            ->withTimestamps();
    }

    public function comments(): MorphMany
    {
        return $this->morphMany(ArticleComment::class, 'article_id'); // Reuse ArticleComment pattern
    }

    // Scopes
    public function scopePublished($query)
    {
        return $query->where('status', 'published')
            ->whereNotNull('published_at')
            ->where(function ($q) {
                $q->whereNull('expires_at')
                    ->orWhere('expires_at', '>', now());
            });
    }

    public function scopeByType($query, string $type)
    {
        return $query->where('type', $type);
    }

    public function scopeUpcoming($query)
    {
        return $query->where(function ($q) {
            $q->whereNull('event_date')
                ->orWhere('event_date', '>=', now()->toDateString());
        });
    }

    public function scopeForRegion($query, int $regionId)
    {
        return $query->whereHas('regions', function ($q) use ($regionId) {
            $q->where('region_id', $regionId);
        });
    }

    public function incrementViewsCount(): void
    {
        $this->increment('views_count');
    }

    public function incrementReactionsCount(): void
    {
        $this->increment('reactions_count');
    }

    public function incrementCommentsCount(): void
    {
        $this->increment('comments_count');
    }

    protected function casts(): array
    {
        return [
            'event_date' => 'date',
            'published_at' => 'datetime',
            'expires_at' => 'datetime',
            'views_count' => 'integer',
            'reactions_count' => 'integer',
            'comments_count' => 'integer',
        ];
    }
}

```

### ArticleComment
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\MorphMany;

final class ArticleComment extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'article_id',
        'user_id',
        'parent_id',
        'content',
        'is_active',
        'is_pinned',
        'reports_count',
    ];

    public function article(): BelongsTo
    {
        return $this->belongsTo(DayNewsPost::class, 'article_id');
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function parent(): BelongsTo
    {
        return $this->belongsTo(self::class, 'parent_id');
    }

    public function replies(): HasMany
    {
        return $this->hasMany(self::class, 'parent_id');
    }

    public function likes(): HasMany
    {
        return $this->hasMany(ArticleCommentLike::class, 'comment_id');
    }

    public function activities(): MorphMany
    {
        return $this->morphMany(SocialActivity::class, 'subject');
    }

    public function isLikedBy(User $user): bool
    {
        return $this->likes()->where('user_id', $user->id)->exists();
    }

    public function likesCount(): int
    {
        return $this->likes()->count();
    }

    public function repliesCount(): int
    {
        return $this->replies()->where('is_active', true)->count();
    }

    // Scopes
    public function scopeTopLevel($query)
    {
        return $query->whereNull('parent_id');
    }

    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    public function scopePinned($query)
    {
        return $query->where('is_pinned', true);
    }

    public function scopeBest($query)
    {
        // Sort by likes count, then by created_at
        return $query->withCount('likes')
            ->orderBy('likes_count', 'desc')
            ->orderBy('created_at', 'desc');
    }

    public function scopeNewest($query)
    {
        return $query->orderBy('created_at', 'desc');
    }

    public function scopeOldest($query)
    {
        return $query->orderBy('created_at', 'asc');
    }

    protected function casts(): array
    {
        return [
            'is_active' => 'boolean',
            'is_pinned' => 'boolean',
            'reports_count' => 'integer',
        ];
    }
}

```

### ArticleCommentLike
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class ArticleCommentLike extends Model
{
    use HasFactory;

    protected $fillable = [
        'comment_id',
        'user_id',
    ];

    public function comment(): BelongsTo
    {
        return $this->belongsTo(ArticleComment::class, 'comment_id');
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }
}

```

### Booking
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Support\Str;

final class Booking extends Model
{
    /** @use HasFactory<\Database\Factories\BookingFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'booking_number',
        'status',
        'booking_type',
        'event_id',
        'venue_id',
        'performer_id',
        'user_id',
        'contact_name',
        'contact_email',
        'contact_phone',
        'contact_company',
        'event_date',
        'start_time',
        'end_time',
        'event_type',
        'expected_guests',
        'expected_audience',
        'ticket_quantity',
        'ticket_type',
        'price_per_ticket',
        'payment_status',
        'total_amount',
        'currency',
        'paid_amount',
        'payment_method',
        'transaction_id',
        'payment_date',
        'refund_amount',
        'refund_date',
        'notes',
        'special_requests',
        'setup_requirements',
        'catering_requirements',
        'performance_requirements',
        'sound_requirements',
        'confirmed_at',
        'cancelled_at',
        'cancellation_reason',
        'workspace_id',
        'created_by',
        'metadata',
    ];

    public function event(): BelongsTo
    {
        return $this->belongsTo(Event::class);
    }

    public function venue(): BelongsTo
    {
        return $this->belongsTo(Venue::class);
    }

    public function performer(): BelongsTo
    {
        return $this->belongsTo(Performer::class);
    }

    public function workspace(): BelongsTo
    {
        return $this->belongsTo(Workspace::class);
    }

    public function createdBy(): BelongsTo
    {
        return $this->belongsTo(User::class, 'created_by');
    }

    // Computed attributes for frontend compatibility
    public function getContactInfoAttribute(): array
    {
        return [
            'name' => $this->contact_name,
            'email' => $this->contact_email,
            'phone' => $this->contact_phone,
            'company' => $this->contact_company,
        ];
    }

    public function getPaymentAttribute(): array
    {
        return [
            'status' => $this->payment_status,
            'totalAmount' => $this->total_amount,
            'currency' => $this->currency,
            'paidAmount' => $this->paid_amount,
            'paymentMethod' => $this->payment_method,
            'transactionId' => $this->transaction_id,
            'paymentDate' => $this->payment_date?->toISOString(),
            'refundAmount' => $this->refund_amount,
            'refundDate' => $this->refund_date?->toISOString(),
        ];
    }

    // Scopes
    public function scopeByStatus($query, string $status)
    {
        return $query->where('status', $status);
    }

    public function scopeByType($query, string $type)
    {
        return $query->where('booking_type', $type);
    }

    public function scopePending($query)
    {
        return $query->where('status', 'pending');
    }

    public function scopeConfirmed($query)
    {
        return $query->where('status', 'confirmed');
    }

    public function scopeForDate($query, string $date)
    {
        return $query->where('event_date', $date);
    }

    public function scopeForDateRange($query, string $from, string $to)
    {
        return $query->whereBetween('event_date', [$from, $to]);
    }

    public function scopeEventBookings($query)
    {
        return $query->where('booking_type', 'event');
    }

    public function scopeVenueBookings($query)
    {
        return $query->where('booking_type', 'venue');
    }

    public function scopePerformerBookings($query)
    {
        return $query->where('booking_type', 'performer');
    }

    // Helper methods
    public function isEventBooking(): bool
    {
        return $this->booking_type === 'event';
    }

    public function isVenueBooking(): bool
    {
        return $this->booking_type === 'venue';
    }

    public function isPerformerBooking(): bool
    {
        return $this->booking_type === 'performer';
    }

    public function isPaid(): bool
    {
        return $this->payment_status === 'paid';
    }

    public function isPartiallyPaid(): bool
    {
        return $this->payment_status === 'partially_paid';
    }

    public function isPending(): bool
    {
        return $this->status === 'pending';
    }

    public function isConfirmed(): bool
    {
        return $this->status === 'confirmed';
    }

    public function isCancelled(): bool
    {
        return $this->status === 'cancelled';
    }

    public function markAsConfirmed(): void
    {
        $this->update([
            'status' => 'confirmed',
            'confirmed_at' => now(),
        ]);
    }

    public function markAsCancelled(?string $reason = null): void
    {
        $this->update([
            'status' => 'cancelled',
            'cancelled_at' => now(),
            'cancellation_reason' => $reason,
        ]);
    }

    protected static function boot(): void
    {
        parent::boot();

        self::creating(function ($booking) {
            if (empty($booking->booking_number)) {
                $booking->booking_number = 'BK-'.mb_strtoupper(Str::random(8));
            }
        });
    }

    protected function casts(): array
    {
        return [
            'event_date' => 'date',
            'start_time' => 'datetime:H:i',
            'end_time' => 'datetime:H:i',
            'total_amount' => 'decimal:2',
            'paid_amount' => 'decimal:2',
            'price_per_ticket' => 'decimal:2',
            'refund_amount' => 'decimal:2',
            'payment_date' => 'datetime',
            'refund_date' => 'datetime',
            'confirmed_at' => 'datetime',
            'cancelled_at' => 'datetime',
            'special_requests' => 'array',
            'setup_requirements' => 'array',
            'catering_requirements' => 'array',
            'performance_requirements' => 'array',
            'sound_requirements' => 'array',
        ];
    }
}
```

### Business
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\MorphTo;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Support\Str;

final class Business extends Model
{
    /** @use HasFactory<\Database\Factories\BusinessFactory> */
    use HasFactory, HasUuid, SoftDeletes;

    protected $fillable = [
        'workspace_id',
        'google_place_id',
        'name',
        'slug',
        'description',
        'website',
        'phone',
        'email',
        'address',
        'city',
        'state',
        'postal_code',
        'country',
        'latitude',
        'longitude',
        'categories',
        'rating',
        'reviews_count',
        'opening_hours',
        'images',
        'serp_metadata',
        // SERP API: Multiple identifiers
        'data_id',
        'data_cid',
        'lsig',
        'provider_id',
        'local_services_cid',
        'local_services_bid',
        'local_services_pid',
        // SERP API: Source tracking
        'serp_source',
        'serp_last_synced_at',
        // SERP API: Business type
        'primary_type',
        'type_id',
        'type_ids',
        // SERP API: Pricing and hours
        'price_level',
        'open_state',
        'hours_display',
        // SERP API: Local Services
        'google_badge',
        'service_area',
        'years_in_business',
        'bookings_nearby',
        // SERP API: Enhanced verification
        'verification_status',
        'verified_at',
        'claimed_at',
        'is_verified', // Backward compatibility
        // SERP API: Service options and URLs
        'service_options',
        'reserve_url',
        'order_online_url',
        'status',
        'claimable_type',
        'claimable_id',
        // Organization fields
        'organization_type',
        'organization_level',
        'parent_organization_id',
        'organization_category',
        'is_organization',
        'organization_identifier',
        'organization_hierarchy',
        // AlphaSite fields
        'alphasite_subdomain',
        'template_id',
        'ai_services_enabled',
        'premium_enrolled_at',
        'premium_expires_at',
        'subscription_tier',
        'homepage_content',
        'social_links',
        'amenities',
        'featured',
        'promoted',
        'seo_metadata',
        'industry_id',
    ];

    public function workspace(): BelongsTo
    {
        return $this->belongsTo(Workspace::class);
    }

    public function regions(): BelongsToMany
    {
        return $this->belongsToMany(Region::class)->withTimestamps();
    }

    public function claimable(): MorphTo
    {
        return $this->morphTo();
    }

    public function rssFeeds(): HasMany
    {
        return $this->hasMany(RssFeed::class);
    }

    public function healthyRssFeeds(): HasMany
    {
        return $this->hasMany(RssFeed::class)
            ->where('health_status', 'healthy')
            ->where('status', 'active');
    }

    // Organization relationships
    public function parentOrganization(): BelongsTo
    {
        return $this->belongsTo(Business::class, 'parent_organization_id');
    }

    public function childOrganizations(): HasMany
    {
        return $this->hasMany(Business::class, 'parent_organization_id');
    }

    public function organizationRelationships(): HasMany
    {
        return $this->hasMany(\App\Models\OrganizationRelationship::class, 'organization_id');
    }

    public function relatedContent(string $type = null): HasMany
    {
        $query = $this->hasMany(\App\Models\OrganizationRelationship::class, 'organization_id');
        if ($type) {
            $query->where('relatable_type', $type);
        }
        return $query;
    }

    // AlphaSite relationships
    public function industry(): BelongsTo
    {
        return $this->belongsTo(Industry::class);
    }

    public function template(): BelongsTo
    {
        return $this->belongsTo(BusinessTemplate::class, 'template_id');
    }

    public function subscription(): BelongsTo
    {
        return $this->belongsTo(BusinessSubscription::class, 'business_id');
    }

    public function achievements(): HasMany
    {
        return $this->hasMany(Achievement::class);
    }

    public function featuredAchievements(): HasMany
    {
        return $this->hasMany(Achievement::class)->where('is_featured', true);
    }

    public function faqs(): HasMany
    {
        return $this->hasMany(BusinessFaq::class);
    }

    public function activeFaqs(): HasMany
    {
        return $this->hasMany(BusinessFaq::class)->where('is_active', true);
    }

    public function surveys(): HasMany
    {
        return $this->hasMany(BusinessSurvey::class);
    }

    public function activeSurveys(): HasMany
    {
        return $this->hasMany(BusinessSurvey::class)->where('is_active', true);
    }

    public function crmCustomers(): HasMany
    {
        return $this->hasMany(SMBCrmCustomer::class);
    }

    public function crmInteractions(): HasMany
    {
        return $this->hasMany(SMBCrmInteraction::class);
    }

    // Scopes
    public function scopeActive($query)
    {
        return $query->where('status', 'active');
    }

    public function scopeInactive($query)
    {
        return $query->where('status', 'inactive');
    }

    public function scopeVerified($query)
    {
        return $query->where('is_verified', true);
    }

    public function scopeClaimed($query)
    {
        return $query->whereNotNull('workspace_id');
    }

    public function scopeUnclaimed($query)
    {
        return $query->whereNull('workspace_id');
    }

    public function scopeInRegion($query, string $regionId)
    {
        return $query->whereHas('regions', function ($q) use ($regionId) {
            $q->where('regions.id', $regionId);
        });
    }

    public function scopeWithHealthyFeeds($query)
    {
        return $query->whereHas('rssFeeds', function ($q) {
            $q->where('health_status', 'healthy')
                ->where('status', 'active');
        });
    }

    public function scopeByCategory($query, string $category)
    {
        return $query->whereJsonContains('categories', $category);
    }

    // Organization scopes
    public function scopeOrganizations($query)
    {
        return $query->where('is_organization', true);
    }

    public function scopeByOrganizationType($query, string $type)
    {
        return $query->where('organization_type', $type);
    }

    public function scopeByOrganizationLevel($query, string $level)
    {
        return $query->where('organization_level', $level);
    }

    public function scopeGovernment($query)
    {
        return $query->where('organization_type', 'government');
    }

    public function scopeNational($query)
    {
        return $query->where(function ($q) {
            $q->where('organization_level', 'national')
              ->orWhere('organization_level', 'international');
        });
    }

    public function scopeLocal($query)
    {
        return $query->where('organization_level', 'local');
    }

    public function scopeWithinRadius($query, float $lat, float $lng, float $radius)
    {
        // Haversine formula for distance calculation (in kilometers)
        return $query->selectRaw('
            *,
            (6371 * acos(cos(radians(?))
            * cos(radians(latitude))
            * cos(radians(longitude) - radians(?))
            + sin(radians(?))
            * sin(radians(latitude)))) AS distance
        ', [$lat, $lng, $lat])
            ->whereRaw('
            (6371 * acos(cos(radians(?))
            * cos(radians(latitude))
            * cos(radians(longitude) - radians(?))
            + sin(radians(?))
            * sin(radians(latitude)))) < ?
        ', [$lat, $lng, $lat, $radius]);
    }

    // Helper methods
    public function isClaimed(): bool
    {
        return $this->workspace_id !== null;
    }

    public function isVerified(): bool
    {
        return $this->is_verified === true;
    }

    public function isActive(): bool
    {
        return $this->status === 'active';
    }

    public function hasHealthyFeeds(): bool
    {
        return $this->healthyRssFeeds()->exists();
    }

    public function getLocationAttribute(): array
    {
        return [
            'address' => $this->address,
            'city' => $this->city,
            'state' => $this->state,
            'postal_code' => $this->postal_code,
            'country' => $this->country,
            'coordinates' => [
                'lat' => $this->latitude,
                'lng' => $this->longitude,
            ],
        ];
    }

    protected static function boot(): void
    {
        parent::boot();

        self::creating(function (Business $business) {
            if (empty($business->slug)) {
                $business->slug = Str::slug($business->name);
            }
        });
    }

    protected function casts(): array
    {
        return [
            'categories' => 'array',
            'opening_hours' => 'array',
            'images' => 'array',
            'serp_metadata' => 'array',
            'type_ids' => 'array',
            'service_area' => 'array',
            'service_options' => 'array',
            'is_verified' => 'boolean',
            'is_organization' => 'boolean',
            'organization_hierarchy' => 'array',
            // AlphaSite casts
            'ai_services_enabled' => 'boolean',
            'premium_enrolled_at' => 'datetime',
            'premium_expires_at' => 'datetime',
            'homepage_content' => 'array',
            'social_links' => 'array',
            'amenities' => 'array',
            'featured' => 'boolean',
            'promoted' => 'boolean',
            'seo_metadata' => 'array',
            'rating' => 'decimal:2',
            'latitude' => 'decimal:8',
            'longitude' => 'decimal:8',
            'reviews_count' => 'integer',
            'years_in_business' => 'integer',
            'bookings_nearby' => 'integer',
            'serp_last_synced_at' => 'datetime',
            'verified_at' => 'datetime',
            'claimed_at' => 'datetime',
        ];
    }
}
```

### BusinessAttribute
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class BusinessAttribute extends Model
{
    /** @use HasFactory<\Database\Factories\BusinessAttributeFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'smb_business_id',
        'attribute_key',
        'attribute_value',
        'attribute_type',
    ];

    protected function casts(): array
    {
        return [
            'attribute_value' => match ($this->attribute_type) {
                'array' => 'array',
                'boolean' => 'boolean',
                default => 'string',
            },
        ];
    }

    public function smbBusiness(): BelongsTo
    {
        return $this->belongsTo(SmbBusiness::class);
    }
}
```

### BusinessFaq
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class BusinessFaq extends Model
{
    use HasFactory, HasUuid;

    protected $table = 'business_faqs';

    protected $fillable = [
        'business_id',
        'question',
        'answer',
        'category',
        'tags',
        'variations',
        'follow_up_questions',
        'times_used',
        'helpful_votes',
        'unhelpful_votes',
        'is_active',
        'display_order',
    ];

    protected function casts(): array
    {
        return [
            'tags' => 'array',
            'variations' => 'array',
            'follow_up_questions' => 'array',
            'is_active' => 'boolean',
        ];
    }

    public function business(): BelongsTo
    {
        return $this->belongsTo(Business::class);
    }

    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }
}
```

### BusinessHours
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class BusinessHours extends Model
{
    /** @use HasFactory<\Database\Factories\BusinessHoursFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'smb_business_id',
        'day_of_week',
        'open_time',
        'close_time',
        'is_closed',
        'is_24_hours',
    ];

    protected function casts(): array
    {
        return [
            'open_time' => 'datetime:H:i',
            'close_time' => 'datetime:H:i',
            'is_closed' => 'boolean',
            'is_24_hours' => 'boolean',
        ];
    }

    public function smbBusiness(): BelongsTo
    {
        return $this->belongsTo(SmbBusiness::class);
    }

    public function getDayNameAttribute(): string
    {
        $days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        return $days[$this->day_of_week] ?? 'Unknown';
    }
}
```

### BusinessPhoto
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class BusinessPhoto extends Model
{
    /** @use HasFactory<\Database\Factories\BusinessPhotoFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'smb_business_id',
        'photo_reference',
        'width',
        'height',
        'html_attributions',
        'is_primary',
        'display_order',
    ];

    protected function casts(): array
    {
        return [
            'html_attributions' => 'array',
            'is_primary' => 'boolean',
        ];
    }

    public function smbBusiness(): BelongsTo
    {
        return $this->belongsTo(SmbBusiness::class);
    }
}
```

### BusinessReview
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class BusinessReview extends Model
{
    /** @use HasFactory<\Database\Factories\BusinessReviewFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'smb_business_id',
        'author_name',
        'author_url',
        'language',
        'profile_photo_url',
        'rating',
        'relative_time_description',
        'text',
        'time',
    ];

    protected function casts(): array
    {
        return [
            'time' => 'datetime',
        ];
    }

    public function smbBusiness(): BelongsTo
    {
        return $this->belongsTo(SmbBusiness::class);
    }

    public function isPositive(): bool
    {
        return $this->rating >= 4;
    }

    public function isNegative(): bool
    {
        return $this->rating <= 2;
    }
}
```

### BusinessSubscription
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class BusinessSubscription extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'business_id',
        'tier',
        'status',
        'trial_started_at',
        'trial_expires_at',
        'trial_converted_at',
        'subscription_started_at',
        'subscription_expires_at',
        'auto_renew',
        'stripe_subscription_id',
        'stripe_customer_id',
        'monthly_amount',
        'billing_cycle',
        'ai_services_enabled',
        'claimed_by_id',
        'claimed_at',
        'downgraded_at',
    ];

    protected function casts(): array
    {
        return [
            'trial_started_at' => 'datetime',
            'trial_expires_at' => 'datetime',
            'trial_converted_at' => 'datetime',
            'subscription_started_at' => 'datetime',
            'subscription_expires_at' => 'datetime',
            'claimed_at' => 'datetime',
            'downgraded_at' => 'datetime',
            'auto_renew' => 'boolean',
            'monthly_amount' => 'decimal:2',
            'ai_services_enabled' => 'array',
        ];
    }

    public function business(): BelongsTo
    {
        return $this->belongsTo(Business::class);
    }

    public function claimedBy(): BelongsTo
    {
        return $this->belongsTo(User::class, 'claimed_by_id');
    }

    public function isTrial(): bool
    {
        return $this->tier === 'trial' && 
               $this->status === 'active' && 
               $this->trial_expires_at > now();
    }

    public function isPremium(): bool
    {
        return in_array($this->tier, ['standard', 'premium', 'enterprise']) &&
               $this->status === 'active';
    }

    public function isExpired(): bool
    {
        if ($this->tier === 'trial') {
            return $this->trial_expires_at < now();
        }
        
        return $this->subscription_expires_at && $this->subscription_expires_at < now();
    }
}
```

### BusinessSurvey
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class BusinessSurvey extends Model
{
    use HasFactory, HasUuid;

    protected $table = 'business_surveys';

    protected $fillable = [
        'business_id',
        'name',
        'description',
        'survey_type',
        'questions',
        'trigger_type',
        'trigger_config',
        'is_active',
        'responses_count',
        'average_score',
    ];

    protected function casts(): array
    {
        return [
            'questions' => 'array',
            'trigger_config' => 'array',
            'is_active' => 'boolean',
            'average_score' => 'decimal:2',
        ];
    }

    public function business(): BelongsTo
    {
        return $this->belongsTo(Business::class);
    }

    public function responses(): HasMany
    {
        return $this->hasMany(BusinessSurveyResponse::class, 'survey_id');
    }

    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }
}
```

### BusinessSurveyResponse
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class BusinessSurveyResponse extends Model
{
    use HasFactory, HasUuid;

    protected $table = 'business_survey_responses';

    public $timestamps = true;
    protected $dateFormat = 'U';

    protected $fillable = [
        'survey_id',
        'business_id',
        'customer_id',
        'responses',
        'overall_score',
        'sentiment',
        'ai_summary',
        'action_items',
        'completed_at',
        'source',
    ];

    protected function casts(): array
    {
        return [
            'responses' => 'array',
            'overall_score' => 'decimal:2',
            'action_items' => 'array',
            'completed_at' => 'datetime',
        ];
    }

    public function survey(): BelongsTo
    {
        return $this->belongsTo(BusinessSurvey::class, 'survey_id');
    }

    public function business(): BelongsTo
    {
        return $this->belongsTo(Business::class);
    }

    public function customer(): BelongsTo
    {
        return $this->belongsTo(SMBCrmCustomer::class, 'customer_id');
    }
}
```

### BusinessTemplate
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class BusinessTemplate extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'name',
        'slug',
        'description',
        'industry_id',
        'layout_config',
        'available_tabs',
        'default_tabs',
        'ai_features',
        'theme_config',
        'component_overrides',
        'seo_template',
        'schema_template',
        'is_premium',
        'is_active',
    ];

    protected function casts(): array
    {
        return [
            'layout_config' => 'array',
            'available_tabs' => 'array',
            'default_tabs' => 'array',
            'ai_features' => 'array',
            'theme_config' => 'array',
            'component_overrides' => 'array',
            'seo_template' => 'array',
            'schema_template' => 'array',
            'is_premium' => 'boolean',
            'is_active' => 'boolean',
        ];
    }

    public function industry(): BelongsTo
    {
        return $this->belongsTo(Industry::class);
    }

    public function businesses(): HasMany
    {
        return $this->hasMany(Business::class, 'template_id');
    }

    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }
}
```

### Calendar
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\MorphMany;

final class Calendar extends Model
{
    /** @use HasFactory<\Database\Factories\CalendarFactory> */
    use HasFactory, HasUuids;

    protected $fillable = [
        'user_id',
        'title',
        'description',
        'category',
        'image',
        'about',
        'location',
        'update_frequency',
        'subscription_price',
        'is_private',
        'is_verified',
        'followers_count',
        'events_count',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function followers(): BelongsToMany
    {
        return $this->belongsToMany(User::class, 'calendar_followers')
            ->withTimestamps();
    }

    public function events(): BelongsToMany
    {
        return $this->belongsToMany(Event::class, 'calendar_events')
            ->withPivot(['added_by', 'position'])
            ->withTimestamps()
            ->orderBy('calendar_events.position');
    }

    public function roles(): HasMany
    {
        return $this->hasMany(CalendarRole::class);
    }

    public function editors(): BelongsToMany
    {
        return $this->belongsToMany(User::class, 'calendar_roles')
            ->withPivot('role')
            ->withTimestamps();
    }

    public function follows(): MorphMany
    {
        return $this->morphMany(Follow::class, 'followable');
    }

    public function scopePublic($query)
    {
        return $query->where('is_private', false);
    }

    public function scopePrivate($query)
    {
        return $query->where('is_private', true);
    }

    public function scopeFree($query)
    {
        return $query->where('subscription_price', 0);
    }

    public function scopePaid($query)
    {
        return $query->where('subscription_price', '>', 0);
    }

    public function scopeByCategory($query, string $category)
    {
        return $query->where('category', $category);
    }

    public function scopeVerified($query)
    {
        return $query->where('is_verified', true);
    }

    protected function casts(): array
    {
        return [
            'subscription_price' => 'decimal:2',
            'is_private' => 'boolean',
            'is_verified' => 'boolean',
            'followers_count' => 'integer',
            'events_count' => 'integer',
        ];
    }
}
```

### CalendarEvent
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class CalendarEvent extends Model
{
    use HasFactory;
    protected $fillable = [
        'calendar_id',
        'event_id',
        'added_by',
        'position',
    ];

    public function calendar(): BelongsTo
    {
        return $this->belongsTo(Calendar::class);
    }

    public function event(): BelongsTo
    {
        return $this->belongsTo(Event::class);
    }

    public function addedBy(): BelongsTo
    {
        return $this->belongsTo(User::class, 'added_by');
    }

    protected function casts(): array
    {
        return [
            'position' => 'integer',
        ];
    }
}
```

### CalendarFollower
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class CalendarFollower extends Model
{
    use HasFactory;
    protected $fillable = [
        'calendar_id',
        'user_id',
    ];

    public function calendar(): BelongsTo
    {
        return $this->belongsTo(Calendar::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }
}
```

### CalendarRole
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class CalendarRole extends Model
{
    use HasFactory;
    protected $fillable = [
        'calendar_id',
        'user_id',
        'role',
    ];

    public function calendar(): BelongsTo
    {
        return $this->belongsTo(Calendar::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }
}
```

### Campaign
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;

final class Campaign extends Model
{
    /** @use HasFactory<\Database\Factories\CampaignFactory> */
    use HasFactory, HasUuid, SoftDeletes;

    protected $fillable = [
        'tenant_id',
        'name',
        'type',
        'status',
        'start_date',
        'end_date',
        'budget',
        'spent',
        'target_audience',
        'content',
        'metadata',
    ];

    protected function casts(): array
    {
        return [
            'start_date' => 'datetime',
            'end_date' => 'datetime',
            'budget' => 'decimal:2',
            'spent' => 'decimal:2',
            'target_audience' => 'array',
            'metadata' => 'array',
        ];
    }

    public function tenant(): BelongsTo
    {
        return $this->belongsTo(Tenant::class);
    }

    public function recipients(): HasMany
    {
        return $this->hasMany(CampaignRecipient::class);
    }

    public function isActive(): bool
    {
        return $this->status === 'active';
    }

    public function isCompleted(): bool
    {
        return $this->status === 'completed';
    }
}
```

### CampaignRecipient
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class CampaignRecipient extends Model
{
    /** @use HasFactory<\Database\Factories\CampaignRecipientFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'campaign_id',
        'customer_id',
        'status',
        'sent_at',
        'delivered_at',
        'opened_at',
        'clicked_at',
        'bounced_at',
        'unsubscribed_at',
        'metadata',
    ];

    protected function casts(): array
    {
        return [
            'sent_at' => 'datetime',
            'delivered_at' => 'datetime',
            'opened_at' => 'datetime',
            'clicked_at' => 'datetime',
            'bounced_at' => 'datetime',
            'unsubscribed_at' => 'datetime',
            'metadata' => 'array',
        ];
    }

    public function campaign(): BelongsTo
    {
        return $this->belongsTo(Campaign::class);
    }

    public function customer(): BelongsTo
    {
        return $this->belongsTo(Customer::class);
    }

    public function hasOpened(): bool
    {
        return $this->opened_at !== null;
    }

    public function hasClicked(): bool
    {
        return $this->clicked_at !== null;
    }

    public function hasBounced(): bool
    {
        return $this->bounced_at !== null;
    }
}
```

### Cart
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class Cart extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'user_id',
        'session_id',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function items(): HasMany
    {
        return $this->hasMany(CartItem::class);
    }

    public function getItemsCountAttribute(): int
    {
        return $this->items()->sum('quantity');
    }

    public function getTotalAttribute(): float
    {
        return $this->items()->get()->sum(function ($item) {
            return $item->price * $item->quantity;
        });
    }

    public function getStoreIdsAttribute(): array
    {
        return $this->items()->distinct('store_id')->pluck('store_id')->toArray();
    }
}
```

### CartItem
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class CartItem extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'cart_id',
        'product_id',
        'store_id',
        'quantity',
        'price',
    ];

    protected $casts = [
        'price' => 'decimal:2',
    ];

    public function cart(): BelongsTo
    {
        return $this->belongsTo(Cart::class);
    }

    public function product(): BelongsTo
    {
        return $this->belongsTo(Product::class);
    }

    public function store(): BelongsTo
    {
        return $this->belongsTo(Store::class);
    }

    public function getTotalAttribute(): float
    {
        return $this->price * $this->quantity;
    }
}
```

### CheckIn
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class CheckIn extends Model
{
    /** @use HasFactory<\Database\Factories\CheckInFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'event_id',
        'user_id',
        'checked_in_at',
        'location',
        'latitude',
        'longitude',
        'notes',
        'is_public',
    ];

    protected function casts(): array
    {
        return [
            'checked_in_at' => 'datetime',
            'latitude' => 'decimal:8',
            'longitude' => 'decimal:8',
            'is_public' => 'boolean',
        ];
    }

    public function event(): BelongsTo
    {
        return $this->belongsTo(Event::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function scopeForEvent($query, string $eventId)
    {
        return $query->where('event_id', $eventId);
    }

    public function scopeForUser($query, string $userId)
    {
        return $query->where('user_id', $userId);
    }

    public function scopePublic($query)
    {
        return $query->where('is_public', true);
    }

    public function scopeRecent($query, int $hours = 24)
    {
        return $query->where('checked_in_at', '>=', now()->subHours($hours));
    }
}

```

### Classified
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;

final class Classified extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'user_id',
        'workspace_id',
        'category',
        'subcategory',
        'title',
        'description',
        'price',
        'price_type',
        'condition',
        'location',
        'is_featured',
        'status',
        'posted_at',
        'expires_at',
        'views_count',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function workspace(): BelongsTo
    {
        return $this->belongsTo(Workspace::class);
    }

    public function images(): HasMany
    {
        return $this->hasMany(ClassifiedImage::class, 'classified_id')->orderBy('order');
    }

    public function regions(): BelongsToMany
    {
        return $this->belongsToMany(Region::class, 'classified_region')
            ->withPivot('days')
            ->withTimestamps();
    }

    public function payment(): HasOne
    {
        return $this->hasOne(ClassifiedPayment::class, 'classified_id');
    }

    // Scopes
    public function scopeActive($query)
    {
        return $query->where('status', 'active')
            ->where(function ($q) {
                $q->whereNull('expires_at')
                    ->orWhere('expires_at', '>', now());
            });
    }

    public function scopeByCategory($query, string $category)
    {
        return $query->where('category', $category);
    }

    public function scopeFeatured($query)
    {
        return $query->where('is_featured', true);
    }

    public function scopeForRegion($query, int $regionId)
    {
        return $query->whereHas('regions', function ($q) use ($regionId) {
            $q->where('region_id', $regionId);
        });
    }

    public function incrementViewsCount(): void
    {
        $this->increment('views_count');
    }

    public function isExpired(): bool
    {
        return $this->expires_at !== null && $this->expires_at->isPast();
    }

    protected function casts(): array
    {
        return [
            'price' => 'decimal:2',
            'is_featured' => 'boolean',
            'posted_at' => 'datetime',
            'expires_at' => 'datetime',
            'views_count' => 'integer',
        ];
    }
}

```

### ClassifiedImage
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class ClassifiedImage extends Model
{
    use HasFactory;

    protected $fillable = [
        'classified_id',
        'image_path',
        'image_disk',
        'order',
    ];

    public function classified(): BelongsTo
    {
        return $this->belongsTo(Classified::class, 'classified_id');
    }

    public function getImageUrlAttribute(): string
    {
        return \Illuminate\Support\Facades\Storage::disk($this->image_disk)->url($this->image_path);
    }
}

```

### ClassifiedPayment
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class ClassifiedPayment extends Model
{
    use HasFactory;

    protected $fillable = [
        'classified_id',
        'workspace_id',
        'stripe_payment_intent_id',
        'stripe_checkout_session_id',
        'amount',
        'currency',
        'status',
        'regions_data',
        'total_days',
    ];

    public function classified(): BelongsTo
    {
        return $this->belongsTo(Classified::class, 'classified_id');
    }

    public function workspace(): BelongsTo
    {
        return $this->belongsTo(Workspace::class);
    }

    public function isPaid(): bool
    {
        return $this->status === 'paid';
    }

    public function markAsPaid(): void
    {
        $this->update(['status' => 'paid']);
    }

    public function markAsFailed(): void
    {
        $this->update(['status' => 'failed']);
    }

    public function getAmountInDollars(): float
    {
        return $this->amount / 100;
    }

    protected function casts(): array
    {
        return [
            'amount' => 'integer',
            'regions_data' => 'array',
            'total_days' => 'integer',
        ];
    }
}

```

### CommentReport
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class CommentReport extends Model
{
    use HasFactory;

    protected $fillable = [
        'comment_id',
        'user_id',
        'reason',
        'details',
        'status',
    ];

    public function comment(): BelongsTo
    {
        return $this->belongsTo(ArticleComment::class, 'comment_id');
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    protected function casts(): array
    {
        return [
            'status' => 'string',
        ];
    }
}

```

### Community
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class Community extends Model
{
    /** @use HasFactory<\Database\Factories\CommunityFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'slug',
        'name',
        'description',
        'image',
        'categories',
        'thread_types',
        'popular_tags',
        'guidelines',
        'total_events',
        'is_active',
        'is_featured',
        'last_activity',
        'workspace_id',
        'created_by',
    ];

    public function workspace(): BelongsTo
    {
        return $this->belongsTo(Workspace::class);
    }

    public function createdBy(): BelongsTo
    {
        return $this->belongsTo(User::class, 'created_by');
    }

    public function threads(): HasMany
    {
        return $this->hasMany(CommunityThread::class);
    }

    public function members(): HasMany
    {
        return $this->hasMany(CommunityMember::class);
    }

    public function activeMembers(): HasMany
    {
        return $this->hasMany(CommunityMember::class)->active();
    }

    // Computed attributes
    public function getMemberCountAttribute(): int
    {
        return $this->activeMembers()->count();
    }

    public function getActiveTodayAttribute(): int
    {
        return $this->activeMembers()->recentlyActive(1)->count();
    }

    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    protected function casts(): array
    {
        return [
            'categories' => 'array',
            'thread_types' => 'array',
            'popular_tags' => 'array',
            'is_active' => 'boolean',
            'is_featured' => 'boolean',
            'last_activity' => 'datetime',
        ];
    }
}
```

### CommunityMember
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class CommunityMember extends Model
{
    /** @use HasFactory<\Database\Factories\CommunityMemberFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'community_id',
        'user_id',
        'role',
        'joined_at',
        'is_active',
        'last_activity_at',
    ];

    public function community(): BelongsTo
    {
        return $this->belongsTo(Community::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    // Scopes
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    public function scopeByRole($query, string $role)
    {
        return $query->where('role', $role);
    }

    public function scopeRecentlyActive($query, int $days = 30)
    {
        return $query->where('last_activity_at', '>=', now()->subDays($days));
    }

    protected function casts(): array
    {
        return [
            'joined_at' => 'datetime',
            'is_active' => 'boolean',
            'last_activity_at' => 'datetime',
        ];
    }
}
```

### CommunityThread
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class CommunityThread extends Model
{
    /** @use HasFactory<\Database\Factories\CommunityThreadFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'title',
        'content',
        'preview',
        'type',
        'tags',
        'images',
        'is_pinned',
        'is_locked',
        'is_featured',
        'last_reply_at',
        'last_reply_by',
        'community_id',
        'author_id',
    ];

    public function community(): BelongsTo
    {
        return $this->belongsTo(Community::class);
    }

    public function author(): BelongsTo
    {
        return $this->belongsTo(User::class, 'author_id');
    }

    public function lastReplyBy(): BelongsTo
    {
        return $this->belongsTo(User::class, 'last_reply_by');
    }

    public function replies(): HasMany
    {
        return $this->hasMany(CommunityThreadReply::class, 'thread_id');
    }

    public function views(): HasMany
    {
        return $this->hasMany(CommunityThreadView::class, 'thread_id');
    }

    public function topLevelReplies(): HasMany
    {
        return $this->hasMany(CommunityThreadReply::class, 'thread_id')->topLevel();
    }

    public function solutions(): HasMany
    {
        return $this->hasMany(CommunityThreadReply::class, 'thread_id')->solutions();
    }

    // Computed attributes
    public function getViewsCountAttribute(): int
    {
        return $this->views()->count();
    }

    public function getReplyCountAttribute(): int
    {
        return $this->replies()->count();
    }

    public function scopePinned($query)
    {
        return $query->where('is_pinned', true);
    }

    public function scopeUnlocked($query)
    {
        return $query->where('is_locked', false);
    }

    public function scopeByType($query, string $type)
    {
        return $query->where('type', $type);
    }

    protected function casts(): array
    {
        return [
            'tags' => 'array',
            'images' => 'array',
            'is_pinned' => 'boolean',
            'is_locked' => 'boolean',
            'is_featured' => 'boolean',
            'last_reply_at' => 'datetime',
        ];
    }
}
```

### CommunityThreadReply
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class CommunityThreadReply extends Model
{
    /** @use HasFactory<\Database\Factories\CommunityThreadReplyFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'thread_id',
        'user_id',
        'content',
        'images',
        'is_solution',
        'is_pinned',
        'is_edited',
        'edited_at',
        'reply_to_id',
    ];

    public function thread(): BelongsTo
    {
        return $this->belongsTo(CommunityThread::class, 'thread_id');
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function author(): BelongsTo
    {
        return $this->belongsTo(User::class, 'user_id');
    }

    public function replyTo(): BelongsTo
    {
        return $this->belongsTo(self::class, 'reply_to_id');
    }

    public function replies(): HasMany
    {
        return $this->hasMany(self::class, 'reply_to_id');
    }

    public function likes(): HasMany
    {
        return $this->hasMany(CommunityThreadReplyLike::class, 'reply_id');
    }

    // Computed attributes
    public function getLikesCountAttribute(): int
    {
        return $this->likes()->count();
    }

    // Scopes
    public function scopePinned($query)
    {
        return $query->where('is_pinned', true);
    }

    public function scopeSolutions($query)
    {
        return $query->where('is_solution', true);
    }

    public function scopeTopLevel($query)
    {
        return $query->whereNull('reply_to_id');
    }

    public function scopeByUser($query, string $userId)
    {
        return $query->where('user_id', $userId);
    }

    public function scopeRecent($query)
    {
        return $query->orderBy('created_at', 'desc');
    }

    protected function casts(): array
    {
        return [
            'images' => 'array',
            'is_solution' => 'boolean',
            'is_pinned' => 'boolean',
            'is_edited' => 'boolean',
            'edited_at' => 'datetime',
        ];
    }
}
```

### CommunityThreadReplyLike
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class CommunityThreadReplyLike extends Model
{
    /** @use HasFactory<\Database\Factories\CommunityThreadReplyLikeFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'reply_id',
        'user_id',
    ];

    public function reply(): BelongsTo
    {
        return $this->belongsTo(CommunityThreadReply::class, 'reply_id');
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class, 'user_id');
    }
}
```

### CommunityThreadView
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class CommunityThreadView extends Model
{
    /** @use HasFactory<\Database\Factories\CommunityThreadViewFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'thread_id',
        'user_id',
        'session_id',
        'viewed_at',
    ];

    protected $casts = [
        'viewed_at' => 'datetime',
    ];

    public function thread(): BelongsTo
    {
        return $this->belongsTo(CommunityThread::class, 'thread_id');
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class, 'user_id');
    }
}
```

### Conversation
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;

final class Conversation extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'type',
        'title',
        'metadata',
        'last_message_at',
    ];

    public function participants(): BelongsToMany
    {
        return $this->belongsToMany(User::class, 'conversation_participants')
            ->using(ConversationParticipant::class)
            ->withPivot(['id', 'joined_at', 'last_read_at', 'is_admin'])
            ->withTimestamps();
    }

    public function messages(): HasMany
    {
        return $this->hasMany(Message::class);
    }

    public function latestMessage(): HasOne
    {
        return $this->hasOne(Message::class)->latestOfMany('created_at');
    }

    public function conversationParticipants(): HasMany
    {
        return $this->hasMany(ConversationParticipant::class);
    }

    public function getUnreadCountForUser(string $userId): int
    {
        $participant = $this->conversationParticipants()
            ->where('user_id', $userId)
            ->first();

        if (! $participant || ! $participant->last_read_at) {
            return $this->messages()->count();
        }

        return $this->messages()
            ->where('created_at', '>', $participant->last_read_at)
            ->where('sender_id', '!=', $userId)
            ->count();
    }

    public function markAsReadForUser(string $userId): void
    {
        $this->conversationParticipants()
            ->where('user_id', $userId)
            ->update(['last_read_at' => now()]);
    }

    public function isPrivate(): bool
    {
        return $this->type === 'private';
    }

    public function isGroup(): bool
    {
        return $this->type === 'group';
    }

    protected function casts(): array
    {
        return [
            'metadata' => 'array',
            'last_message_at' => 'datetime',
        ];
    }
}
```

### ConversationParticipant
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\Pivot;

final class ConversationParticipant extends Pivot
{
    use HasFactory, HasUuid;

    protected $table = 'conversation_participants';

    protected $fillable = [
        'conversation_id',
        'user_id',
        'joined_at',
        'last_read_at',
        'is_admin',
    ];

    public function conversation(): BelongsTo
    {
        return $this->belongsTo(Conversation::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    protected function casts(): array
    {
        return [
            'joined_at' => 'datetime',
            'last_read_at' => 'datetime',
            'is_admin' => 'boolean',
        ];
    }
}
```

### Coupon
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Support\Str;

final class Coupon extends Model
{
    use HasFactory, HasUuid, \App\Traits\RelatableToOrganizations;

    protected $fillable = [
        'user_id',
        'business_id',
        'title',
        'description',
        'discount_type',
        'discount_value',
        'terms',
        'code',
        'image',
        'business_name',
        'business_location',
        'start_date',
        'end_date',
        'usage_limit',
        'used_count',
        'status',
        'views_count',
        'clicks_count',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function business(): BelongsTo
    {
        return $this->belongsTo(Business::class);
    }

    public function regions(): BelongsToMany
    {
        return $this->belongsToMany(Region::class, 'coupon_region')
            ->withTimestamps();
    }

    public function usages(): HasMany
    {
        return $this->hasMany(CouponUsage::class, 'coupon_id');
    }

    // Scopes
    public function scopeActive($query)
    {
        return $query->where('status', 'active')
            ->where('start_date', '<=', now()->toDateString())
            ->where('end_date', '>=', now()->toDateString());
    }

    public function scopeExpired($query)
    {
        return $query->where('end_date', '<', now()->toDateString())
            ->orWhere('status', 'expired');
    }

    public function scopeForRegion($query, int $regionId)
    {
        return $query->whereHas('regions', function ($q) use ($regionId) {
            $q->where('region_id', $regionId);
        });
    }

    public function scopeByBusiness($query, int $businessId)
    {
        return $query->where('business_id', $businessId);
    }

    public function isActive(): bool
    {
        return $this->status === 'active'
            && $this->start_date <= now()->toDateString()
            && $this->end_date >= now()->toDateString()
            && ($this->usage_limit === null || $this->used_count < $this->usage_limit);
    }

    public function isExpired(): bool
    {
        return $this->end_date < now()->toDateString() || $this->status === 'expired';
    }

    public function canBeUsed(): bool
    {
        return $this->isActive() && ($this->usage_limit === null || $this->used_count < $this->usage_limit);
    }

    public function incrementViewsCount(): void
    {
        $this->increment('views_count');
    }

    public function incrementClicksCount(): void
    {
        $this->increment('clicks_count');
    }

    public function recordUsage(?int $userId = null, ?string $ipAddress = null): void
    {
        $this->usages()->create([
            'user_id' => $userId,
            'ip_address' => $ipAddress ?? request()->ip(),
        ]);

        $this->increment('used_count');
    }

    protected static function booted(): void
    {
        self::creating(function (Coupon $coupon): void {
            if (empty($coupon->code)) {
                $coupon->code = static::generateUniqueCode();
            }
        });
    }

    protected static function generateUniqueCode(): string
    {
        do {
            $code = strtoupper(Str::random(8));
        } while (self::where('code', $code)->exists());

        return $code;
    }

    protected function casts(): array
    {
        return [
            'discount_value' => 'decimal:2',
            'start_date' => 'date',
            'end_date' => 'date',
            'usage_limit' => 'integer',
            'used_count' => 'integer',
            'views_count' => 'integer',
            'clicks_count' => 'integer',
        ];
    }
}

```

### CouponUsage
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class CouponUsage extends Model
{
    use HasFactory;

    protected $fillable = [
        'coupon_id',
        'user_id',
        'ip_address',
    ];

    public function coupon(): BelongsTo
    {
        return $this->belongsTo(Coupon::class, 'coupon_id');
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }
}

```

### CreatorProfile
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\MorphMany;
use Illuminate\Support\Str;

final class CreatorProfile extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'user_id',
        'display_name',
        'slug',
        'bio',
        'avatar',
        'cover_image',
        'social_links',
        'status',
        'followers_count',
        'podcasts_count',
        'episodes_count',
        'total_listens',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function podcasts(): HasMany
    {
        return $this->hasMany(Podcast::class, 'creator_profile_id');
    }

    public function followers(): MorphMany
    {
        return $this->morphMany(Follow::class, 'followable');
    }

    // Scopes
    public function scopeApproved($query)
    {
        return $query->where('status', 'approved');
    }

    public function incrementFollowersCount(): void
    {
        $this->increment('followers_count');
    }

    public function incrementPodcastsCount(): void
    {
        $this->increment('podcasts_count');
    }

    public function incrementEpisodesCount(): void
    {
        $this->increment('episodes_count');
    }

    protected static function booted(): void
    {
        self::creating(function (CreatorProfile $profile): void {
            if (empty($profile->slug)) {
                $profile->slug = static::generateUniqueSlug($profile->display_name);
            }
        });
    }

    protected static function generateUniqueSlug(string $name): string
    {
        $slug = Str::slug($name);
        $originalSlug = $slug;
        $count = 1;

        while (self::where('slug', $slug)->exists()) {
            $slug = $originalSlug . '-' . $count;
            $count++;
        }

        return $slug;
    }

    protected function casts(): array
    {
        return [
            'social_links' => 'array',
            'followers_count' => 'integer',
            'podcasts_count' => 'integer',
            'episodes_count' => 'integer',
            'total_listens' => 'integer',
        ];
    }
}

```

### CrossDomainAuthToken
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class CrossDomainAuthToken extends Model
{
    use HasFactory;

    protected $fillable = [
        'user_id',
        'token',
        'source_domain',
        'target_domains',
        'expires_at',
        'used',
    ];

    protected $casts = [
        'target_domains' => 'array',
        'expires_at' => 'datetime',
        'used' => 'boolean',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Check if token is valid (not expired and not used)
     */
    public function isValid(): bool
    {
        return !$this->used && $this->expires_at->isFuture();
    }

    /**
     * Mark token as used
     */
    public function markAsUsed(): void
    {
        $this->update(['used' => true]);
    }
}
```

### Customer
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;

final class Customer extends Model
{
    /** @use HasFactory<\Database\Factories\CustomerFactory> */
    use HasFactory, HasUuid, SoftDeletes;

    protected $fillable = [
        'tenant_id',
        'smb_business_id',
        'first_name',
        'last_name',
        'email',
        'phone',
        'lifecycle_stage',
        'lead_score',
        'lead_source',
        'email_opted_in',
        'sms_opted_in',
        'lifetime_value',
        'tags',
        'custom_fields',
    ];

    protected function casts(): array
    {
        return [
            'email_opted_in' => 'boolean',
            'sms_opted_in' => 'boolean',
            'lifetime_value' => 'decimal:2',
            'tags' => 'array',
            'custom_fields' => 'array',
        ];
    }

    public function tenant(): BelongsTo
    {
        return $this->belongsTo(Tenant::class);
    }

    public function smbBusiness(): BelongsTo
    {
        return $this->belongsTo(SmbBusiness::class);
    }

    public function deals(): HasMany
    {
        return $this->hasMany(Deal::class);
    }

    public function interactions(): HasMany
    {
        return $this->hasMany(Interaction::class);
    }

    public function tasks(): HasMany
    {
        return $this->hasMany(Task::class);
    }

    public function campaignRecipients(): HasMany
    {
        return $this->hasMany(CampaignRecipient::class);
    }

    public function getFullNameAttribute(): string
    {
        return "{$this->first_name} {$this->last_name}";
    }
}
```

### DayNewsPost
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Traits\HasReviewsAndRatings;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;
use Illuminate\Database\Eloquent\Relations\MorphMany;
use Illuminate\Support\Str;

final class DayNewsPost extends Model
{
    /** @use HasFactory<\Database\Factories\DayNewsPostFactory> */
    use HasFactory, HasReviewsAndRatings, \App\Traits\RelatableToOrganizations;

    protected $fillable = [
        'workspace_id',
        'author_id',
        'writer_agent_id',
        'rss_feed_id',
        'rss_feed_item_id',
        'source_type',
        'type',
        'category',
        'title',
        'slug',
        'content',
        'excerpt',
        'featured_image',
        'featured_image_path',
        'featured_image_disk',
        'metadata',
        'status',
        'published_at',
        'expires_at',
        'view_count',
    ];

    public function workspace(): BelongsTo
    {
        return $this->belongsTo(Workspace::class);
    }

    public function author(): BelongsTo
    {
        return $this->belongsTo(User::class, 'author_id');
    }

    public function writerAgent(): BelongsTo
    {
        return $this->belongsTo(WriterAgent::class);
    }

    /**
     * Get the display author name (author or writer agent).
     */
    public function getDisplayAuthorAttribute(): ?string
    {
        if ($this->author) {
            return $this->author->name;
        }

        if ($this->writerAgent) {
            return $this->writerAgent->name;
        }

        return null;
    }

    /**
     * Get the display author avatar URL.
     */
    public function getDisplayAuthorAvatarAttribute(): ?string
    {
        if ($this->author) {
            return $this->author->profile_photo_url ?? null;
        }

        if ($this->writerAgent) {
            return $this->writerAgent->avatar_url;
        }

        return null;
    }

    public function regions(): BelongsToMany
    {
        return $this->belongsToMany(Region::class, 'day_news_post_region')
            ->withTimestamps();
    }

    public function payment(): HasOne
    {
        return $this->hasOne(DayNewsPostPayment::class, 'post_id');
    }

    public function advertisements(): MorphMany
    {
        return $this->morphMany(Advertisement::class, 'advertable');
    }

    public function rssFeed(): BelongsTo
    {
        return $this->belongsTo(RssFeed::class);
    }

    public function rssFeedItem(): BelongsTo
    {
        return $this->belongsTo(RssFeedItem::class);
    }

    public function comments(): HasMany
    {
        return $this->hasMany(ArticleComment::class, 'article_id');
    }

    public function activeComments(): HasMany
    {
        return $this->comments()->where('is_active', true);
    }

    public function tags(): BelongsToMany
    {
        return $this->belongsToMany(Tag::class, 'day_news_post_tag')
            ->withTimestamps();
    }

    public function activities(): MorphMany
    {
        return $this->morphMany(SocialActivity::class, 'subject');
    }

    public function scopePublished($query)
    {
        return $query->where('status', 'published')
            ->whereNotNull('published_at')
            ->where(function ($q) {
                $q->whereNull('expires_at')
                    ->orWhere('expires_at', '>', now());
            });
    }

    public function scopeActive($query)
    {
        return $query->published();
    }

    public function scopeForRegion($query, int $regionId)
    {
        return $query->whereHas('regions', function ($q) use ($regionId) {
            $q->where('region_id', $regionId);
        });
    }

    public function scopeByType($query, string $type)
    {
        return $query->where('type', $type);
    }

    public function scopeDraft($query)
    {
        return $query->where('status', 'draft');
    }

    public function scopeExpired($query)
    {
        return $query->where('status', 'expired')
            ->orWhere(function ($q) {
                $q->whereNotNull('expires_at')
                    ->where('expires_at', '<=', now());
            });
    }

    public function scopeForWorkspace($query, int $workspaceId)
    {
        return $query->where('workspace_id', $workspaceId);
    }

    public function incrementViewCount(): void
    {
        $this->increment('view_count');
    }

    public function isExpired(): bool
    {
        return $this->expires_at !== null && $this->expires_at->isPast();
    }

    public function isFreeCategory(): bool
    {
        return in_array($this->category, config('services.day_news.free_categories', []));
    }

    public function getFeaturedImageAttribute(): ?string
    {
        // Priority: local storage > original URL > null
        if ($this->featured_image_path && $this->featured_image_disk) {
            return \Illuminate\Support\Facades\Storage::disk($this->featured_image_disk)->url($this->featured_image_path);
        }

        return $this->attributes['featured_image'] ?? null;
    }

    protected static function booted(): void
    {
        self::creating(function (DayNewsPost $post): void {
            if (empty($post->slug)) {
                $post->slug = static::generateUniqueSlug($post->title);
            }
        });
    }

    protected static function generateUniqueSlug(string $title): string
    {
        $slug = Str::slug($title);
        $originalSlug = $slug;
        $count = 1;

        while (self::where('slug', $slug)->exists()) {
            $slug = $originalSlug.'-'.$count;
            $count++;
        }

        return $slug;
    }

    protected function casts(): array
    {
        return [
            'published_at' => 'datetime',
            'expires_at' => 'datetime',
            'metadata' => 'array',
            'view_count' => 'integer',
        ];
    }
}
```

### DayNewsPostPayment
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class DayNewsPostPayment extends Model
{
    /** @use HasFactory<\Database\Factories\DayNewsPostPaymentFactory> */
    use HasFactory;

    protected $fillable = [
        'post_id',
        'workspace_id',
        'stripe_payment_intent_id',
        'stripe_checkout_session_id',
        'amount',
        'currency',
        'status',
        'payment_type',
        'ad_days',
    ];

    public function post(): BelongsTo
    {
        return $this->belongsTo(DayNewsPost::class, 'post_id');
    }

    public function workspace(): BelongsTo
    {
        return $this->belongsTo(Workspace::class);
    }

    public function scopePaid($query)
    {
        return $query->where('status', 'paid');
    }

    public function scopePending($query)
    {
        return $query->where('status', 'pending');
    }

    public function scopeFailed($query)
    {
        return $query->where('status', 'failed');
    }

    public function isPaid(): bool
    {
        return $this->status === 'paid';
    }

    public function markAsPaid(): void
    {
        $this->update(['status' => 'paid']);
    }

    public function markAsFailed(): void
    {
        $this->update(['status' => 'failed']);
    }

    public function getAmountInDollars(): float
    {
        return $this->amount / 100;
    }

    protected function casts(): array
    {
        return [
            'amount' => 'integer',
            'ad_days' => 'integer',
        ];
    }
}
```

### Deal
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\SoftDeletes;

final class Deal extends Model
{
    /** @use HasFactory<\Database\Factories\DealFactory> */
    use HasFactory, HasUuid, SoftDeletes;

    protected $fillable = [
        'tenant_id',
        'customer_id',
        'name',
        'amount',
        'currency',
        'stage',
        'probability',
        'expected_close_date',
        'actual_close_date',
        'description',
        'tags',
        'custom_fields',
    ];

    protected function casts(): array
    {
        return [
            'amount' => 'decimal:2',
            'expected_close_date' => 'date',
            'actual_close_date' => 'date',
            'tags' => 'array',
            'custom_fields' => 'array',
        ];
    }

    public function tenant(): BelongsTo
    {
        return $this->belongsTo(Tenant::class);
    }

    public function customer(): BelongsTo
    {
        return $this->belongsTo(Customer::class);
    }

    public function isWon(): bool
    {
        return $this->stage === 'closed_won';
    }

    public function isLost(): bool
    {
        return $this->stage === 'closed_lost';
    }

    public function isOpen(): bool
    {
        return !$this->isWon() && !$this->isLost();
    }
}
```

### EmailCampaign
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Support\Str;

final class EmailCampaign extends Model
{
    use HasFactory;

    protected $fillable = [
        'uuid',
        'community_id',
        'template_id',
        'name',
        'type',
        'status',
        'subject',
        'preview_text',
        'html_content',
        'text_content',
        'segment',
        'scheduled_at',
        'started_at',
        'completed_at',
        'total_recipients',
        'sent_count',
        'delivered_count',
        'opened_count',
        'clicked_count',
        'bounced_count',
        'complained_count',
        'unsubscribed_count',
    ];

    protected $casts = [
        'segment' => 'array',
        'scheduled_at' => 'datetime',
        'started_at' => 'datetime',
        'completed_at' => 'datetime',
    ];

    protected static function boot(): void
    {
        parent::boot();

        static::creating(function ($model): void {
            $model->uuid = $model->uuid ?? Str::uuid()->toString();
        });
    }

    public function community(): BelongsTo
    {
        return $this->belongsTo(Community::class);
    }

    public function template(): BelongsTo
    {
        return $this->belongsTo(EmailTemplate::class);
    }

    public function sends(): HasMany
    {
        return $this->hasMany(EmailSend::class, 'campaign_id');
    }

    public function getOpenRateAttribute(): float
    {
        if ($this->delivered_count === 0) {
            return 0.0;
        }

        return round(($this->opened_count / $this->delivered_count) * 100, 2);
    }

    public function getClickRateAttribute(): float
    {
        if ($this->opened_count === 0) {
            return 0.0;
        }

        return round(($this->clicked_count / $this->opened_count) * 100, 2);
    }
}
```

### EmailSend
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class EmailSend extends Model
{
    use HasFactory;

    protected $fillable = [
        'campaign_id',
        'subscriber_id',
        'message_id',
        'status',
        'sent_at',
        'delivered_at',
        'opened_at',
        'open_count',
        'clicked_at',
        'click_count',
        'bounce_type',
        'error_message',
    ];

    protected $casts = [
        'sent_at' => 'datetime',
        'delivered_at' => 'datetime',
        'opened_at' => 'datetime',
        'clicked_at' => 'datetime',
    ];

    public function campaign(): BelongsTo
    {
        return $this->belongsTo(EmailCampaign::class, 'campaign_id');
    }

    public function subscriber(): BelongsTo
    {
        return $this->belongsTo(EmailSubscriber::class, 'subscriber_id');
    }
}
```

### EmailSubscriber
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Support\Str;

final class EmailSubscriber extends Model
{
    use HasFactory, SoftDeletes;

    protected $fillable = [
        'uuid',
        'email',
        'first_name',
        'last_name',
        'community_id',
        'business_id',
        'type',
        'status',
        'confirmed_at',
        'unsubscribed_at',
        'unsubscribe_reason',
        'preferences',
        'source',
    ];

    protected $casts = [
        'confirmed_at' => 'datetime',
        'unsubscribed_at' => 'datetime',
        'preferences' => 'array',
    ];

    protected static function boot(): void
    {
        parent::boot();

        static::creating(function ($model): void {
            $model->uuid = $model->uuid ?? Str::uuid()->toString();
        });
    }

    public function community(): BelongsTo
    {
        return $this->belongsTo(Community::class);
    }

    public function business(): BelongsTo
    {
        return $this->belongsTo(Business::class);
    }

    public function sends(): HasMany
    {
        return $this->hasMany(EmailSend::class, 'subscriber_id');
    }

    public function newsletterSubscription(): HasOne
    {
        return $this->hasOne(NewsletterSubscription::class, 'subscriber_id');
    }

    public function emergencySubscription(): HasOne
    {
        return $this->hasOne(EmergencySubscription::class, 'subscriber_id');
    }

    public function getFullNameAttribute(): string
    {
        return trim("{$this->first_name} {$this->last_name}") ?: $this->email;
    }

    public function wantsDigest(): bool
    {
        return ($this->preferences['daily_digest'] ?? true) && $this->status === 'active';
    }

    public function wantsBreakingNews(): bool
    {
        return ($this->preferences['breaking_news'] ?? true) && $this->status === 'active';
    }

    public function wantsNewsletter(): bool
    {
        return ($this->preferences['weekly_newsletter'] ?? false) && $this->status === 'active';
    }
}
```

### EmailTemplate
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Str;

final class EmailTemplate extends Model
{
    use HasFactory;

    protected $fillable = [
        'uuid',
        'name',
        'slug',
        'type',
        'subject_template',
        'preview_text',
        'html_template',
        'text_template',
        'variables',
        'is_active',
        'version',
    ];

    protected $casts = [
        'variables' => 'array',
        'is_active' => 'boolean',
    ];

    protected static function boot(): void
    {
        parent::boot();

        static::creating(function ($model): void {
            $model->uuid = $model->uuid ?? Str::uuid()->toString();
        });
    }
}
```

### EmergencyAlert
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Support\Str;

final class EmergencyAlert extends Model
{
    use HasFactory, SoftDeletes;

    protected $fillable = [
        'uuid',
        'community_id',
        'created_by',
        'municipal_partner_id',
        'priority',
        'category',
        'title',
        'message',
        'instructions',
        'source',
        'source_url',
        'status',
        'published_at',
        'expires_at',
        'delivery_channels',
        'email_sent',
        'sms_sent',
    ];

    protected $casts = [
        'published_at' => 'datetime',
        'expires_at' => 'datetime',
        'delivery_channels' => 'array',
    ];

    protected static function boot(): void
    {
        parent::boot();

        static::creating(function ($model): void {
            $model->uuid = $model->uuid ?? Str::uuid()->toString();
        });
    }

    public function community(): BelongsTo
    {
        return $this->belongsTo(Community::class);
    }

    public function creator(): BelongsTo
    {
        return $this->belongsTo(User::class, 'created_by');
    }

    public function municipalPartner(): BelongsTo
    {
        return $this->belongsTo(MunicipalPartner::class);
    }

    public function deliveries(): HasMany
    {
        return $this->hasMany(EmergencyDelivery::class, 'alert_id');
    }

    public function auditLogs(): HasMany
    {
        return $this->hasMany(EmergencyAuditLog::class, 'alert_id');
    }

    public function isActive(): bool
    {
        return $this->status === 'active'
            && ($this->expires_at === null || $this->expires_at > now());
    }

    public function getPriorityColorAttribute(): string
    {
        return match($this->priority) {
            'critical' => 'red',
            'urgent' => 'orange',
            'advisory' => 'yellow',
            'info' => 'blue',
            default => 'gray',
        };
    }
}
```

### EmergencyAuditLog
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class EmergencyAuditLog extends Model
{
    use HasFactory;
    
    protected $table = 'emergency_audit_log';

    protected $fillable = [
        'alert_id',
        'user_id',
        'municipal_partner_id',
        'action',
        'changes',
        'ip_address',
        'user_agent',
    ];

    protected $casts = [
        'changes' => 'array',
    ];

    public function alert(): BelongsTo
    {
        return $this->belongsTo(EmergencyAlert::class, 'alert_id');
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class, 'user_id');
    }

    public function municipalPartner(): BelongsTo
    {
        return $this->belongsTo(MunicipalPartner::class, 'municipal_partner_id');
    }
}
```

### EmergencyDelivery
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class EmergencyDelivery extends Model
{
    use HasFactory;

    protected $fillable = [
        'alert_id',
        'subscription_id',
        'channel',
        'status',
        'external_id',
        'sent_at',
        'delivered_at',
        'error_message',
    ];

    protected $casts = [
        'sent_at' => 'datetime',
        'delivered_at' => 'datetime',
    ];

    public function alert(): BelongsTo
    {
        return $this->belongsTo(EmergencyAlert::class, 'alert_id');
    }

    public function subscription(): BelongsTo
    {
        return $this->belongsTo(EmergencySubscription::class, 'subscription_id');
    }
}
```

### EmergencySubscription
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class EmergencySubscription extends Model
{
    use HasFactory;
    protected $fillable = [
        'subscriber_id',
        'email_enabled',
        'sms_enabled',
        'phone_number',
        'phone_verified',
        'phone_verification_code',
        'phone_verified_at',
        'priority_levels',
        'categories',
        'stripe_subscription_id',
        'sms_tier',
    ];

    protected $casts = [
        'email_enabled' => 'boolean',
        'sms_enabled' => 'boolean',
        'phone_verified' => 'boolean',
        'phone_verified_at' => 'datetime',
        'priority_levels' => 'array',
        'categories' => 'array',
    ];

    public function subscriber(): BelongsTo
    {
        return $this->belongsTo(EmailSubscriber::class, 'subscriber_id');
    }

    public function deliveries(): HasMany
    {
        return $this->hasMany(EmergencyDelivery::class, 'subscription_id');
    }

    public function shouldReceiveAlert(EmergencyAlert $alert): bool
    {
        // Check priority level
        $priorities = $this->priority_levels ?? ['critical', 'urgent', 'advisory', 'info'];
        if (!in_array($alert->priority, $priorities)) {
            return false;
        }

        // Check category
        $categories = $this->categories ?? [];
        if (!empty($categories) && !in_array($alert->category, $categories)) {
            return false;
        }

        return true;
    }

    public function canReceiveSms(): bool
    {
        return $this->sms_enabled
            && $this->phone_verified
            && $this->sms_tier !== 'none';
    }
}
```

### Event
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\MorphMany;

final class Event extends Model
{
    /** @use HasFactory<\Database\Factories\EventFactory> */
    use HasFactory, HasUuid, \App\Traits\RelatableToOrganizations;

    protected $appends = [
        'date',
        'venue_info',
        'price',
        'location',
        'venue_model',
    ];

    protected $fillable = [
        'title',
        'image',
        'image_path',
        'image_disk',
        'event_date',
        'time',
        'description',
        'badges',
        'subcategories',
        'category',
        'is_free',
        'price_min',
        'price_max',
        'community_rating',
        'member_attendance',
        'member_recommendations',
        'discussion_thread_id',
        'curator_notes',
        'latitude',
        'longitude',
        'google_place_id',
        'postal_code',
        'venue_id',
        'performer_id',
        'workspace_id',
        'created_by',
        'source_news_article_id',
        'source_type',
        'status',
    ];

    public function venue(): BelongsTo
    {
        return $this->belongsTo(Venue::class);
    }

    public function performer(): BelongsTo
    {
        return $this->belongsTo(Performer::class);
    }

    public function workspace(): BelongsTo
    {
        return $this->belongsTo(Workspace::class);
    }

    public function createdBy(): BelongsTo
    {
        return $this->belongsTo(User::class, 'created_by');
    }

    public function sourceNewsArticle(): BelongsTo
    {
        return $this->belongsTo(NewsArticle::class, 'source_news_article_id');
    }

    public function regions(): BelongsToMany
    {
        return $this->belongsToMany(Region::class, 'event_region')
            ->withTimestamps();
    }

    public function bookings(): HasMany
    {
        return $this->hasMany(Booking::class);
    }

    public function ticketPlans(): HasMany
    {
        return $this->hasMany(TicketPlan::class);
    }

    public function ticketOrders(): HasMany
    {
        return $this->hasMany(TicketOrder::class);
    }

    public function hub(): BelongsTo
    {
        return $this->belongsTo(Hub::class);
    }

    public function checkIns(): HasMany
    {
        return $this->hasMany(CheckIn::class);
    }

    public function plannedEvents(): HasMany
    {
        return $this->hasMany(PlannedEvent::class);
    }

    public function follows(): MorphMany
    {
        return $this->morphMany(Follow::class, 'followable');
    }

    // Computed attributes for frontend compatibility
    public function getDateAttribute(): string
    {
        return $this->event_date->toISOString();
    }

    public function getVenueInfoAttribute(): array
    {
        if ($this->venue) {
            return [
                'name' => $this->venue->name,
                'city' => $this->venue->neighborhood ?? 'Unknown',
            ];
        }

        return [
            'name' => 'TBD',
            'city' => 'TBD',
        ];
    }

    public function getPriceAttribute(): array
    {
        return [
            'isFree' => $this->is_free,
            'min' => $this->price_min,
            'max' => $this->price_max,
        ];
    }

    public function getLocationAttribute(): array
    {
        return [
            'lat' => $this->latitude,
            'lng' => $this->longitude,
        ];
    }

    public function getVenueModelAttribute(): ?Venue
    {
        return $this->venue;
    }

    public function getImageAttribute(): ?string
    {
        // Priority: local storage > original URL > null
        if ($this->image_path && $this->image_disk) {
            return \Illuminate\Support\Facades\Storage::disk($this->image_disk)->url($this->image_path);
        }

        return $this->attributes['image'] ?? null;
    }

    // Scopes
    public function scopePublished($query)
    {
        return $query->where('status', 'published');
    }

    public function scopeUpcoming($query)
    {
        return $query->where('event_date', '>=', now());
    }

    public function scopeByCategory($query, string $category)
    {
        return $query->where('category', $category);
    }

    public function scopeWithBadge($query, string $badge)
    {
        return $query->whereJsonContains('badges', $badge);
    }

    public function scopeFree($query)
    {
        return $query->where('is_free', true);
    }

    public function scopeAiExtracted($query)
    {
        return $query->where('source_type', 'ai_extracted');
    }

    public function scopeManual($query)
    {
        return $query->where('source_type', 'manual');
    }

    public function scopeWithinPriceRange($query, float $min, float $max)
    {
        return $query->where(function ($q) use ($min, $max) {
            $q->where('is_free', true)
                ->orWhere(function ($q2) use ($min, $max) {
                    $q2->where('price_min', '>=', $min)
                        ->where('price_max', '<=', $max);
                });
        });
    }

    public function scopeWithinRadius($query, float $lat, float $lng, float $radius)
    {
        // Haversine formula for distance calculation
        return $query->selectRaw('
            *,
            (6371 * acos(cos(radians(?))
            * cos(radians(latitude))
            * cos(radians(longitude) - radians(?))
            + sin(radians(?))
            * sin(radians(latitude)))) AS distance
        ', [$lat, $lng, $lat])
            ->whereRaw('
            (6371 * acos(cos(radians(?))
            * cos(radians(latitude))
            * cos(radians(longitude) - radians(?))
            + sin(radians(?))
            * sin(radians(latitude)))) < ?
        ', [$lat, $lng, $lat, $radius]);
    }

    protected function casts(): array
    {
        return [
            'event_date' => 'datetime',
            'badges' => 'array',
            'subcategories' => 'array',
            'is_free' => 'boolean',
            'price_min' => 'decimal:2',
            'price_max' => 'decimal:2',
            'community_rating' => 'decimal:2',
            'latitude' => 'decimal:8',
            'longitude' => 'decimal:8',
        ];
    }
}
```

### EventExtractionDraft
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class EventExtractionDraft extends Model
{
    use HasFactory, HasUuids;

    protected $fillable = [
        'news_article_id',
        'region_id',
        'status',
        'detection_confidence',
        'extraction_confidence',
        'quality_score',
        'extracted_data',
        'matched_venue_id',
        'matched_performer_id',
        'published_event_id',
        'ai_metadata',
        'rejection_reason',
    ];

    public function newsArticle(): BelongsTo
    {
        return $this->belongsTo(NewsArticle::class);
    }

    public function region(): BelongsTo
    {
        return $this->belongsTo(Region::class);
    }

    public function matchedVenue(): BelongsTo
    {
        return $this->belongsTo(Venue::class, 'matched_venue_id');
    }

    public function matchedPerformer(): BelongsTo
    {
        return $this->belongsTo(Performer::class, 'matched_performer_id');
    }

    public function publishedEvent(): BelongsTo
    {
        return $this->belongsTo(Event::class, 'published_event_id');
    }

    public function scopeByStatus($query, string $status)
    {
        return $query->where('status', $status);
    }

    public function scopePending($query)
    {
        return $query->where('status', 'pending');
    }

    public function scopeDetected($query)
    {
        return $query->where('status', 'detected');
    }

    public function scopeExtracted($query)
    {
        return $query->where('status', 'extracted');
    }

    public function scopeValidated($query)
    {
        return $query->where('status', 'validated');
    }

    public function scopePublished($query)
    {
        return $query->where('status', 'published');
    }

    public function scopeRejected($query)
    {
        return $query->where('status', 'rejected');
    }

    public function scopeForRegion($query, string $regionId)
    {
        return $query->where('region_id', $regionId);
    }

    public function scopeAboveQualityThreshold($query, float $threshold)
    {
        return $query->where('quality_score', '>=', $threshold);
    }

    public function shouldAutoPublish(): bool
    {
        $threshold = config('news-workflow.event_extraction.auto_publish_threshold', 85);

        return $this->quality_score >= $threshold;
    }

    protected function casts(): array
    {
        return [
            'detection_confidence' => 'decimal:2',
            'extraction_confidence' => 'decimal:2',
            'quality_score' => 'decimal:2',
            'extracted_data' => 'array',
            'ai_metadata' => 'array',
        ];
    }
}
```

### Follow
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\MorphTo;

final class Follow extends Model
{
    use HasFactory;
    /**
     * The attributes that are mass assignable.
     *
     * @var list<string>
     */
    protected $fillable = [
        'user_id',
        'followable_type',
        'followable_id',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function followable(): MorphTo
    {
        return $this->morphTo();
    }

    protected function casts(): array
    {
        return [
            'created_at' => 'datetime',
            'updated_at' => 'datetime',
        ];
    }
}
```

### Hub
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\MorphMany;
use Illuminate\Support\Str;

final class Hub extends Model
{
    /** @use HasFactory<\Database\Factories\HubFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'workspace_id',
        'created_by',
        'name',
        'slug',
        'description',
        'image',
        'banner_image',
        'about',
        'category',
        'subcategory',
        'location',
        'website',
        'social_links',
        'contact_email',
        'contact_phone',
        'is_active',
        'is_featured',
        'is_verified',
        'design_settings',
        'monetization_settings',
        'permissions',
        'analytics_enabled',
        'articles_enabled',
        'community_enabled',
        'events_enabled',
        'gallery_enabled',
        'performers_enabled',
        'venues_enabled',
        'followers_count',
        'events_count',
        'articles_count',
        'members_count',
        'last_activity_at',
        'published_at',
    ];

    protected function casts(): array
    {
        return [
            'social_links' => 'array',
            'design_settings' => 'array',
            'monetization_settings' => 'array',
            'permissions' => 'array',
            'is_active' => 'boolean',
            'is_featured' => 'boolean',
            'is_verified' => 'boolean',
            'analytics_enabled' => 'boolean',
            'articles_enabled' => 'boolean',
            'community_enabled' => 'boolean',
            'events_enabled' => 'boolean',
            'gallery_enabled' => 'boolean',
            'performers_enabled' => 'boolean',
            'venues_enabled' => 'boolean',
            'followers_count' => 'integer',
            'events_count' => 'integer',
            'articles_count' => 'integer',
            'members_count' => 'integer',
            'last_activity_at' => 'datetime',
            'published_at' => 'datetime',
        ];
    }

    public function workspace(): BelongsTo
    {
        return $this->belongsTo(Workspace::class);
    }

    public function createdBy(): BelongsTo
    {
        return $this->belongsTo(User::class, 'created_by');
    }

    public function sections(): HasMany
    {
        return $this->hasMany(HubSection::class)->orderBy('sort_order');
    }

    public function members(): HasMany
    {
        return $this->hasMany(HubMember::class);
    }

    public function roles(): HasMany
    {
        return $this->hasMany(HubRole::class);
    }

    public function analytics(): HasMany
    {
        return $this->hasMany(HubAnalytics::class);
    }

    public function events(): HasMany
    {
        return $this->hasMany(Event::class, 'hub_id');
    }

    public function follows(): MorphMany
    {
        return $this->morphMany(Follow::class, 'followable');
    }

    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    public function scopeFeatured($query)
    {
        return $query->where('is_featured', true);
    }

    public function scopeVerified($query)
    {
        return $query->where('is_verified', true);
    }

    public function scopePublished($query)
    {
        return $query->whereNotNull('published_at')
            ->where('published_at', '<=', now());
    }

    public static function generateUniqueSlug(string $name): string
    {
        $slug = Str::slug($name);
        $originalSlug = $slug;
        $count = 1;

        while (self::where('slug', $slug)->exists()) {
            $slug = $originalSlug.'-'.$count;
            $count++;
        }

        return $slug;
    }

    public function getUrlAttribute(): string
    {
        return "/hubs/{$this->slug}";
    }
}

```

### HubAnalytics
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class HubAnalytics extends Model
{
    /** @use HasFactory<\Database\Factories\HubAnalyticsFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'hub_id',
        'date',
        'page_views',
        'unique_visitors',
        'events_created',
        'events_published',
        'articles_created',
        'articles_published',
        'members_joined',
        'followers_gained',
        'engagement_score',
        'revenue',
        'metadata',
    ];

    protected function casts(): array
    {
        return [
            'date' => 'date',
            'page_views' => 'integer',
            'unique_visitors' => 'integer',
            'events_created' => 'integer',
            'events_published' => 'integer',
            'articles_created' => 'integer',
            'articles_published' => 'integer',
            'members_joined' => 'integer',
            'followers_gained' => 'integer',
            'engagement_score' => 'decimal:2',
            'revenue' => 'decimal:2',
            'metadata' => 'array',
        ];
    }

    public function hub(): BelongsTo
    {
        return $this->belongsTo(Hub::class);
    }

    public function scopeForDateRange($query, string $startDate, string $endDate)
    {
        return $query->whereBetween('date', [$startDate, $endDate]);
    }

    public function scopeRecent($query, int $days = 30)
    {
        return $query->where('date', '>=', now()->subDays($days));
    }
}

```

### HubMember
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class HubMember extends Model
{
    /** @use HasFactory<\Database\Factories\HubMemberFactory> */
    use HasFactory, HasUuid;

    public const ROLE_OWNER = 'owner';
    public const ROLE_ADMIN = 'admin';
    public const ROLE_EDITOR = 'editor';
    public const ROLE_MEMBER = 'member';

    public const ROLES = [
        self::ROLE_OWNER,
        self::ROLE_ADMIN,
        self::ROLE_EDITOR,
        self::ROLE_MEMBER,
    ];

    protected $fillable = [
        'hub_id',
        'user_id',
        'role',
        'permissions',
        'joined_at',
        'is_active',
    ];

    protected function casts(): array
    {
        return [
            'permissions' => 'array',
            'joined_at' => 'datetime',
            'is_active' => 'boolean',
        ];
    }

    public function hub(): BelongsTo
    {
        return $this->belongsTo(Hub::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    public function scopeRole($query, string $role)
    {
        return $query->where('role', $role);
    }

    public function canEdit(): bool
    {
        return in_array($this->role, [self::ROLE_OWNER, self::ROLE_ADMIN, self::ROLE_EDITOR]);
    }

    public function canManage(): bool
    {
        return in_array($this->role, [self::ROLE_OWNER, self::ROLE_ADMIN]);
    }
}

```

### HubRole
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class HubRole extends Model
{
    /** @use HasFactory<\Database\Factories\HubRoleFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'hub_id',
        'name',
        'slug',
        'description',
        'permissions',
        'is_system',
        'sort_order',
    ];

    protected function casts(): array
    {
        return [
            'permissions' => 'array',
            'is_system' => 'boolean',
            'sort_order' => 'integer',
        ];
    }

    public function hub(): BelongsTo
    {
        return $this->belongsTo(Hub::class);
    }

    public function members(): HasMany
    {
        return $this->hasMany(HubMember::class, 'role', 'slug');
    }
}

```

### HubSection
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class HubSection extends Model
{
    /** @use HasFactory<\Database\Factories\HubSectionFactory> */
    use HasFactory, HasUuid;

    public const TYPE_ANALYTICS = 'analytics';
    public const TYPE_ARTICLES = 'articles';
    public const TYPE_COMMUNITY = 'community';
    public const TYPE_EVENTS = 'events';
    public const TYPE_GALLERY = 'gallery';
    public const TYPE_PERFORMERS = 'performers';
    public const TYPE_VENUES = 'venues';
    public const TYPE_CUSTOM = 'custom';

    public const TYPES = [
        self::TYPE_ANALYTICS,
        self::TYPE_ARTICLES,
        self::TYPE_COMMUNITY,
        self::TYPE_EVENTS,
        self::TYPE_GALLERY,
        self::TYPE_PERFORMERS,
        self::TYPE_VENUES,
        self::TYPE_CUSTOM,
    ];

    protected $fillable = [
        'hub_id',
        'type',
        'title',
        'description',
        'content',
        'settings',
        'is_visible',
        'sort_order',
    ];

    protected function casts(): array
    {
        return [
            'content' => 'array',
            'settings' => 'array',
            'is_visible' => 'boolean',
            'sort_order' => 'integer',
        ];
    }

    public function hub(): BelongsTo
    {
        return $this->belongsTo(Hub::class);
    }
}

```

### Industry
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class Industry extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'name',
        'slug',
        'description',
        'icon',
        'parent_id',
        'default_template_id',
        'available_features',
        'required_fields',
        'seo_title',
        'seo_description',
        'schema_type',
        'display_order',
        'is_active',
    ];

    protected function casts(): array
    {
        return [
            'available_features' => 'array',
            'required_fields' => 'array',
            'is_active' => 'boolean',
        ];
    }

    public function parent(): BelongsTo
    {
        return $this->belongsTo(Industry::class, 'parent_id');
    }

    public function children(): HasMany
    {
        return $this->hasMany(Industry::class, 'parent_id');
    }

    public function defaultTemplate(): BelongsTo
    {
        return $this->belongsTo(BusinessTemplate::class, 'default_template_id');
    }

    public function businesses(): HasMany
    {
        return $this->hasMany(Business::class, 'industry_id');
    }

    public function templates(): HasMany
    {
        return $this->hasMany(BusinessTemplate::class, 'industry_id');
    }

    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }
}
```

### Interaction
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class Interaction extends Model
{
    /** @use HasFactory<\Database\Factories\InteractionFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'tenant_id',
        'customer_id',
        'type',
        'subject',
        'description',
        'direction',
        'duration_minutes',
        'outcome',
        'next_action',
        'next_action_date',
        'metadata',
    ];

    protected function casts(): array
    {
        return [
            'next_action_date' => 'date',
            'metadata' => 'array',
        ];
    }

    public function tenant(): BelongsTo
    {
        return $this->belongsTo(Tenant::class);
    }

    public function customer(): BelongsTo
    {
        return $this->belongsTo(Customer::class);
    }

    public function isInbound(): bool
    {
        return $this->direction === 'inbound';
    }

    public function isOutbound(): bool
    {
        return $this->direction === 'outbound';
    }
}
```

### LegalNotice
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;

final class LegalNotice extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'user_id',
        'workspace_id',
        'type',
        'case_number',
        'title',
        'content',
        'court',
        'publish_date',
        'expiry_date',
        'status',
        'metadata',
        'views_count',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function workspace(): BelongsTo
    {
        return $this->belongsTo(Workspace::class);
    }

    public function regions(): BelongsToMany
    {
        return $this->belongsToMany(Region::class, 'legal_notice_region')
            ->withTimestamps();
    }

    // Scopes
    public function scopeActive($query)
    {
        return $query->where('status', 'active')
            ->where(function ($q) {
                $q->whereNull('expiry_date')
                    ->orWhere('expiry_date', '>=', now()->toDateString());
            });
    }

    public function scopeByType($query, string $type)
    {
        return $query->where('type', $type);
    }

    public function scopeForRegion($query, int $regionId)
    {
        return $query->whereHas('regions', function ($q) use ($regionId) {
            $q->where('region_id', $regionId);
        });
    }

    public function scopeExpiresSoon($query)
    {
        return $query->where('expiry_date', '>=', now()->toDateString())
            ->where('expiry_date', '<=', now()->addDays(7)->toDateString());
    }

    public function incrementViewsCount(): void
    {
        $this->increment('views_count');
    }

    public function isExpired(): bool
    {
        return $this->expiry_date !== null && $this->expiry_date->isPast();
    }

    protected function casts(): array
    {
        return [
            'publish_date' => 'date',
            'expiry_date' => 'date',
            'metadata' => 'array',
            'views_count' => 'integer',
        ];
    }
}

```

### Memorial
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use App\Traits\HasReviewsAndRatings;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\MorphMany;

final class Memorial extends Model
{
    use HasFactory, HasUuid, HasReviewsAndRatings;

    protected $fillable = [
        'user_id',
        'workspace_id',
        'name',
        'years',
        'date_of_passing',
        'obituary',
        'image',
        'location',
        'service_date',
        'service_location',
        'service_details',
        'is_featured',
        'status',
        'published_at',
        'views_count',
        'reactions_count',
        'comments_count',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function workspace(): BelongsTo
    {
        return $this->belongsTo(Workspace::class);
    }

    public function regions(): BelongsToMany
    {
        return $this->belongsToMany(Region::class, 'memorial_region')
            ->withTimestamps();
    }

    // Memorials can have comments, but they would need their own comment system
    // For now, we'll use the reactions_count field to track engagement
    // TODO: Create MemorialComment model if comments are needed

    // Scopes
    public function scopePublished($query)
    {
        return $query->where('status', 'published')
            ->whereNotNull('published_at');
    }

    public function scopeFeatured($query)
    {
        return $query->where('is_featured', true);
    }

    public function scopeForRegion($query, int $regionId)
    {
        return $query->whereHas('regions', function ($q) use ($regionId) {
            $q->where('region_id', $regionId);
        });
    }

    public function incrementViewsCount(): void
    {
        $this->increment('views_count');
    }

    public function incrementReactionsCount(): void
    {
        $this->increment('reactions_count');
    }

    public function incrementCommentsCount(): void
    {
        $this->increment('comments_count');
    }

    protected function casts(): array
    {
        return [
            'date_of_passing' => 'date',
            'service_date' => 'date',
            'published_at' => 'datetime',
            'is_featured' => 'boolean',
            'views_count' => 'integer',
            'reactions_count' => 'integer',
            'comments_count' => 'integer',
        ];
    }
}

```

### Message
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class Message extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'conversation_id',
        'sender_id',
        'content',
        'type',
        'metadata',
        'edited_at',
    ];

    public function conversation(): BelongsTo
    {
        return $this->belongsTo(Conversation::class);
    }

    public function sender(): BelongsTo
    {
        return $this->belongsTo(User::class, 'sender_id');
    }

    public function isText(): bool
    {
        return $this->type === 'text';
    }

    public function isImage(): bool
    {
        return $this->type === 'image';
    }

    public function isFile(): bool
    {
        return $this->type === 'file';
    }

    public function isSystem(): bool
    {
        return $this->type === 'system';
    }

    public function isEdited(): bool
    {
        return $this->edited_at !== null;
    }

    public function markAsEdited(): void
    {
        $this->update(['edited_at' => now()]);
    }

    protected function casts(): array
    {
        return [
            'metadata' => 'array',
            'edited_at' => 'datetime',
        ];
    }
}
```

### MunicipalPartner
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Support\Str;

final class MunicipalPartner extends Model
{
    use HasFactory, SoftDeletes;

    protected $fillable = [
        'uuid',
        'name',
        'type',
        'community_ids',
        'primary_contact_id',
        'api_key_hash',
        'is_verified',
        'is_active',
        'allowed_categories',
        'allowed_priorities',
        'requires_approval',
    ];

    protected $casts = [
        'community_ids' => 'array',
        'is_verified' => 'boolean',
        'is_active' => 'boolean',
        'allowed_categories' => 'array',
        'allowed_priorities' => 'array',
        'requires_approval' => 'boolean',
    ];

    protected static function boot(): void
    {
        parent::boot();

        static::creating(function ($model): void {
            $model->uuid = $model->uuid ?? Str::uuid()->toString();
        });
    }

    public function primaryContact(): BelongsTo
    {
        return $this->belongsTo(User::class, 'primary_contact_id');
    }

    public function alerts(): HasMany
    {
        return $this->hasMany(EmergencyAlert::class, 'municipal_partner_id');
    }
}
```

### NewsArticle
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class NewsArticle extends Model
{
    use HasFactory, HasUuids;

    protected $fillable = [
        'region_id',
        'business_id',
        'source_type',
        'source_name',
        'title',
        'url',
        'content_snippet',
        'full_content',
        'source_publisher',
        'published_at',
        'metadata',
        'content_hash',
        'processed',
        'relevance_score',
        'relevance_topic_tags',
        'relevance_rationale',
        'scored_at',
    ];

    public function region(): BelongsTo
    {
        return $this->belongsTo(Region::class);
    }

    public function business(): BelongsTo
    {
        return $this->belongsTo(Business::class);
    }

    public function drafts(): HasMany
    {
        return $this->hasMany(NewsArticleDraft::class);
    }

    public function eventExtractionDrafts(): HasMany
    {
        return $this->hasMany(EventExtractionDraft::class);
    }

    public function scopeUnprocessed($query)
    {
        return $query->where('processed', false);
    }

    public function scopeProcessed($query)
    {
        return $query->where('processed', true);
    }

    public function scopeForRegion($query, string $regionId)
    {
        return $query->where('region_id', $regionId);
    }

    public function scopeForBusiness($query, string $businessId)
    {
        return $query->where('business_id', $businessId);
    }

    public function scopeBySourceType($query, string $sourceType)
    {
        return $query->where('source_type', $sourceType);
    }

    public function scopeScored($query)
    {
        return $query->whereNotNull('relevance_score');
    }

    public function scopeUnscored($query)
    {
        return $query->whereNull('relevance_score');
    }

    public function markAsProcessed(): void
    {
        $this->update(['processed' => true]);
    }

    public function isScored(): bool
    {
        return $this->relevance_score !== null;
    }

    protected function casts(): array
    {
        return [
            'metadata' => 'array',
            'processed' => 'boolean',
            'published_at' => 'datetime',
            'relevance_topic_tags' => 'array',
            'scored_at' => 'datetime',
        ];
    }
}
```

### NewsArticleDraft
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class NewsArticleDraft extends Model
{
    use HasFactory, HasUuids;

    protected $fillable = [
        'news_article_id',
        'region_id',
        'status',
        'relevance_score',
        'quality_score',
        'fact_check_confidence',
        'topic_tags',
        'outline',
        'generated_title',
        'generated_content',
        'generated_excerpt',
        'seo_metadata',
        'featured_image_url',
        'featured_image_path',
        'featured_image_disk',
        'ai_metadata',
        'published_post_id',
        'rejection_reason',
    ];

    public function newsArticle(): BelongsTo
    {
        return $this->belongsTo(NewsArticle::class);
    }

    public function region(): BelongsTo
    {
        return $this->belongsTo(Region::class);
    }

    public function publishedPost(): BelongsTo
    {
        return $this->belongsTo(DayNewsPost::class, 'published_post_id');
    }

    public function factChecks(): HasMany
    {
        return $this->hasMany(NewsFactCheck::class, 'draft_id');
    }

    public function scopeByStatus($query, string $status)
    {
        return $query->where('status', $status);
    }

    public function scopeShortlisted($query)
    {
        return $query->where('status', 'shortlisted');
    }

    public function scopeOutlineGenerated($query)
    {
        return $query->where('status', 'outline_generated');
    }

    public function scopeReadyForGeneration($query)
    {
        return $query->where('status', 'ready_for_generation');
    }

    public function scopeReadyForPublishing($query)
    {
        return $query->where('status', 'ready_for_publishing');
    }

    public function scopePublished($query)
    {
        return $query->where('status', 'published');
    }

    public function scopeRejected($query)
    {
        return $query->where('status', 'rejected');
    }

    public function scopeForRegion($query, string $regionId)
    {
        return $query->where('region_id', $regionId);
    }

    public function scopeAboveQualityThreshold($query, float $threshold)
    {
        return $query->where('quality_score', '>=', $threshold);
    }

    public function shouldAutoPublish(): bool
    {
        $threshold = config('news-workflow.publishing.auto_publish_threshold', 85);

        return $this->quality_score >= $threshold;
    }

    public function calculateAverageFactCheckConfidence(): void
    {
        $avg = $this->factChecks()->avg('confidence_score');

        $this->update(['fact_check_confidence' => $avg]);
    }

    public function getFeaturedImageUrlAttribute(): ?string
    {
        // Priority: local storage > original URL > null
        if ($this->featured_image_path && $this->featured_image_disk) {
            return \Illuminate\Support\Facades\Storage::disk($this->featured_image_disk)->url($this->featured_image_path);
        }

        return $this->attributes['featured_image_url'] ?? null;
    }

    protected function casts(): array
    {
        return [
            'relevance_score' => 'decimal:2',
            'quality_score' => 'decimal:2',
            'fact_check_confidence' => 'decimal:2',
            'topic_tags' => 'array',
            'seo_metadata' => 'array',
            'ai_metadata' => 'array',
        ];
    }
}
```

### NewsFactCheck
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class NewsFactCheck extends Model
{
    use HasFactory, HasUuids;

    protected $fillable = [
        'draft_id',
        'claim',
        'verification_result',
        'confidence_score',
        'sources',
        'scraped_evidence',
        'metadata',
    ];

    public function draft(): BelongsTo
    {
        return $this->belongsTo(NewsArticleDraft::class, 'draft_id');
    }

    public function scopeVerified($query)
    {
        return $query->where('verification_result', 'verified');
    }

    public function scopeUnverified($query)
    {
        return $query->where('verification_result', 'unverified');
    }

    public function scopeContradicted($query)
    {
        return $query->where('verification_result', 'contradicted');
    }

    public function scopeAboveConfidence($query, float $threshold)
    {
        return $query->where('confidence_score', '>=', $threshold);
    }

    public function scopeForDraft($query, string $draftId)
    {
        return $query->where('draft_id', $draftId);
    }

    public function isVerified(): bool
    {
        return $this->verification_result === 'verified';
    }

    public function isUnverified(): bool
    {
        return $this->verification_result === 'unverified';
    }

    public function isContradicted(): bool
    {
        return $this->verification_result === 'contradicted';
    }

    protected function casts(): array
    {
        return [
            'confidence_score' => 'decimal:2',
            'sources' => 'array',
            'scraped_evidence' => 'array',
            'metadata' => 'array',
        ];
    }
}
```

### NewsFetchFrequency
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

final class NewsFetchFrequency extends Model
{
    use HasFactory, HasUuids;

    public const FREQUENCY_DAILY = 'daily';

    public const FREQUENCY_WEEKLY = 'weekly';

    public const FREQUENCY_MONTHLY = 'monthly';

    public const FREQUENCY_CUSTOM_DAYS = 'custom_days';

    public const CATEGORY_TYPE_NEWS = 'news_category';

    public const CATEGORY_TYPE_BUSINESS = 'business_category';

    protected $fillable = [
        'category',
        'category_type',
        'frequency_type',
        'custom_interval_days',
        'last_fetched_at',
        'is_enabled',
        'metadata',
    ];

    /**
     * @return array<string, string>
     */
    public static function frequencyOptions(): array
    {
        return [
            self::FREQUENCY_DAILY => 'Daily',
            self::FREQUENCY_WEEKLY => 'Weekly',
            self::FREQUENCY_MONTHLY => 'Monthly',
            self::FREQUENCY_CUSTOM_DAYS => 'Custom Days',
        ];
    }

    /**
     * @return array<string, string>
     */
    public static function categoryTypeOptions(): array
    {
        return [
            self::CATEGORY_TYPE_NEWS => 'News Category',
            self::CATEGORY_TYPE_BUSINESS => 'Business Category',
        ];
    }

    /**
     * @param  Builder<NewsFetchFrequency>  $query
     * @return Builder<NewsFetchFrequency>
     */
    public function scopeEnabled(Builder $query): Builder
    {
        return $query->where('is_enabled', true);
    }

    /**
     * @param  Builder<NewsFetchFrequency>  $query
     * @return Builder<NewsFetchFrequency>
     */
    public function scopeForNewsCategories(Builder $query): Builder
    {
        return $query->where('category_type', self::CATEGORY_TYPE_NEWS);
    }

    /**
     * @param  Builder<NewsFetchFrequency>  $query
     * @return Builder<NewsFetchFrequency>
     */
    public function scopeForBusinessCategories(Builder $query): Builder
    {
        return $query->where('category_type', self::CATEGORY_TYPE_BUSINESS);
    }

    /**
     * @param  Builder<NewsFetchFrequency>  $query
     * @return Builder<NewsFetchFrequency>
     */
    public function scopeForCategory(Builder $query, string $category, string $categoryType): Builder
    {
        return $query->where('category', $category)->where('category_type', $categoryType);
    }

    public function getIntervalInDays(): int
    {
        return match ($this->frequency_type) {
            self::FREQUENCY_DAILY => 1,
            self::FREQUENCY_WEEKLY => 7,
            self::FREQUENCY_MONTHLY => 30,
            self::FREQUENCY_CUSTOM_DAYS => $this->custom_interval_days ?? 1,
            default => 1,
        };
    }

    public function shouldFetchToday(): bool
    {
        if (! $this->is_enabled) {
            return false;
        }

        if ($this->last_fetched_at === null) {
            return true;
        }

        $daysSinceLastFetch = $this->last_fetched_at->diffInDays(now());

        return $daysSinceLastFetch >= $this->getIntervalInDays();
    }

    public function markAsFetched(): void
    {
        $this->update(['last_fetched_at' => now()]);
    }

    public function getNextFetchDate(): ?\Carbon\CarbonInterface
    {
        if ($this->last_fetched_at === null) {
            return now();
        }

        return $this->last_fetched_at->addDays($this->getIntervalInDays());
    }

    /**
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'custom_interval_days' => 'integer',
            'last_fetched_at' => 'datetime',
            'is_enabled' => 'boolean',
            'metadata' => 'array',
        ];
    }
}
```

### NewsWorkflowRun
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class NewsWorkflowRun extends Model
{
    use HasFactory, HasUuids;

    protected $fillable = [
        'region_id',
        'phase',
        'status',
        'started_at',
        'completed_at',
        'items_processed',
        'summary',
        'error_message',
        'error_trace',
    ];

    public function region(): BelongsTo
    {
        return $this->belongsTo(Region::class);
    }

    public function scopeForRegion($query, string $regionId)
    {
        return $query->where('region_id', $regionId);
    }

    public function scopeByPhase($query, string $phase)
    {
        return $query->where('phase', $phase);
    }

    public function scopeRunning($query)
    {
        return $query->where('status', 'running');
    }

    public function scopeCompleted($query)
    {
        return $query->where('status', 'completed');
    }

    public function scopeFailed($query)
    {
        return $query->where('status', 'failed');
    }

    public function scopeRecent($query, int $days = 7)
    {
        return $query->where('started_at', '>=', now()->subDays($days));
    }

    public function isRunning(): bool
    {
        return $this->status === 'running';
    }

    public function isCompleted(): bool
    {
        return $this->status === 'completed';
    }

    public function isFailed(): bool
    {
        return $this->status === 'failed';
    }

    public function getDuration(): ?int
    {
        if (! $this->completed_at) {
            return null;
        }

        return $this->started_at->diffInSeconds($this->completed_at);
    }

    protected function casts(): array
    {
        return [
            'started_at' => 'datetime',
            'completed_at' => 'datetime',
            'summary' => 'array',
        ];
    }
}
```

### NewsWorkflowSetting
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\Cache;

final class NewsWorkflowSetting extends Model
{
    use HasFactory;
    private const CACHE_KEY = 'news_workflow_settings';

    private const CACHE_TTL = 3600; // 1 hour

    protected $fillable = [
        'key',
        'value',
        'type',
        'description',
    ];

    /**
     * Get a setting value by key.
     */
    public static function get(string $key, mixed $default = null): mixed
    {
        $settings = self::getAllCached();

        if (! isset($settings[$key])) {
            return $default;
        }

        return self::castValue($settings[$key]['value'], $settings[$key]['type']);
    }

    /**
     * Set a setting value.
     */
    public static function set(string $key, mixed $value, ?string $description = null): void
    {
        $setting = self::query()->where('key', $key)->first();

        $stringValue = is_bool($value) ? ($value ? 'true' : 'false') : (string) $value;

        if ($setting) {
            $setting->update(['value' => $stringValue]);
        } else {
            self::create([
                'key' => $key,
                'value' => $stringValue,
                'type' => is_bool($value) ? 'boolean' : 'string',
                'description' => $description,
            ]);
        }

        self::clearCache();
    }

    /**
     * Get all settings as cached array.
     *
     * @return array<string, array{value: string, type: string}>
     */
    public static function getAllCached(): array
    {
        return Cache::remember(self::CACHE_KEY, self::CACHE_TTL, function () {
            return self::query()
                ->get()
                ->keyBy('key')
                ->map(fn ($setting) => [
                    'value' => $setting->value,
                    'type' => $setting->type,
                ])
                ->toArray();
        });
    }

    /**
     * Clear the settings cache.
     */
    public static function clearCache(): void
    {
        Cache::forget(self::CACHE_KEY);
    }

    /**
     * Cast a value to its proper type.
     */
    private static function castValue(string $value, string $type): mixed
    {
        return match ($type) {
            'boolean' => in_array(mb_strtolower($value), ['true', '1', 'yes'], true),
            'integer' => (int) $value,
            'float' => (float) $value,
            default => $value,
        };
    }
}
```

### NewsletterSubscription
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class NewsletterSubscription extends Model
{
    use HasFactory;

    protected $fillable = [
        'subscriber_id',
        'tier',
        'price',
        'stripe_subscription_id',
        'status',
        'started_at',
        'cancelled_at',
        'current_period_end',
    ];

    protected $casts = [
        'price' => 'decimal:2',
        'started_at' => 'datetime',
        'cancelled_at' => 'datetime',
        'current_period_end' => 'datetime',
    ];

    public function subscriber(): BelongsTo
    {
        return $this->belongsTo(EmailSubscriber::class, 'subscriber_id');
    }
}
```

### Notification
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class Notification extends Model
{
    /** @use HasFactory<\Database\Factories\NotificationFactory> */
    use HasFactory;

    protected $fillable = [
        'user_id',
        'type',
        'data',
        'read',
        'title',
        'message',
        'action_url',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function markAsRead(): void
    {
        $this->update(['read' => true]);
    }

    public function scopeUnread($query)
    {
        return $query->where('read', false);
    }

    public function scopeForUser($query, $userId)
    {
        return $query->where('user_id', $userId);
    }

    protected function casts(): array
    {
        return [
            'data' => 'array',
            'read' => 'boolean',
        ];
    }
}
```

### NotificationLog
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

final class NotificationLog extends Model
{
    use HasFactory, HasUuid;

    protected $table = 'notification_log';

    protected $fillable = [
        'platform',
        'community_id',
        'notification_type',
        'channel',
        'title',
        'message',
        'payload',
        'recipient_count',
        'sns_message_id',
        'status',
        'error_message',
        'sent_at',
    ];

    protected $casts = [
        'payload' => 'array',
        'recipient_count' => 'integer',
        'sent_at' => 'datetime',
    ];

    /**
     * Scope: For specific platform
     */
    public function scopeForPlatform($query, string $platform)
    {
        return $query->where('platform', $platform);
    }

    /**
     * Scope: For specific community
     */
    public function scopeForCommunity($query, string $communityId)
    {
        return $query->where('community_id', $communityId);
    }

    /**
     * Scope: By status
     */
    public function scopeByStatus($query, string $status)
    {
        return $query->where('status', $status);
    }

    /**
     * Mark as sent
     */
    public function markAsSent(): void
    {
        $this->update([
            'status' => 'sent',
            'sent_at' => now(),
        ]);
    }

    /**
     * Mark as failed
     */
    public function markAsFailed(string $errorMessage): void
    {
        $this->update([
            'status' => 'failed',
            'error_message' => $errorMessage,
        ]);
    }

    /**
     * Mark as partial (some succeeded, some failed)
     */
    public function markAsPartial(): void
    {
        $this->update([
            'status' => 'partial',
            'sent_at' => now(),
        ]);
    }
}
```

### NotificationSubscription
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Carbon\Carbon;

final class NotificationSubscription extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'user_id',
        'platform',
        'community_id',
        'business_id',
        'phone_number',
        'phone_verified',
        'phone_verified_at',
        'web_push_endpoint',
        'web_push_p256dh',
        'web_push_auth',
        'sns_sms_subscription_arn',
        'sns_endpoint_arn',
        'notification_types',
        'frequency',
        'quiet_hours_start',
        'quiet_hours_end',
        'status',
        'last_notification_at',
    ];

    protected $casts = [
        'phone_verified' => 'boolean',
        'phone_verified_at' => 'datetime',
        'notification_types' => 'array',
        'quiet_hours_start' => 'datetime:H:i',
        'quiet_hours_end' => 'datetime:H:i',
        'last_notification_at' => 'datetime',
    ];

    /**
     * Get the user that owns the subscription
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Get the business (for AlphaSite)
     */
    public function business(): BelongsTo
    {
        return $this->belongsTo(Business::class);
    }

    /**
     * Scope: Active subscriptions
     */
    public function scopeActive($query)
    {
        return $query->where('status', 'active');
    }

    /**
     * Scope: For specific platform
     */
    public function scopeForPlatform($query, string $platform)
    {
        return $query->where('platform', $platform);
    }

    /**
     * Scope: For specific community
     */
    public function scopeForCommunity($query, string $communityId)
    {
        return $query->where('community_id', $communityId);
    }

    /**
     * Scope: Has SMS subscription
     */
    public function scopeHasSms($query)
    {
        return $query->whereNotNull('phone_number')
            ->where('phone_verified', true)
            ->whereNotNull('sns_sms_subscription_arn');
    }

    /**
     * Scope: Has web push subscription
     */
    public function scopeHasWebPush($query)
    {
        return $query->whereNotNull('web_push_endpoint');
    }

    /**
     * Check if currently in quiet hours
     */
    public function isQuietHours(): bool
    {
        $now = Carbon::now()->format('H:i');
        $start = Carbon::parse($this->quiet_hours_start)->format('H:i');
        $end = Carbon::parse($this->quiet_hours_end)->format('H:i');

        if ($start <= $end) {
            // Normal case: 22:00 to 08:00
            return $now >= $start || $now <= $end;
        } else {
            // Wraps midnight: 22:00 to 08:00
            return $now >= $start || $now <= $end;
        }
    }

    /**
     * Check if user wants this notification type
     */
    public function wantsNotificationType(string $type): bool
    {
        return in_array($type, $this->notification_types ?? []);
    }

    /**
     * Check if subscription is active and ready
     */
    public function isActive(): bool
    {
        return $this->status === 'active' && !$this->isQuietHours();
    }
}
```

### Order
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;

final class Order extends Model
{
    use HasFactory, HasUuid, SoftDeletes;

    protected $fillable = [
        'order_number',
        'store_id',
        'user_id',
        'customer_email',
        'customer_name',
        'subtotal',
        'tax',
        'shipping',
        'total',
        'status',
        'payment_status',
        'stripe_payment_intent_id',
        'stripe_charge_id',
        'shipping_address',
        'billing_address',
        'notes',
        'paid_at',
    ];

    public function store(): BelongsTo
    {
        return $this->belongsTo(Store::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function items(): HasMany
    {
        return $this->hasMany(OrderItem::class);
    }

    public function isPaid(): bool
    {
        return $this->payment_status === 'paid';
    }

    public function isPending(): bool
    {
        return $this->status === 'pending';
    }

    public function isProcessing(): bool
    {
        return $this->status === 'processing';
    }

    public function isCompleted(): bool
    {
        return $this->status === 'completed';
    }

    public function isCancelled(): bool
    {
        return $this->status === 'cancelled';
    }

    public function isRefunded(): bool
    {
        return $this->payment_status === 'refunded';
    }

    protected static function booted(): void
    {
        self::creating(function (Order $order) {
            if (! $order->order_number) {
                $order->order_number = 'ORD-'.mb_strtoupper(uniqid());
            }
        });
    }

    protected function casts(): array
    {
        return [
            'subtotal' => 'decimal:2',
            'tax' => 'decimal:2',
            'shipping' => 'decimal:2',
            'total' => 'decimal:2',
            'shipping_address' => 'array',
            'billing_address' => 'array',
            'paid_at' => 'datetime',
        ];
    }
}
```

### OrderItem
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class OrderItem extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'order_id',
        'product_id',
        'product_name',
        'product_description',
        'price',
        'quantity',
        'total',
        'metadata',
    ];

    public function order(): BelongsTo
    {
        return $this->belongsTo(Order::class);
    }

    public function product(): BelongsTo
    {
        return $this->belongsTo(Product::class);
    }

    protected function casts(): array
    {
        return [
            'price' => 'decimal:2',
            'total' => 'decimal:2',
            'metadata' => 'array',
        ];
    }
}
```

### OrganizationHierarchy
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class OrganizationHierarchy extends Model
{
    /** @use HasFactory<\Database\Factories\OrganizationHierarchyFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'organization_id',
        'parent_id',
        'level',
        'path',
    ];

    public function organization(): BelongsTo
    {
        return $this->belongsTo(Business::class, 'organization_id');
    }

    public function parent(): BelongsTo
    {
        return $this->belongsTo(Business::class, 'parent_id');
    }

    // Scopes
    public function scopeByLevel($query, int $level)
    {
        return $query->where('level', $level);
    }

    public function scopeRoots($query)
    {
        return $query->where('level', 0)->whereNull('parent_id');
    }

    protected function casts(): array
    {
        return [
            'level' => 'integer',
        ];
    }
}

```

### OrganizationRelationship
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\MorphTo;
use Illuminate\Database\Eloquent\SoftDeletes;

final class OrganizationRelationship extends Model
{
    /** @use HasFactory<\Database\Factories\OrganizationRelationshipFactory> */
    use HasFactory, HasUuid, SoftDeletes;

    protected $fillable = [
        'organization_id',
        'relatable_type',
        'relatable_id',
        'relationship_type',
        'is_primary',
        'metadata',
    ];

    public function organization(): BelongsTo
    {
        return $this->belongsTo(Business::class, 'organization_id');
    }

    public function relatable(): MorphTo
    {
        return $this->morphTo();
    }

    // Scopes
    public function scopePrimary($query)
    {
        return $query->where('is_primary', true);
    }

    public function scopeByRelationshipType($query, string $type)
    {
        return $query->where('relationship_type', $type);
    }

    public function scopeByRelatableType($query, string $type)
    {
        return $query->where('relatable_type', $type);
    }

    public function scopeForOrganization($query, string $organizationId)
    {
        return $query->where('organization_id', $organizationId);
    }

    protected function casts(): array
    {
        return [
            'is_primary' => 'boolean',
            'metadata' => 'array',
        ];
    }
}

```

### Performer
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use App\Traits\HasReviewsAndRatings;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\MorphMany;

final class Performer extends Model
{
    /** @use HasFactory<\Database\Factories\PerformerFactory> */
    use HasFactory, HasReviewsAndRatings, HasUuid;

    protected $fillable = [
        'name',
        'profile_image',
        'genres',
        'rating',
        'review_count',
        'follower_count',
        'bio',
        'years_active',
        'shows_played',
        'home_city',
        'is_verified',
        'is_touring_now',
        'available_for_booking',
        'has_merchandise',
        'has_original_music',
        'offers_meet_and_greet',
        'takes_requests',
        'available_for_private_events',
        'is_family_friendly',
        'has_samples',
        'trending_score',
        'distance_miles',
        'added_date',
        'introductory_pricing',
        'base_price',
        'currency',
        'minimum_booking_hours',
        'travel_fee_per_mile',
        'setup_fee',
        'cancellation_policy',
        'status',
        'workspace_id',
        'created_by',
        'average_rating',
        'total_reviews',
    ];

    public function workspace(): BelongsTo
    {
        return $this->belongsTo(Workspace::class);
    }

    public function createdBy(): BelongsTo
    {
        return $this->belongsTo(User::class, 'created_by');
    }

    public function events(): HasMany
    {
        return $this->hasMany(Event::class);
    }

    public function bookings(): HasMany
    {
        return $this->hasMany(Booking::class);
    }

    public function upcomingShows(): HasMany
    {
        return $this->hasMany(UpcomingShow::class);
    }

    public function follows(): MorphMany
    {
        return $this->morphMany(Follow::class, 'followable');
    }

    // Computed attributes for frontend compatibility
    public function getImageAttribute(): ?string
    {
        return $this->profile_image;
    }

    public function getUpcomingShowAttribute(): ?array
    {
        $nextShow = $this->upcomingShows()->upcoming()->first();

        if (! $nextShow) {
            return null;
        }

        return [
            'date' => $nextShow->date->format('Y-m-d'),
            'venue' => $nextShow->venue,
            'ticketsAvailable' => $nextShow->tickets_available,
        ];
    }

    public function getDistanceMilesAttribute(): float
    {
        // This would be calculated based on user's location
        // For now, return a default value
        return (float) ($this->attributes['distance_miles'] ?? 0.0);
    }

    // Scopes
    public function scopeActive($query)
    {
        return $query->where('status', 'active');
    }

    public function scopeVerified($query)
    {
        return $query->where('is_verified', true);
    }

    public function scopeAvailableForBooking($query)
    {
        return $query->where('available_for_booking', true);
    }

    public function scopeByGenre($query, string $genre)
    {
        return $query->whereJsonContains('genres', $genre);
    }

    public function scopeFamilyFriendly($query)
    {
        return $query->where('is_family_friendly', true);
    }

    public function scopeTrending($query)
    {
        return $query->orderBy('trending_score', 'desc');
    }

    public function scopeWithinRadius($query, float $lat, float $lng, float $radius)
    {
        // This would need to be implemented based on performer's location
        // For now, return all performers
        return $query;
    }

    protected function casts(): array
    {
        return [
            'genres' => 'array',
            'average_rating' => 'decimal:2',
            'is_verified' => 'boolean',
            'is_touring_now' => 'boolean',
            'available_for_booking' => 'boolean',
            'has_merchandise' => 'boolean',
            'has_original_music' => 'boolean',
            'offers_meet_and_greet' => 'boolean',
            'takes_requests' => 'boolean',
            'available_for_private_events' => 'boolean',
            'is_family_friendly' => 'boolean',
            'has_samples' => 'boolean',
            'distance_miles' => 'decimal:2',
            'added_date' => 'date',
            'introductory_pricing' => 'boolean',
            'base_price' => 'decimal:2',
            'travel_fee_per_mile' => 'decimal:2',
            'setup_fee' => 'decimal:2',
        ];
    }
}
```

### PhoneVerification
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Carbon\Carbon;

final class PhoneVerification extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'phone_number',
        'code',
        'expires_at',
        'attempts',
        'verified',
    ];

    protected $casts = [
        'expires_at' => 'datetime',
        'attempts' => 'integer',
        'verified' => 'boolean',
    ];

    /**
     * Scope: Valid (not expired, not verified, attempts < 5)
     */
    public function scopeValid($query)
    {
        return $query->where('expires_at', '>', Carbon::now())
            ->where('verified', false)
            ->where('attempts', '<', 5);
    }

    /**
     * Scope: For specific phone number
     */
    public function scopeForPhone($query, string $phoneNumber)
    {
        return $query->where('phone_number', $phoneNumber);
    }

    /**
     * Check if verification is expired
     */
    public function isExpired(): bool
    {
        return $this->expires_at->isPast();
    }

    /**
     * Increment attempts
     */
    public function incrementAttempts(): void
    {
        $this->increment('attempts');
    }
}
```

### Photo
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use App\Traits\HasReviewsAndRatings;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\MorphMany;
use Illuminate\Support\Facades\Storage;

final class Photo extends Model
{
    use HasFactory, HasUuid, HasReviewsAndRatings;

    protected $fillable = [
        'user_id',
        'album_id',
        'title',
        'description',
        'image_path',
        'image_disk',
        'thumbnail_path',
        'category',
        'status',
        'width',
        'height',
        'file_size',
        'views_count',
        'likes_count',
        'comments_count',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function album(): BelongsTo
    {
        return $this->belongsTo(PhotoAlbum::class, 'album_id');
    }

    public function albums(): BelongsToMany
    {
        return $this->belongsToMany(PhotoAlbum::class, 'photo_album_photo')
            ->withPivot('order')
            ->withTimestamps();
    }

    public function regions(): BelongsToMany
    {
        return $this->belongsToMany(Region::class, 'photo_region')
            ->withTimestamps();
    }

    // Photos don't use ArticleComment - they would need their own comment system
    // For now, we'll leave this out or create a separate PhotoComment model if needed

    public function getImageUrlAttribute(): string
    {
        return Storage::disk($this->image_disk)->url($this->image_path);
    }

    public function getThumbnailUrlAttribute(): ?string
    {
        if (!$this->thumbnail_path) {
            return $this->image_url;
        }
        return Storage::disk($this->image_disk)->url($this->thumbnail_path);
    }

    // Scopes
    public function scopeApproved($query)
    {
        return $query->where('status', 'approved');
    }

    public function scopeByCategory($query, string $category)
    {
        return $query->where('category', $category);
    }

    public function scopeForRegion($query, int $regionId)
    {
        return $query->whereHas('regions', function ($q) use ($regionId) {
            $q->where('region_id', $regionId);
        });
    }

    public function scopePublic($query)
    {
        return $query->whereHas('album', function ($q) {
            $q->where('visibility', 'public');
        })->orWhereNull('album_id');
    }

    public function incrementViewsCount(): void
    {
        $this->increment('views_count');
    }

    public function incrementLikesCount(): void
    {
        $this->increment('likes_count');
    }

    public function incrementCommentsCount(): void
    {
        $this->increment('comments_count');
    }

    protected function casts(): array
    {
        return [
            'width' => 'integer',
            'height' => 'integer',
            'file_size' => 'integer',
            'views_count' => 'integer',
            'likes_count' => 'integer',
            'comments_count' => 'integer',
        ];
    }
}

```

### PhotoAlbum
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class PhotoAlbum extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'user_id',
        'workspace_id',
        'title',
        'description',
        'cover_image',
        'visibility',
        'photos_count',
        'views_count',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function workspace(): BelongsTo
    {
        return $this->belongsTo(Workspace::class);
    }

    public function photos(): BelongsToMany
    {
        return $this->belongsToMany(Photo::class, 'photo_album_photo')
            ->withPivot('order')
            ->orderBy('photo_album_photo.order')
            ->withTimestamps();
    }

    // Albums don't directly have regions - photos do
    // Use a helper method to get regions from photos
    public function getRegionsAttribute()
    {
        return Region::whereHas('photos', function ($q) {
            $q->where('album_id', $this->id);
        })->get();
    }

    public function incrementViewsCount(): void
    {
        $this->increment('views_count');
    }

    public function incrementPhotosCount(): void
    {
        $this->increment('photos_count');
    }

    protected function casts(): array
    {
        return [
            'photos_count' => 'integer',
            'views_count' => 'integer',
        ];
    }
}

```

### PlannedEvent
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class PlannedEvent extends Model
{
    /** @use HasFactory<\Database\Factories\PlannedEventFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'event_id',
        'user_id',
        'planned_at',
        'reminder_sent',
        'reminder_sent_at',
        'notes',
    ];

    protected function casts(): array
    {
        return [
            'planned_at' => 'datetime',
            'reminder_sent' => 'boolean',
            'reminder_sent_at' => 'datetime',
        ];
    }

    public function event(): BelongsTo
    {
        return $this->belongsTo(Event::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function scopeForUser($query, string $userId)
    {
        return $query->where('user_id', $userId);
    }

    public function scopeUpcoming($query)
    {
        return $query->whereHas('event', function ($q) {
            $q->where('event_date', '>=', now());
        });
    }

    public function scopeNeedsReminder($query, int $hoursBefore = 24)
    {
        return $query->where('reminder_sent', false)
            ->whereHas('event', function ($q) use ($hoursBefore) {
                $q->whereBetween('event_date', [
                    now(),
                    now()->addHours($hoursBefore),
                ]);
            });
    }
}

```

### Podcast
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\MorphMany;
use Illuminate\Support\Str;

final class Podcast extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'creator_profile_id',
        'title',
        'slug',
        'description',
        'cover_image',
        'category',
        'status',
        'published_at',
        'episodes_count',
        'subscribers_count',
        'total_listens',
        'total_duration',
    ];

    public function creator(): BelongsTo
    {
        return $this->belongsTo(CreatorProfile::class, 'creator_profile_id');
    }

    public function episodes(): HasMany
    {
        return $this->hasMany(PodcastEpisode::class, 'podcast_id')
            ->orderBy('published_at', 'desc');
    }

    public function publishedEpisodes(): HasMany
    {
        return $this->episodes()->where('status', 'published');
    }

    public function regions(): BelongsToMany
    {
        return $this->belongsToMany(Region::class, 'podcast_region')
            ->withTimestamps();
    }

    public function followers(): MorphMany
    {
        return $this->morphMany(Follow::class, 'followable');
    }

    // Scopes
    public function scopePublished($query)
    {
        return $query->where('status', 'published')
            ->whereNotNull('published_at');
    }

    public function scopeByCategory($query, string $category)
    {
        return $query->where('category', $category);
    }

    public function scopeForRegion($query, int $regionId)
    {
        return $query->whereHas('regions', function ($q) use ($regionId) {
            $q->where('region_id', $regionId);
        });
    }

    public function incrementSubscribersCount(): void
    {
        $this->increment('subscribers_count');
    }

    public function incrementEpisodesCount(): void
    {
        $this->increment('episodes_count');
        $this->creator->incrementEpisodesCount();
    }

    public function incrementTotalListens(): void
    {
        $this->increment('total_listens');
        $this->creator->increment('total_listens');
    }

    protected static function booted(): void
    {
        self::creating(function (Podcast $podcast): void {
            if (empty($podcast->slug)) {
                $podcast->slug = static::generateUniqueSlug($podcast->title);
            }
        });

        self::created(function (Podcast $podcast): void {
            $podcast->creator->incrementPodcastsCount();
        });
    }

    protected static function generateUniqueSlug(string $title): string
    {
        $slug = Str::slug($title);
        $originalSlug = $slug;
        $count = 1;

        while (self::where('slug', $slug)->exists()) {
            $slug = $originalSlug . '-' . $count;
            $count++;
        }

        return $slug;
    }

    protected function casts(): array
    {
        return [
            'published_at' => 'datetime',
            'episodes_count' => 'integer',
            'subscribers_count' => 'integer',
            'total_listens' => 'integer',
            'total_duration' => 'integer',
        ];
    }
}

```

### PodcastEpisode
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\MorphMany;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;

final class PodcastEpisode extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'podcast_id',
        'title',
        'slug',
        'description',
        'show_notes',
        'audio_file_path',
        'audio_file_disk',
        'duration',
        'file_size',
        'episode_number',
        'status',
        'published_at',
        'listens_count',
        'downloads_count',
        'likes_count',
        'comments_count',
    ];

    public function podcast(): BelongsTo
    {
        return $this->belongsTo(Podcast::class, 'podcast_id');
    }

    // Podcast episodes can have comments, but they would need their own comment system
    // For now, we'll use the comments_count field to track engagement
    // TODO: Create PodcastComment model if comments are needed

    public function getAudioUrlAttribute(): string
    {
        return Storage::disk($this->audio_file_disk)->url($this->audio_file_path);
    }

    public function getFormattedDurationAttribute(): string
    {
        if (!$this->duration) {
            return '0:00';
        }

        $hours = floor($this->duration / 3600);
        $minutes = floor(($this->duration % 3600) / 60);
        $seconds = $this->duration % 60;

        if ($hours > 0) {
            return sprintf('%d:%02d:%02d', $hours, $minutes, $seconds);
        }

        return sprintf('%d:%02d', $minutes, $seconds);
    }

    // Scopes
    public function scopePublished($query)
    {
        return $query->where('status', 'published')
            ->whereNotNull('published_at');
    }

    public function incrementListensCount(): void
    {
        $this->increment('listens_count');
        $this->podcast->incrementTotalListens();
    }

    public function incrementDownloadsCount(): void
    {
        $this->increment('downloads_count');
    }

    public function incrementLikesCount(): void
    {
        $this->increment('likes_count');
    }

    public function incrementCommentsCount(): void
    {
        $this->increment('comments_count');
    }

    protected static function booted(): void
    {
        self::creating(function (PodcastEpisode $episode): void {
            if (empty($episode->slug)) {
                $episode->slug = static::generateUniqueSlug($episode->title);
            }
        });

        self::created(function (PodcastEpisode $episode): void {
            $episode->podcast->incrementEpisodesCount();
        });
    }

    protected static function generateUniqueSlug(string $title): string
    {
        $slug = Str::slug($title);
        $originalSlug = $slug;
        $count = 1;

        while (self::where('slug', $slug)->exists()) {
            $slug = $originalSlug . '-' . $count;
            $count++;
        }

        return $slug;
    }

    protected function casts(): array
    {
        return [
            'duration' => 'integer',
            'file_size' => 'integer',
            'published_at' => 'datetime',
            'listens_count' => 'integer',
            'downloads_count' => 'integer',
            'likes_count' => 'integer',
            'comments_count' => 'integer',
        ];
    }
}

```

### Product
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;

final class Product extends Model
{
    use HasFactory, HasUuid, SoftDeletes;

    protected $fillable = [
        'store_id',
        'name',
        'slug',
        'description',
        'images',
        'price',
        'compare_at_price',
        'quantity',
        'track_inventory',
        'sku',
        'is_active',
        'is_featured',
        'stripe_price_id',
        'stripe_product_id',
        'metadata',
    ];

    public function store(): BelongsTo
    {
        return $this->belongsTo(Store::class);
    }

    public function orderItems(): HasMany
    {
        return $this->hasMany(OrderItem::class);
    }

    public function isInStock(): bool
    {
        if (! $this->track_inventory) {
            return true;
        }

        return $this->quantity > 0;
    }

    public function hasDiscount(): bool
    {
        return $this->compare_at_price && $this->compare_at_price > $this->price;
    }

    public function getDiscountPercentageAttribute(): ?float
    {
        if (! $this->hasDiscount()) {
            return null;
        }

        return round((($this->compare_at_price - $this->price) / $this->compare_at_price) * 100, 2);
    }

    protected function casts(): array
    {
        return [
            'images' => 'array',
            'price' => 'decimal:2',
            'compare_at_price' => 'decimal:2',
            'track_inventory' => 'boolean',
            'is_active' => 'boolean',
            'is_featured' => 'boolean',
            'metadata' => 'array',
        ];
    }
}
```

### PromoCode
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Support\Str;

final class PromoCode extends Model
{
    /** @use HasFactory<\Database\Factories\PromoCodeFactory> */
    use HasFactory, HasUuid;

    public const TYPE_PERCENTAGE = 'percentage';
    public const TYPE_FIXED = 'fixed';

    public const TYPES = [
        self::TYPE_PERCENTAGE,
        self::TYPE_FIXED,
    ];

    protected $fillable = [
        'code',
        'description',
        'type',
        'value',
        'min_purchase',
        'max_discount',
        'usage_limit',
        'used_count',
        'is_active',
        'starts_at',
        'expires_at',
        'applicable_to',
        'metadata',
    ];

    protected function casts(): array
    {
        return [
            'value' => 'decimal:2',
            'min_purchase' => 'decimal:2',
            'max_discount' => 'decimal:2',
            'usage_limit' => 'integer',
            'used_count' => 'integer',
            'is_active' => 'boolean',
            'starts_at' => 'datetime',
            'expires_at' => 'datetime',
            'applicable_to' => 'array',
            'metadata' => 'array',
        ];
    }

    public function usages(): HasMany
    {
        return $this->hasMany(PromoCodeUsage::class);
    }

    public function scopeActive($query)
    {
        return $query->where('is_active', true)
            ->where(function ($q) {
                $q->whereNull('starts_at')
                    ->orWhere('starts_at', '<=', now());
            })
            ->where(function ($q) {
                $q->whereNull('expires_at')
                    ->orWhere('expires_at', '>=', now());
            });
    }

    public function scopeValid($query)
    {
        return $query->active()
            ->where(function ($q) {
                $q->whereNull('usage_limit')
                    ->orWhereColumn('used_count', '<', 'usage_limit');
            });
    }

    public function isValid(): bool
    {
        if (!$this->is_active) {
            return false;
        }

        if ($this->starts_at && $this->starts_at->isFuture()) {
            return false;
        }

        if ($this->expires_at && $this->expires_at->isPast()) {
            return false;
        }

        if ($this->usage_limit && $this->used_count >= $this->usage_limit) {
            return false;
        }

        return true;
    }

    public function calculateDiscount(float $amount): float
    {
        if (!$this->isValid()) {
            return 0;
        }

        if ($this->min_purchase && $amount < $this->min_purchase) {
            return 0;
        }

        $discount = match ($this->type) {
            self::TYPE_PERCENTAGE => $amount * ($this->value / 100),
            self::TYPE_FIXED => $this->value,
            default => 0,
        };

        if ($this->max_discount && $discount > $this->max_discount) {
            $discount = $this->max_discount;
        }

        return min($discount, $amount);
    }

    public static function generateUniqueCode(int $length = 8): string
    {
        do {
            $code = strtoupper(Str::random($length));
        } while (self::where('code', $code)->exists());

        return $code;
    }
}

```

### PromoCodeUsage
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class PromoCodeUsage extends Model
{
    /** @use HasFactory<\Database\Factories\PromoCodeUsageFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'promo_code_id',
        'user_id',
        'ticket_order_id',
        'discount_amount',
        'original_amount',
        'final_amount',
        'used_at',
    ];

    protected function casts(): array
    {
        return [
            'discount_amount' => 'decimal:2',
            'original_amount' => 'decimal:2',
            'final_amount' => 'decimal:2',
            'used_at' => 'datetime',
        ];
    }

    public function promoCode(): BelongsTo
    {
        return $this->belongsTo(PromoCode::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function ticketOrder(): BelongsTo
    {
        return $this->belongsTo(TicketOrder::class);
    }
}

```

### Rating
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\MorphTo;

final class Rating extends Model
{
    /** @use HasFactory<\Database\Factories\RatingFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'ratable_type',
        'ratable_id',
        'user_id',
        'rating',
        'context',
        'notes',
        'type',
        'booking_id',
    ];

    public function ratable(): MorphTo
    {
        return $this->morphTo();
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function booking(): BelongsTo
    {
        return $this->belongsTo(Booking::class);
    }

    // Scopes
    public function scopeByContext($query, string $context)
    {
        return $query->where('context', $context);
    }

    public function scopeByType($query, string $type)
    {
        return $query->where('type', $type);
    }

    public function scopeByRating($query, int $rating)
    {
        return $query->where('rating', $rating);
    }

    public function scopeFromBookings($query)
    {
        return $query->where('type', 'booking');
    }

    protected function casts(): array
    {
        return [
            //
        ];
    }
}
```

### Region
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class Region extends Model
{
    /** @use HasFactory<\Database\Factories\RegionFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'name',
        'slug',
        'type',
        'parent_id',
        'description',
        'is_active',
        'display_order',
        'metadata',
        'latitude',
        'longitude',
    ];

    public function parent(): BelongsTo
    {
        return $this->belongsTo(self::class, 'parent_id');
    }

    public function children(): HasMany
    {
        return $this->hasMany(self::class, 'parent_id');
    }

    public function zipcodes(): HasMany
    {
        return $this->hasMany(RegionZipcode::class);
    }

    public function newsArticles(): HasMany
    {
        return $this->hasMany(NewsArticle::class);
    }

    public function businesses(): BelongsToMany
    {
        return $this->belongsToMany(Business::class, 'business_region')
            ->withTimestamps();
    }

    public function events(): BelongsToMany
    {
        return $this->belongsToMany(Event::class, 'event_region')
            ->withTimestamps();
    }

    /**
     * Get all ancestor regions (parents up the hierarchy)
     */
    public function ancestors(): array
    {
        $ancestors = [];
        $current = $this->parent;

        while ($current !== null) {
            $ancestors[] = $current;
            $current = $current->parent;
        }

        return $ancestors;
    }

    /**
     * Get all descendant regions (children down the hierarchy)
     */
    public function descendants(): array
    {
        $descendants = [];

        foreach ($this->children as $child) {
            $descendants[] = $child;
            $descendants = array_merge($descendants, $child->descendants());
        }

        return $descendants;
    }

    /**
     * Check if this region has a specific zipcode
     */
    public function hasZipcode(string $zipcode): bool
    {
        return $this->zipcodes()->where('zipcode', $zipcode)->exists();
    }

    /**
     * Get full hierarchical name
     */
    public function getFullNameAttribute(): string
    {
        $names = [$this->name];

        foreach ($this->ancestors() as $ancestor) {
            $names[] = $ancestor->name;
        }

        return implode(', ', $names);
    }

    // Scopes
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    public function scopeOfType($query, string $type)
    {
        return $query->where('type', $type);
    }

    public function scopeForZipcode($query, string $zipcode)
    {
        return $query->whereHas('zipcodes', function ($q) use ($zipcode) {
            $q->where('zipcode', $zipcode);
        });
    }

    public function scopeTopLevel($query)
    {
        return $query->whereNull('parent_id');
    }

    protected function casts(): array
    {
        return [
            'is_active' => 'boolean',
            'metadata' => 'array',
            'latitude' => 'decimal:7',
            'longitude' => 'decimal:7',
        ];
    }
}
```

### RegionZipcode
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class RegionZipcode extends Model
{
    /** @use HasFactory<\Database\Factories\RegionZipcodeFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'region_id',
        'zipcode',
        'is_primary',
    ];

    public function region(): BelongsTo
    {
        return $this->belongsTo(Region::class);
    }

    // Scopes
    public function scopePrimary($query)
    {
        return $query->where('is_primary', true);
    }

    public function scopeForZipcode($query, string $zipcode)
    {
        return $query->where('zipcode', $zipcode);
    }

    protected function casts(): array
    {
        return [
            'is_primary' => 'boolean',
        ];
    }
}
```

### Review
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\MorphTo;

final class Review extends Model
{
    /** @use HasFactory<\Database\Factories\ReviewFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'reviewable_type',
        'reviewable_id',
        'user_id',
        'title',
        'content',
        'rating',
        'is_verified',
        'is_featured',
        'helpful_votes',
        'helpful_count',
        'status',
        'approved_at',
        'approved_by',
        'rejection_reason',
    ];

    public function reviewable(): MorphTo
    {
        return $this->morphTo();
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function approvedBy(): BelongsTo
    {
        return $this->belongsTo(User::class, 'approved_by');
    }

    // Helper methods
    public function markAsHelpful(int $userId): void
    {
        $helpfulVotes = $this->helpful_votes ?? [];
        if (! in_array($userId, $helpfulVotes)) {
            $helpfulVotes[] = $userId;
            $this->update([
                'helpful_votes' => $helpfulVotes,
                'helpful_count' => count($helpfulVotes),
            ]);
        }
    }

    public function removeHelpful(int $userId): void
    {
        $helpfulVotes = $this->helpful_votes ?? [];
        $helpfulVotes = array_filter($helpfulVotes, fn ($id) => $id !== $userId);
        $this->update([
            'helpful_votes' => array_values($helpfulVotes),
            'helpful_count' => count($helpfulVotes),
        ]);
    }

    public function approve(int $approvedBy): void
    {
        $this->update([
            'status' => 'approved',
            'approved_at' => now(),
            'approved_by' => $approvedBy,
        ]);
    }

    public function reject(string $reason): void
    {
        $this->update([
            'status' => 'rejected',
            'rejection_reason' => $reason,
        ]);
    }

    // Scopes
    public function scopeApproved($query)
    {
        return $query->where('status', 'approved');
    }

    public function scopeByRating($query, int $rating)
    {
        return $query->where('rating', $rating);
    }

    public function scopeFeatured($query)
    {
        return $query->where('is_featured', true);
    }

    public function scopeVerified($query)
    {
        return $query->where('is_verified', true);
    }

    protected function casts(): array
    {
        return [
            'helpful_votes' => 'array',
            'is_verified' => 'boolean',
            'is_featured' => 'boolean',
            'approved_at' => 'datetime',
        ];
    }
}
```

### Role
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class Role extends Model
{
    use HasFactory;
    protected $fillable = [
        'name',
    ];

    protected $appends = [
        'permissions',
    ];

    public function memberships(): HasMany
    {
        return $this->hasMany(WorkspaceMembership::class);
    }

    public function getPermissionsAttribute(): array
    {
        return config('makerkit.workspaces.roles.'.mb_strtolower($this->name).'.permissions', []);
    }
}
```

### RssFeed
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;

final class RssFeed extends Model
{
    /** @use HasFactory<\Database\Factories\RssFeedFactory> */
    use HasFactory, HasUuid, SoftDeletes;

    protected $fillable = [
        'business_id',
        'url',
        'feed_type',
        'title',
        'description',
        'status',
        'health_status',
        'last_checked_at',
        'last_successful_fetch_at',
        'last_error',
        'fetch_frequency',
        'total_items_count',
        'metadata',
        'auto_approved',
    ];

    public function business(): BelongsTo
    {
        return $this->belongsTo(Business::class);
    }

    public function feedItems(): HasMany
    {
        return $this->hasMany(RssFeedItem::class);
    }

    public function dayNewsPosts(): HasMany
    {
        return $this->hasMany(DayNewsPost::class);
    }

    // Scopes
    public function scopeActive($query)
    {
        return $query->where('status', 'active');
    }

    public function scopeInactive($query)
    {
        return $query->where('status', 'inactive');
    }

    public function scopeBroken($query)
    {
        return $query->where('status', 'broken');
    }

    public function scopeHealthy($query)
    {
        return $query->where('health_status', 'healthy');
    }

    public function scopeDegraded($query)
    {
        return $query->where('health_status', 'degraded');
    }

    public function scopeUnhealthy($query)
    {
        return $query->where('health_status', 'unhealthy');
    }

    public function scopeByType($query, string $type)
    {
        return $query->where('feed_type', $type);
    }

    public function scopeAutoApproved($query)
    {
        return $query->where('auto_approved', true);
    }

    public function scopeNeedingCheck($query)
    {
        return $query->where('status', 'active')
            ->where(function ($q) {
                $q->whereNull('last_checked_at')
                    ->orWhereRaw('last_checked_at < NOW() - INTERVAL \'1 minute\' * fetch_frequency');
            });
    }

    // Helper methods
    public function isActive(): bool
    {
        return $this->status === 'active';
    }

    public function isHealthy(): bool
    {
        return $this->health_status === 'healthy';
    }

    public function isBroken(): bool
    {
        return $this->status === 'broken';
    }

    public function markAsHealthy(): void
    {
        $this->update([
            'health_status' => 'healthy',
            'last_successful_fetch_at' => now(),
            'last_error' => null,
        ]);
    }

    public function markAsDegraded(?string $error = null): void
    {
        $this->update([
            'health_status' => 'degraded',
            'last_error' => $error,
        ]);
    }

    public function markAsUnhealthy(?string $error = null): void
    {
        $this->update([
            'health_status' => 'unhealthy',
            'last_error' => $error,
        ]);
    }

    public function markAsBroken(?string $error = null): void
    {
        $this->update([
            'status' => 'broken',
            'health_status' => 'unhealthy',
            'last_error' => $error,
        ]);
    }

    public function updateLastChecked(): void
    {
        $this->update([
            'last_checked_at' => now(),
        ]);
    }

    public function incrementItemCount(): void
    {
        $this->increment('total_items_count');
    }

    protected function casts(): array
    {
        return [
            'metadata' => 'array',
            'auto_approved' => 'boolean',
            'last_checked_at' => 'datetime',
            'last_successful_fetch_at' => 'datetime',
            'fetch_frequency' => 'integer',
            'total_items_count' => 'integer',
        ];
    }
}
```

### RssFeedItem
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;

final class RssFeedItem extends Model
{
    /** @use HasFactory<\Database\Factories\RssFeedItemFactory> */
    use HasFactory, HasUuid, SoftDeletes;

    protected $fillable = [
        'rss_feed_id',
        'guid',
        'title',
        'description',
        'content',
        'url',
        'author',
        'published_at',
        'categories',
        'metadata',
        'processed',
        'processed_at',
    ];

    public function rssFeed(): BelongsTo
    {
        return $this->belongsTo(RssFeed::class);
    }

    public function dayNewsPosts(): HasMany
    {
        return $this->hasMany(DayNewsPost::class);
    }

    // Scopes
    public function scopeProcessed($query)
    {
        return $query->where('processed', true);
    }

    public function scopeUnprocessed($query)
    {
        return $query->where('processed', false);
    }

    public function scopeRecent($query, int $days = 7)
    {
        return $query->where('published_at', '>=', now()->subDays($days));
    }

    public function scopeByCategory($query, string $category)
    {
        return $query->whereJsonContains('categories', $category);
    }

    // Helper methods
    public function isProcessed(): bool
    {
        return $this->processed === true;
    }

    public function markAsProcessed(): void
    {
        $this->update([
            'processed' => true,
            'processed_at' => now(),
        ]);
    }

    public function markAsUnprocessed(): void
    {
        $this->update([
            'processed' => false,
            'processed_at' => null,
        ]);
    }

    protected function casts(): array
    {
        return [
            'categories' => 'array',
            'metadata' => 'array',
            'processed' => 'boolean',
            'published_at' => 'datetime',
            'processed_at' => 'datetime',
        ];
    }
}
```

### SMBCrmCustomer
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;

final class SMBCrmCustomer extends Model
{
    use HasFactory, HasUuid, SoftDeletes;

    protected $table = 'smb_crm_customers';

    protected $fillable = [
        'business_id',
        'first_name',
        'last_name',
        'email',
        'phone',
        'source',
        'source_details',
        'status',
        'customer_since',
        'last_interaction_at',
        'health_score',
        'lifetime_value',
        'predicted_churn_risk',
        'ai_notes',
        'preferences',
        'tags',
    ];

    protected function casts(): array
    {
        return [
            'source_details' => 'array',
            'customer_since' => 'date',
            'last_interaction_at' => 'datetime',
            'lifetime_value' => 'decimal:2',
            'predicted_churn_risk' => 'decimal:4',
            'preferences' => 'array',
            'tags' => 'array',
        ];
    }

    public function business(): BelongsTo
    {
        return $this->belongsTo(Business::class);
    }

    public function interactions(): HasMany
    {
        return $this->hasMany(SMBCrmInteraction::class, 'customer_id');
    }

    public function surveyResponses(): HasMany
    {
        return $this->hasMany(BusinessSurveyResponse::class, 'customer_id');
    }
}
```

### SMBCrmInteraction
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class SMBCrmInteraction extends Model
{
    use HasFactory, HasUuid;

    protected $table = 'smb_crm_interactions';

    public $timestamps = false;
    protected $dateFormat = 'U';

    protected $fillable = [
        'business_id',
        'customer_id',
        'interaction_type',
        'channel',
        'direction',
        'subject',
        'content',
        'summary',
        'handled_by',
        'ai_service_used',
        'ai_confidence_score',
        'escalated_reason',
        'outcome',
        'sentiment',
        'duration_seconds',
        'metadata',
        'created_at',
    ];

    protected function casts(): array
    {
        return [
            'created_at' => 'datetime',
            'ai_confidence_score' => 'decimal:4',
            'metadata' => 'array',
        ];
    }

    public function business(): BelongsTo
    {
        return $this->belongsTo(Business::class);
    }

    public function customer(): BelongsTo
    {
        return $this->belongsTo(SMBCrmCustomer::class, 'customer_id');
    }
}
```

### SearchHistory
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class SearchHistory extends Model
{
    use HasFactory;

    protected $table = 'search_history';

    protected $fillable = [
        'user_id',
        'query',
        'results_count',
        'filters',
        'ip_address',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    protected function casts(): array
    {
        return [
            'filters' => 'array',
            'results_count' => 'integer',
        ];
    }
}

```

### SearchSuggestion
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

final class SearchSuggestion extends Model
{
    use HasFactory;

    protected $fillable = [
        'query',
        'popularity',
        'click_count',
    ];

    public function incrementPopularity(): void
    {
        $this->increment('popularity');
    }

    public function incrementClickCount(): void
    {
        $this->increment('click_count');
    }

    protected function casts(): array
    {
        return [
            'popularity' => 'integer',
            'click_count' => 'integer',
        ];
    }
}

```

### SmbBusiness
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;

final class SmbBusiness extends Model
{
    /** @use HasFactory<\Database\Factories\SmbBusinessFactory> */
    use HasFactory, HasUuid, SoftDeletes;

    protected $table = 'smb_businesses';

    protected $fillable = [
        'tenant_id',
        'google_place_id',
        'display_name',
        'latitude',
        'longitude',
        'formatted_address',
        'address_components',
        'plus_code',
        'viewport',
        'location',
        'phone_national',
        'phone_international',
        'website_url',
        'business_status',
        'fibonacco_status',
        'google_rating',
        'google_rating_count',
        'user_rating_total',
        'delivery',
        'dine_in',
        'takeout',
        'reservable',
        'outdoor_seating',
        'serves_breakfast',
        'serves_lunch',
        'serves_dinner',
        'serves_beer',
        'serves_wine',
        'serves_brunch',
        'serves_vegetarian_food',
        'wheelchair_accessible_entrance',
        'place_types',
        'accessibility_options',
        'payment_options',
        'parking_options',
        'data_sources',
        'opening_hours',
        'current_opening_hours',
        'secondary_opening_hours',
        'editorial_summary',
        'photos',
        'reviews',
        'utc_offset',
        'adr_address',
        'formatted_phone_number',
        'international_phone_number',
        'price_level',
        'icon',
        'icon_background_color',
        'icon_mask_base_uri',
        'name',
        'place_id',
        'reference',
        'scope',
        'types',
        'url',
        'vicinity',
        'geometry',
        'permanently_closed',
        'permanently_closed_time',
        'last_google_sync_at',
    ];

    protected function casts(): array
    {
        return [
            'latitude' => 'decimal:8',
            'longitude' => 'decimal:8',
            'google_rating' => 'decimal:1',
            'address_components' => 'array',
            'viewport' => 'array',
            'location' => 'array',
            'place_types' => 'array',
            'accessibility_options' => 'array',
            'payment_options' => 'array',
            'parking_options' => 'array',
            'data_sources' => 'array',
            'opening_hours' => 'array',
            'current_opening_hours' => 'array',
            'secondary_opening_hours' => 'array',
            'editorial_summary' => 'array',
            'photos' => 'array',
            'reviews' => 'array',
            'types' => 'array',
            'geometry' => 'array',
            'delivery' => 'boolean',
            'dine_in' => 'boolean',
            'takeout' => 'boolean',
            'reservable' => 'boolean',
            'outdoor_seating' => 'boolean',
            'serves_breakfast' => 'boolean',
            'serves_lunch' => 'boolean',
            'serves_dinner' => 'boolean',
            'serves_beer' => 'boolean',
            'serves_wine' => 'boolean',
            'serves_brunch' => 'boolean',
            'serves_vegetarian_food' => 'boolean',
            'wheelchair_accessible_entrance' => 'boolean',
            'permanently_closed' => 'boolean',
            'permanently_closed_time' => 'datetime',
            'last_google_sync_at' => 'datetime',
        ];
    }

    public function tenant(): BelongsTo
    {
        return $this->belongsTo(Tenant::class);
    }

    public function customers(): HasMany
    {
        return $this->hasMany(Customer::class, 'smb_business_id');
    }

    public function businessHours(): HasMany
    {
        return $this->hasMany(BusinessHours::class);
    }

    public function photos(): HasMany
    {
        return $this->hasMany(BusinessPhoto::class);
    }

    public function reviews(): HasMany
    {
        return $this->hasMany(BusinessReview::class);
    }

    public function attributes(): HasMany
    {
        return $this->hasMany(BusinessAttribute::class);
    }
}
```

### SocialAccount
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class SocialAccount extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'user_id',
        'provider',
        'provider_id',
        'name',
        'token',
        'refresh_token',
        'avatar',
        'code',
        'expires_at',
    ];

    protected $casts = [
        'expires_at' => 'datetime',
        'token' => 'encrypted',
        'refresh_token' => 'encrypted',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function getAvatarAttribute(): string
    {
        return $this->avatar ?? "https://api.dicebear.com/9.x/glass/svg?seed={$this->user->id}";
    }
}
```

### SocialActivity
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\MorphTo;

final class SocialActivity extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'user_id',
        'actor_id',
        'type',
        'subject_type',
        'subject_id',
        'data',
        'is_read',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function actor(): BelongsTo
    {
        return $this->belongsTo(User::class, 'actor_id');
    }

    public function subject(): MorphTo
    {
        return $this->morphTo();
    }

    public function markAsRead(): void
    {
        $this->update(['is_read' => true]);
    }

    public function scopeUnread($query)
    {
        return $query->where('is_read', false);
    }

    public function scopeOfType($query, string $type)
    {
        return $query->where('type', $type);
    }

    protected function casts(): array
    {
        return [
            'data' => 'array',
            'is_read' => 'boolean',
        ];
    }
}
```

### SocialCommentLike
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class SocialCommentLike extends Model
{
    use HasFactory;

    protected $fillable = [
        'comment_id',
        'user_id',
    ];

    public function comment(): BelongsTo
    {
        return $this->belongsTo(SocialPostComment::class, 'comment_id');
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }
}
```

### SocialFriendship
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class SocialFriendship extends Model
{
    use HasFactory, HasUuids;

    protected $fillable = [
        'user_id',
        'friend_id',
        'status',
        'requested_at',
        'responded_at',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function friend(): BelongsTo
    {
        return $this->belongsTo(User::class, 'friend_id');
    }

    public function requester(): BelongsTo
    {
        return $this->belongsTo(User::class, 'user_id');
    }

    public function recipient(): BelongsTo
    {
        return $this->belongsTo(User::class, 'friend_id');
    }

    public function isPending(): bool
    {
        return $this->status === 'pending';
    }

    public function isAccepted(): bool
    {
        return $this->status === 'accepted';
    }

    public function isBlocked(): bool
    {
        return $this->status === 'blocked';
    }

    protected function casts(): array
    {
        return [
            'requested_at' => 'datetime',
            'responded_at' => 'datetime',
        ];
    }
}
```

### SocialGroup
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class SocialGroup extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'name',
        'description',
        'cover_image',
        'creator_id',
        'privacy',
        'is_active',
        'settings',
    ];

    public function creator(): BelongsTo
    {
        return $this->belongsTo(User::class, 'creator_id');
    }

    public function members(): HasMany
    {
        return $this->hasMany(SocialGroupMember::class, 'group_id');
    }

    public function posts(): HasMany
    {
        return $this->hasMany(SocialGroupPost::class, 'group_id');
    }

    public function invitations(): HasMany
    {
        return $this->hasMany(SocialGroupInvitation::class, 'group_id');
    }

    public function approvedMembers(): HasMany
    {
        return $this->members()->where('status', 'approved');
    }

    public function admins(): HasMany
    {
        return $this->members()->where('role', 'admin')->where('status', 'approved');
    }

    public function membersCount(): int
    {
        return $this->approvedMembers()->count();
    }

    public function isPublic(): bool
    {
        return $this->privacy === 'public';
    }

    public function isPrivate(): bool
    {
        return $this->privacy === 'private';
    }

    public function isSecret(): bool
    {
        return $this->privacy === 'secret';
    }

    protected function casts(): array
    {
        return [
            'is_active' => 'boolean',
            'settings' => 'array',
        ];
    }
}
```

### SocialGroupInvitation
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class SocialGroupInvitation extends Model
{
    use HasFactory;

    protected $fillable = [
        'group_id',
        'inviter_id',
        'invited_id',
        'message',
        'status',
        'expires_at',
    ];

    public function group(): BelongsTo
    {
        return $this->belongsTo(SocialGroup::class, 'group_id');
    }

    public function inviter(): BelongsTo
    {
        return $this->belongsTo(User::class, 'inviter_id');
    }

    public function invited(): BelongsTo
    {
        return $this->belongsTo(User::class, 'invited_id');
    }

    public function isPending(): bool
    {
        return $this->status === 'pending';
    }

    public function isAccepted(): bool
    {
        return $this->status === 'accepted';
    }

    public function isDeclined(): bool
    {
        return $this->status === 'declined';
    }

    public function isExpired(): bool
    {
        return $this->expires_at && $this->expires_at < now();
    }

    public function scopePending($query)
    {
        return $query->where('status', 'pending');
    }

    public function scopeNotExpired($query)
    {
        return $query->where(function ($q) {
            $q->whereNull('expires_at')
                ->orWhere('expires_at', '>=', now());
        });
    }

    protected function casts(): array
    {
        return [
            'expires_at' => 'datetime',
        ];
    }
}
```

### SocialGroupMember
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class SocialGroupMember extends Model
{
    use HasFactory;

    protected $fillable = [
        'group_id',
        'user_id',
        'role',
        'status',
        'joined_at',
    ];

    public function group(): BelongsTo
    {
        return $this->belongsTo(SocialGroup::class, 'group_id');
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function isAdmin(): bool
    {
        return $this->role === 'admin';
    }

    public function isModerator(): bool
    {
        return $this->role === 'moderator';
    }

    public function isMember(): bool
    {
        return $this->role === 'member';
    }

    public function isPending(): bool
    {
        return $this->status === 'pending';
    }

    public function isApproved(): bool
    {
        return $this->status === 'approved';
    }

    public function isBanned(): bool
    {
        return $this->status === 'banned';
    }

    protected function casts(): array
    {
        return [
            'joined_at' => 'datetime',
        ];
    }
}
```

### SocialGroupPost
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\MorphMany;

final class SocialGroupPost extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'group_id',
        'user_id',
        'content',
        'media',
        'is_pinned',
        'is_active',
    ];

    public function group(): BelongsTo
    {
        return $this->belongsTo(SocialGroup::class, 'group_id');
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function activities(): MorphMany
    {
        return $this->morphMany(SocialActivity::class, 'subject');
    }

    protected function casts(): array
    {
        return [
            'media' => 'array',
            'is_pinned' => 'boolean',
            'is_active' => 'boolean',
        ];
    }
}
```

### SocialPost
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\MorphMany;

final class SocialPost extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'user_id',
        'content',
        'media',
        'visibility',
        'location',
        'is_active',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function likes(): HasMany
    {
        return $this->hasMany(SocialPostLike::class, 'post_id');
    }

    public function comments(): HasMany
    {
        return $this->hasMany(SocialPostComment::class, 'post_id');
    }

    public function shares(): HasMany
    {
        return $this->hasMany(SocialPostShare::class, 'post_id');
    }

    public function activities(): MorphMany
    {
        return $this->morphMany(SocialActivity::class, 'subject');
    }

    public function isLikedBy(User $user): bool
    {
        return $this->likes()->where('user_id', $user->id)->exists();
    }

    public function likesCount(): int
    {
        return $this->likes()->count();
    }

    public function commentsCount(): int
    {
        return $this->comments()->where('is_active', true)->count();
    }

    public function sharesCount(): int
    {
        return $this->shares()->count();
    }

    protected function casts(): array
    {
        return [
            'media' => 'array',
            'location' => 'array',
            'is_active' => 'boolean',
        ];
    }
}
```

### SocialPostComment
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\MorphMany;

final class SocialPostComment extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'post_id',
        'user_id',
        'parent_id',
        'content',
        'is_active',
    ];

    public function post(): BelongsTo
    {
        return $this->belongsTo(SocialPost::class, 'post_id');
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function parent(): BelongsTo
    {
        return $this->belongsTo(self::class, 'parent_id');
    }

    public function replies(): HasMany
    {
        return $this->hasMany(self::class, 'parent_id');
    }

    public function likes(): HasMany
    {
        return $this->hasMany(SocialCommentLike::class, 'comment_id');
    }

    public function activities(): MorphMany
    {
        return $this->morphMany(SocialActivity::class, 'subject');
    }

    public function isLikedBy(User $user): bool
    {
        return $this->likes()->where('user_id', $user->id)->exists();
    }

    public function likesCount(): int
    {
        return $this->likes()->count();
    }

    public function repliesCount(): int
    {
        return $this->replies()->where('is_active', true)->count();
    }

    protected function casts(): array
    {
        return [
            'is_active' => 'boolean',
        ];
    }
}
```

### SocialPostLike
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class SocialPostLike extends Model
{
    use HasFactory;

    protected $fillable = [
        'post_id',
        'user_id',
    ];

    public function post(): BelongsTo
    {
        return $this->belongsTo(SocialPost::class, 'post_id');
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }
}
```

### SocialPostShare
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class SocialPostShare extends Model
{
    use HasFactory;

    protected $fillable = [
        'post_id',
        'user_id',
        'message',
    ];

    public function post(): BelongsTo
    {
        return $this->belongsTo(SocialPost::class, 'post_id');
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }
}
```

### SocialUserFollow
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class SocialUserFollow extends Model
{
    use HasFactory;

    protected $fillable = [
        'follower_id',
        'following_id',
    ];

    public function follower(): BelongsTo
    {
        return $this->belongsTo(User::class, 'follower_id');
    }

    public function following(): BelongsTo
    {
        return $this->belongsTo(User::class, 'following_id');
    }
}
```

### SocialUserProfile
```php
<?php

declare(strict_types=1);

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class SocialUserProfile extends Model
{
    use HasFactory;

    protected $fillable = [
        'user_id',
        'bio',
        'website',
        'location',
        'birth_date',
        'profile_visibility',
        'interests',
        'cover_photo',
        'social_links',
        'show_email',
        'show_location',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function isPublic(): bool
    {
        return $this->profile_visibility === 'public';
    }

    public function isFriendsOnly(): bool
    {
        return $this->profile_visibility === 'friends';
    }

    public function isPrivate(): bool
    {
        return $this->profile_visibility === 'private';
    }

    protected function casts(): array
    {
        return [
            'birth_date' => 'date',
            'interests' => 'array',
            'social_links' => 'array',
            'show_email' => 'boolean',
            'show_location' => 'boolean',
        ];
    }
}
```

### Store
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;

final class Store extends Model
{
    use HasFactory, HasUuid, SoftDeletes;

    protected $fillable = [
        'workspace_id',
        'name',
        'slug',
        'description',
        'logo',
        'banner',
        'status',
        'rejection_reason',
        'approved_at',
    ];

    /**
     * Get the route key for the model.
     */
    public function getRouteKeyName(): string
    {
        return 'slug';
    }

    public function workspace(): BelongsTo
    {
        return $this->belongsTo(Workspace::class);
    }

    public function products(): HasMany
    {
        return $this->hasMany(Product::class);
    }

    public function orders(): HasMany
    {
        return $this->hasMany(Order::class);
    }

    public function isApproved(): bool
    {
        return $this->status === 'approved';
    }

    public function isPending(): bool
    {
        return $this->status === 'pending';
    }

    public function isRejected(): bool
    {
        return $this->status === 'rejected';
    }

    public function isSuspended(): bool
    {
        return $this->status === 'suspended';
    }

    public function canAcceptPayments(): bool
    {
        return $this->isApproved() && $this->workspace->canAcceptPayments();
    }

    protected function casts(): array
    {
        return [
            'approved_at' => 'datetime',
        ];
    }
}
```

### Tag
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\MorphMany;
use Illuminate\Support\Str;

final class Tag extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'name',
        'slug',
        'description',
        'article_count',
        'followers_count',
        'is_trending',
        'trending_score',
    ];

    public function posts(): BelongsToMany
    {
        return $this->belongsToMany(DayNewsPost::class, 'day_news_post_tag')
            ->withTimestamps();
    }

    public function followers(): MorphMany
    {
        return $this->morphMany(Follow::class, 'followable');
    }

    // Scopes
    public function scopeTrending($query)
    {
        return $query->where('is_trending', true)
            ->orderBy('trending_score', 'desc');
    }

    public function scopePopular($query)
    {
        return $query->orderBy('article_count', 'desc');
    }

    protected static function booted(): void
    {
        self::creating(function (Tag $tag): void {
            if (empty($tag->slug)) {
                $tag->slug = static::generateUniqueSlug($tag->name);
            }
        });
    }

    protected static function generateUniqueSlug(string $name): string
    {
        $slug = Str::slug($name);
        $originalSlug = $slug;
        $count = 1;

        while (self::where('slug', $slug)->exists()) {
            $slug = $originalSlug.'-'.$count;
            $count++;
        }

        return $slug;
    }

    protected function casts(): array
    {
        return [
            'is_trending' => 'boolean',
            'article_count' => 'integer',
            'followers_count' => 'integer',
            'trending_score' => 'integer',
        ];
    }
}

```

### Task
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class Task extends Model
{
    /** @use HasFactory<\Database\Factories\TaskFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'tenant_id',
        'customer_id',
        'assigned_to_id',
        'title',
        'description',
        'type',
        'priority',
        'status',
        'due_date',
        'completed_at',
        'metadata',
    ];

    protected function casts(): array
    {
        return [
            'due_date' => 'date',
            'completed_at' => 'datetime',
            'metadata' => 'array',
        ];
    }

    public function tenant(): BelongsTo
    {
        return $this->belongsTo(Tenant::class);
    }

    public function customer(): BelongsTo
    {
        return $this->belongsTo(Customer::class);
    }

    public function assignedTo(): BelongsTo
    {
        return $this->belongsTo(User::class, 'assigned_to_id');
    }

    public function isCompleted(): bool
    {
        return $this->status === 'completed';
    }

    public function isOverdue(): bool
    {
        return $this->due_date && $this->due_date->isPast() && !$this->isCompleted();
    }
}
```

### Tenant
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;

final class Tenant extends Model
{
    /** @use HasFactory<\Database\Factories\TenantFactory> */
    use HasFactory, HasUuid, SoftDeletes;

    protected $fillable = [
        'name',
        'subdomain',
        'domain',
        'email',
        'phone',
        'address',
        'city',
        'state',
        'postal_code',
        'country',
        'timezone',
        'locale',
        'currency',
        'is_active',
        'trial_ends_at',
        'settings',
        'metadata',
    ];

    protected function casts(): array
    {
        return [
            'is_active' => 'boolean',
            'trial_ends_at' => 'datetime',
            'settings' => 'array',
            'metadata' => 'array',
        ];
    }

    public function users(): HasMany
    {
        return $this->hasMany(User::class);
    }

    public function smbBusinesses(): HasMany
    {
        return $this->hasMany(SmbBusiness::class);
    }

    public function customers(): HasMany
    {
        return $this->hasMany(Customer::class);
    }

    public function accountManagers(): HasMany
    {
        return $this->hasMany(AccountManager::class);
    }

    public function deals(): HasMany
    {
        return $this->hasMany(Deal::class);
    }

    public function interactions(): HasMany
    {
        return $this->hasMany(Interaction::class);
    }

    public function tasks(): HasMany
    {
        return $this->hasMany(Task::class);
    }

    public function campaigns(): HasMany
    {
        return $this->hasMany(Campaign::class);
    }

    public function isOnTrial(): bool
    {
        return $this->trial_ends_at && $this->trial_ends_at->isFuture();
    }
}
```

### TicketGift
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class TicketGift extends Model
{
    /** @use HasFactory<\Database\Factories\TicketGiftFactory> */
    use HasFactory, HasUuid;

    public const STATUS_PENDING = 'pending';
    public const STATUS_REDEEMED = 'redeemed';
    public const STATUS_CANCELLED = 'cancelled';
    public const STATUS_EXPIRED = 'expired';

    public const STATUSES = [
        self::STATUS_PENDING,
        self::STATUS_REDEEMED,
        self::STATUS_CANCELLED,
        self::STATUS_EXPIRED,
    ];

    protected $fillable = [
        'ticket_order_item_id',
        'gifter_id',
        'recipient_email',
        'recipient_name',
        'recipient_user_id',
        'status',
        'gift_token',
        'message',
        'gifted_at',
        'redeemed_at',
        'expires_at',
    ];

    protected function casts(): array
    {
        return [
            'gifted_at' => 'datetime',
            'redeemed_at' => 'datetime',
            'expires_at' => 'datetime',
        ];
    }

    public function ticketOrderItem(): BelongsTo
    {
        return $this->belongsTo(TicketOrderItem::class);
    }

    public function gifter(): BelongsTo
    {
        return $this->belongsTo(User::class, 'gifter_id');
    }

    public function recipient(): BelongsTo
    {
        return $this->belongsTo(User::class, 'recipient_user_id');
    }

    public function scopePending($query)
    {
        return $query->where('status', self::STATUS_PENDING)
            ->where(function ($q) {
                $q->whereNull('expires_at')
                    ->orWhere('expires_at', '>', now());
            });
    }

    public function scopeForGifter($query, string $userId)
    {
        return $query->where('gifter_id', $userId);
    }

    public function scopeForRecipient($query, string $email)
    {
        return $query->where('recipient_email', $email);
    }

    public function redeem(string $userId): void
    {
        $this->update([
            'status' => self::STATUS_REDEEMED,
            'recipient_user_id' => $userId,
            'redeemed_at' => now(),
        ]);
    }
}

```

### TicketListing
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class TicketListing extends Model
{
    /** @use HasFactory<\Database\Factories\TicketListingFactory> */
    use HasFactory, HasUuid;

    public const STATUS_ACTIVE = 'active';
    public const STATUS_SOLD = 'sold';
    public const STATUS_CANCELLED = 'cancelled';
    public const STATUS_EXPIRED = 'expired';

    public const STATUSES = [
        self::STATUS_ACTIVE,
        self::STATUS_SOLD,
        self::STATUS_CANCELLED,
        self::STATUS_EXPIRED,
    ];

    protected $fillable = [
        'ticket_order_item_id',
        'seller_id',
        'event_id',
        'price',
        'quantity',
        'status',
        'description',
        'expires_at',
        'sold_at',
        'sold_to',
    ];

    protected function casts(): array
    {
        return [
            'price' => 'decimal:2',
            'quantity' => 'integer',
            'expires_at' => 'datetime',
            'sold_at' => 'datetime',
        ];
    }

    public function ticketOrderItem(): BelongsTo
    {
        return $this->belongsTo(TicketOrderItem::class);
    }

    public function seller(): BelongsTo
    {
        return $this->belongsTo(User::class, 'seller_id');
    }

    public function buyer(): BelongsTo
    {
        return $this->belongsTo(User::class, 'sold_to');
    }

    public function event(): BelongsTo
    {
        return $this->belongsTo(Event::class);
    }

    public function scopeActive($query)
    {
        return $query->where('status', self::STATUS_ACTIVE)
            ->where(function ($q) {
                $q->whereNull('expires_at')
                    ->orWhere('expires_at', '>', now());
            });
    }

    public function scopeForEvent($query, string $eventId)
    {
        return $query->where('event_id', $eventId);
    }

    public function markAsSold(string $buyerId): void
    {
        $this->update([
            'status' => self::STATUS_SOLD,
            'sold_at' => now(),
            'sold_to' => $buyerId,
        ]);
    }
}

```

### TicketOrder
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class TicketOrder extends Model
{
    /** @use HasFactory<\Database\Factories\TicketOrderFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'event_id',
        'user_id',
        'status',
        'subtotal',
        'fees',
        'discount',
        'total',
        'promo_code',
        'billing_info',
        'payment_intent_id',
        'payment_status',
        'completed_at',
    ];

    public function event(): BelongsTo
    {
        return $this->belongsTo(Event::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function items(): HasMany
    {
        return $this->hasMany(TicketOrderItem::class);
    }

    public function scopePending($query)
    {
        return $query->where('status', 'pending');
    }

    public function scopeCompleted($query)
    {
        return $query->where('status', 'completed');
    }

    public function scopeForUser($query, string $userId)
    {
        return $query->where('user_id', $userId);
    }

    public function scopeForEvent($query, string $eventId)
    {
        return $query->where('event_id', $eventId);
    }

    public function getIsFreeOrderAttribute(): bool
    {
        return $this->total === 0;
    }

    public function getFormattedTotalAttribute(): string
    {
        return '$'.number_format($this->total, 2);
    }

    public function getTotalQuantityAttribute(): int
    {
        return $this->items->sum('quantity');
    }

    protected function casts(): array
    {
        return [
            'subtotal' => 'decimal:2',
            'fees' => 'decimal:2',
            'discount' => 'decimal:2',
            'total' => 'decimal:2',
            'promo_code' => 'array',
            'billing_info' => 'array',
            'completed_at' => 'datetime',
        ];
    }
}
```

### TicketOrderItem
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class TicketOrderItem extends Model
{
    /** @use HasFactory<\Database\Factories\TicketOrderItemFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'ticket_order_id',
        'ticket_plan_id',
        'quantity',
        'unit_price',
        'total_price',
        'ticket_code',
        'qr_code',
    ];

    public function ticketOrder(): BelongsTo
    {
        return $this->belongsTo(TicketOrder::class);
    }

    public function ticketPlan(): BelongsTo
    {
        return $this->belongsTo(TicketPlan::class);
    }

    protected function casts(): array
    {
        return [
            'unit_price' => 'decimal:2',
            'total_price' => 'decimal:2',
        ];
    }
}
```

### TicketPlan
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class TicketPlan extends Model
{
    /** @use HasFactory<\Database\Factories\TicketPlanFactory> */
    use HasFactory, HasUuid, \App\Traits\RelatableToOrganizations;

    protected $fillable = [
        'event_id',
        'name',
        'description',
        'price',
        'max_quantity',
        'available_quantity',
        'is_active',
        'metadata',
        'sort_order',
    ];

    public function event(): BelongsTo
    {
        return $this->belongsTo(Event::class);
    }

    public function orderItems(): HasMany
    {
        return $this->hasMany(TicketOrderItem::class);
    }

    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    public function scopeAvailable($query)
    {
        return $query->where('available_quantity', '>', 0);
    }

    public function scopeForEvent($query, string $eventId)
    {
        return $query->where('event_id', $eventId);
    }

    public function scopeOrderBySortOrder($query)
    {
        return $query->orderBy('sort_order')->orderBy('price');
    }

    public function getIsFreeAttribute(): bool
    {
        return (float) $this->price === 0.0;
    }

    public function getFormattedPriceAttribute(): string
    {
        return $this->is_free ? 'Free' : '$'.number_format((float) $this->price, 2);
    }

    protected function casts(): array
    {
        return [
            'price' => 'decimal:2',
            'is_active' => 'boolean',
            'metadata' => 'array',
        ];
    }
}
```

### TicketTransfer
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class TicketTransfer extends Model
{
    /** @use HasFactory<\Database\Factories\TicketTransferFactory> */
    use HasFactory, HasUuid;

    public const STATUS_PENDING = 'pending';
    public const STATUS_COMPLETED = 'completed';
    public const STATUS_CANCELLED = 'cancelled';
    public const STATUS_EXPIRED = 'expired';

    public const STATUSES = [
        self::STATUS_PENDING,
        self::STATUS_COMPLETED,
        self::STATUS_CANCELLED,
        self::STATUS_EXPIRED,
    ];

    protected $fillable = [
        'ticket_order_item_id',
        'from_user_id',
        'to_user_id',
        'to_email',
        'status',
        'transfer_token',
        'message',
        'transferred_at',
        'expires_at',
    ];

    protected function casts(): array
    {
        return [
            'transferred_at' => 'datetime',
            'expires_at' => 'datetime',
        ];
    }

    public function ticketOrderItem(): BelongsTo
    {
        return $this->belongsTo(TicketOrderItem::class);
    }

    public function fromUser(): BelongsTo
    {
        return $this->belongsTo(User::class, 'from_user_id');
    }

    public function toUser(): BelongsTo
    {
        return $this->belongsTo(User::class, 'to_user_id');
    }

    public function scopePending($query)
    {
        return $query->where('status', self::STATUS_PENDING)
            ->where(function ($q) {
                $q->whereNull('expires_at')
                    ->orWhere('expires_at', '>', now());
            });
    }

    public function scopeForUser($query, string $userId)
    {
        return $query->where(function ($q) use ($userId) {
            $q->where('from_user_id', $userId)
                ->orWhere('to_user_id', $userId);
        });
    }

    public function complete(): void
    {
        $this->update([
            'status' => self::STATUS_COMPLETED,
            'transferred_at' => now(),
        ]);
    }
}

```

### UpcomingShow
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

final class UpcomingShow extends Model
{
    /** @use HasFactory<\Database\Factories\UpcomingShowFactory> */
    use HasFactory, HasUuid;

    protected $fillable = [
        'performer_id',
        'date',
        'venue',
        'tickets_available',
        'ticket_url',
        'ticket_price',
        'description',
    ];

    public function performer(): BelongsTo
    {
        return $this->belongsTo(Performer::class);
    }

    // Scopes
    public function scopeUpcoming($query)
    {
        return $query->where('date', '>=', now()->toDateString());
    }

    public function scopeWithTickets($query)
    {
        return $query->where('tickets_available', true);
    }

    protected function casts(): array
    {
        return [
            'date' => 'date',
            'tickets_available' => 'boolean',
            'ticket_price' => 'decimal:2',
        ];
    }
}
```

### User
```php
<?php

declare(strict_types=1);

namespace App\Models;

// use Illuminate\Contracts\Auth\MustVerifyEmail;

use App\Concerns\HasUuid;
use Filament\Models\Contracts\FilamentUser;
use Filament\Panel;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;

final class User extends Authenticatable implements FilamentUser
{
    /** @use HasFactory<\Database\Factories\UserFactory> */
    use HasFactory, HasUuid, Notifiable;

    /**
     * The attributes that are mass assignable.
     *
     * @var list<string>
     */
    protected $fillable = [
        'name',
        'email',
        'password',
        'current_workspace_id',
        'tenant_id',
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var list<string>
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    protected $appends = [
        'avatar',
    ];

    public function socialAccounts(): HasMany
    {
        return $this->hasMany(SocialAccount::class);
    }

    public function getAvatarAttribute(): string
    {
        return $this->socialAccounts()->first()?->avatar ?? "https://api.dicebear.com/9.x/fun-emoji/svg?seed={$this->id}&flip=true&backgroundType=solid,gradientLinear&eyes=closed,cute,glasses,love,pissed,plain,sad,shades,sleepClose,tearDrop,wink,wink2,closed2&mouth=cute,kissHeart,lilSmile,plain,shy,smileLol,smileTeeth,tongueOut,wideSmile";
    }

    public function workspaces(): HasMany
    {
        return $this->hasMany(WorkspaceMembership::class);
    }

    public function currentWorkspace(): BelongsTo
    {
        return $this->belongsTo(Workspace::class, 'current_workspace_id');
    }

    public function tenant(): BelongsTo
    {
        return $this->belongsTo(Tenant::class);
    }

    public function workspaceMemberships(): HasMany
    {
        return $this->hasMany(WorkspaceMembership::class);
    }

    /**
     * Check if user is a member of the given workspace
     */
    public function isMemberOfWorkspace(?string $workspaceId): bool
    {
        if (! $workspaceId) {
            return false;
        }

        return $this->workspaceMemberships()
            ->where('workspace_id', $workspaceId)
            ->exists();
    }

    /**
     * Get user's membership for a specific workspace
     */
    public function getMembershipForWorkspace(string $workspaceId): ?WorkspaceMembership
    {
        return $this->workspaceMemberships()
            ->where('workspace_id', $workspaceId)
            ->first();
    }

    /**
     * Check if user can manage resources in a workspace (owner or admin)
     */
    public function hasSomePermissions(array $permissions, ?string $workspaceId): bool
    {
        if (! $workspaceId) {
            return false;
        }

        return $this->workspaceMemberships()
            ->where('workspace_id', $workspaceId)
            ->get()
            ->some(fn ($membership) => collect($permissions)->some(fn ($permission) => in_array($permission, $membership->permissions)));
    }

    public function hasAllPermissions(array $permissions, ?string $workspaceId): bool
    {
        if (! $workspaceId) {
            return false;
        }

        return $this->workspaceMemberships()
            ->where('workspace_id', $workspaceId)
            ->get()
            ->every(fn ($membership) => collect($permissions)->every(fn ($permission) => in_array($permission, $membership->permissions)));
    }

    public function isOwnerOfWorkspace(?string $workspaceId): bool
    {
        if (! $workspaceId) {
            return false;
        }

        return $this->workspaceMemberships()
            ->where('workspace_id', $workspaceId)
            ->where('role', 'owner')
            ->exists();
    }

    // Social relationships
    public function socialPosts(): HasMany
    {
        return $this->hasMany(SocialPost::class);
    }

    public function authoredDayNewsPosts(): HasMany
    {
        return $this->hasMany(DayNewsPost::class, 'author_id');
    }

    public function socialProfile(): HasOne
    {
        return $this->hasOne(SocialUserProfile::class);
    }

    public function friendships(): HasMany
    {
        return $this->hasMany(SocialFriendship::class);
    }

    public function friendshipRequests(): HasMany
    {
        return $this->hasMany(SocialFriendship::class, 'friend_id');
    }

    public function followers(): HasMany
    {
        return $this->hasMany(SocialUserFollow::class, 'following_id');
    }

    public function following(): HasMany
    {
        return $this->hasMany(SocialUserFollow::class, 'follower_id');
    }

    public function socialGroups(): HasMany
    {
        return $this->hasMany(SocialGroup::class, 'creator_id');
    }

    public function groupMemberships(): HasMany
    {
        return $this->hasMany(SocialGroupMember::class);
    }

    public function groupInvitations(): HasMany
    {
        return $this->hasMany(SocialGroupInvitation::class, 'invited_id');
    }

    public function sentGroupInvitations(): HasMany
    {
        return $this->hasMany(SocialGroupInvitation::class, 'inviter_id');
    }

    public function socialActivities(): HasMany
    {
        return $this->hasMany(SocialActivity::class);
    }

    public function actorActivities(): HasMany
    {
        return $this->hasMany(SocialActivity::class, 'actor_id');
    }

    // Social helper methods
    public function isFriendsWith(self $user): bool
    {
        return $this->friendships()
            ->where('friend_id', $user->id)
            ->where('status', 'accepted')
            ->exists() ||
            $this->friendshipRequests()
                ->where('user_id', $user->id)
                ->where('status', 'accepted')
                ->exists();
    }

    public function hasPendingFriendRequestWith(self $user): bool
    {
        return $this->friendships()
            ->where('friend_id', $user->id)
            ->where('status', 'pending')
            ->exists() ||
            $this->friendshipRequests()
                ->where('user_id', $user->id)
                ->where('status', 'pending')
                ->exists();
    }

    public function isFollowing(self $user): bool
    {
        return $this->following()->where('following_id', $user->id)->exists();
    }

    public function isMemberOfGroup(SocialGroup $group): bool
    {
        return $this->groupMemberships()
            ->where('group_id', $group->id)
            ->where('status', 'approved')
            ->exists();
    }

    public function unreadActivitiesCount(): int
    {
        return $this->socialActivities()->unread()->count();
    }

    /**
     * Determine if the user can access the Filament admin panel
     */
    public function canAccessPanel(Panel $panel): bool
    {
        // Only check for admin panel
        if ($panel->getId() !== 'admin') {
            return true;
        }

        $adminEmails = $this->getAdminEmails();

        return in_array($this->email, $adminEmails, true);
    }

    public function acceptedFriends(): HasMany
    {
        return $this->hasMany(SocialFriendship::class)
            ->where('status', 'accepted');
    }

    public function blockedUsers(): HasMany
    {
        return $this->hasMany(SocialFriendship::class)
            ->where('status', 'blocked');
    }

    // Messaging relationships
    public function conversations(): BelongsToMany
    {
        return $this->belongsToMany(Conversation::class, 'conversation_participants')
            ->using(ConversationParticipant::class)
            ->withPivot(['id', 'joined_at', 'last_read_at', 'is_admin'])
            ->withTimestamps();
    }

    public function sentMessages(): HasMany
    {
        return $this->hasMany(Message::class, 'sender_id');
    }

    public function conversationParticipants(): HasMany
    {
        return $this->hasMany(ConversationParticipant::class);
    }

    public function follows(): HasMany
    {
        return $this->hasMany(Follow::class);
    }

    public function ticketOrders(): HasMany
    {
        return $this->hasMany(TicketOrder::class);
    }

    public function checkIns(): HasMany
    {
        return $this->hasMany(CheckIn::class);
    }

    public function plannedEvents(): HasMany
    {
        return $this->hasMany(PlannedEvent::class);
    }

    public function hubMemberships(): HasMany
    {
        return $this->hasMany(HubMember::class);
    }

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'email_verified_at' => 'datetime',
            'password' => 'hashed',
            'is_private_profile' => 'boolean',
            'allow_friend_requests' => 'boolean',
            'allow_group_invites' => 'boolean',
            'last_active_at' => 'datetime',
        ];
    }

    /**
     * Get the list of admin emails from configuration
     *
     * @return array<int, string>
     */
    private function getAdminEmails(): array
    {
        $emails = config('app.admin_emails', '');

        if (empty($emails)) {
            return [];
        }

        return array_map(
            fn (string $email) => mb_trim($email),
            explode(',', $emails)
        );
    }
}
```

### Venue
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use App\Traits\HasReviewsAndRatings;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\MorphMany;

final class Venue extends Model
{
    /** @use HasFactory<\Database\Factories\VenueFactory> */
    use HasFactory, HasReviewsAndRatings, HasUuid;

    protected $fillable = [
        'name',
        'description',
        'images',
        'verified',
        'venue_type',
        'capacity',
        'price_per_hour',
        'price_per_event',
        'price_per_day',
        'rating',
        'review_count',
        'address',
        'neighborhood',
        'latitude',
        'longitude',
        'google_place_id',
        'postal_code',
        'amenities',
        'event_types',
        'unavailable_dates',
        'last_booked_days_ago',
        'response_time_hours',
        'listed_date',
        'status',
        'workspace_id',
        'created_by',
        'average_rating',
        'total_reviews',
    ];

    public function workspace(): BelongsTo
    {
        return $this->belongsTo(Workspace::class);
    }

    public function createdBy(): BelongsTo
    {
        return $this->belongsTo(User::class, 'created_by');
    }

    public function events(): HasMany
    {
        return $this->hasMany(Event::class);
    }

    public function bookings(): HasMany
    {
        return $this->hasMany(Booking::class);
    }

    public function follows(): MorphMany
    {
        return $this->morphMany(Follow::class, 'followable');
    }

    // Computed attributes for frontend compatibility
    public function getLocationAttribute(): array
    {
        return [
            'address' => $this->address,
            'neighborhood' => $this->neighborhood,
            'coordinates' => [
                'lat' => $this->latitude,
                'lng' => $this->longitude,
            ],
        ];
    }

    public function getPricingAttribute(): array
    {
        return [
            'pricePerHour' => $this->price_per_hour,
            'pricePerEvent' => $this->price_per_event,
            'pricePerDay' => $this->price_per_day,
        ];
    }

    public function getDistanceAttribute(): float
    {
        // This would be calculated based on user's location
        // For now, return a default value
        return 0.0;
    }

    // Scopes
    public function scopeActive($query)
    {
        return $query->where('status', 'active');
    }

    public function scopeVerified($query)
    {
        return $query->where('verified', true);
    }

    public function scopeByType($query, string $type)
    {
        return $query->where('venue_type', $type);
    }

    public function scopeWithinRadius($query, float $lat, float $lng, float $radius)
    {
        // Haversine formula for distance calculation
        return $query->selectRaw('
            *,
            (6371 * acos(cos(radians(?))
            * cos(radians(latitude))
            * cos(radians(longitude) - radians(?))
            + sin(radians(?))
            * sin(radians(latitude)))) AS distance
        ', [$lat, $lng, $lat])
            ->whereRaw('
            (6371 * acos(cos(radians(?))
            * cos(radians(latitude))
            * cos(radians(longitude) - radians(?))
            + sin(radians(?))
            * sin(radians(latitude)))) < ?
        ', [$lat, $lng, $lat, $radius]);
    }

    protected function casts(): array
    {
        return [
            'images' => 'array',
            'verified' => 'boolean',
            'price_per_hour' => 'decimal:2',
            'price_per_event' => 'decimal:2',
            'price_per_day' => 'decimal:2',
            'average_rating' => 'decimal:2',
            'latitude' => 'decimal:8',
            'longitude' => 'decimal:8',
            'amenities' => 'array',
            'event_types' => 'array',
            'unavailable_dates' => 'array',
            'listed_date' => 'date',
        ];
    }
}
```

### Workspace
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Climactic\Credits\Traits\HasCredits;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

final class Workspace extends Model
{
    use HasCredits, HasFactory, HasUuid;

    protected $fillable = [
        'name',
        'slug',
        'logo',
        'owner_id',
        'stripe_connect_id',
        'stripe_charges_enabled',
        'stripe_payouts_enabled',
        'stripe_admin_approved',
    ];

    public function getLogoAttribute($value)
    {
        return "https://api.dicebear.com/9.x/glass/svg?seed={$this->id}";
    }

    public function owner(): BelongsTo
    {
        return $this->belongsTo(User::class, 'owner_id');
    }

    public function members(): HasMany
    {
        return $this->hasMany(WorkspaceMembership::class);
    }

    public function invitations(): HasMany
    {
        return $this->hasMany(WorkspaceInvitation::class);
    }

    public function stores(): HasMany
    {
        return $this->hasMany(Store::class);
    }

    public function dayNewsPosts(): HasMany
    {
        return $this->hasMany(DayNewsPost::class);
    }

    public function canAcceptPayments(): bool
    {
        return $this->stripe_charges_enabled
            && $this->stripe_payouts_enabled
            && $this->stripe_connect_id
            && $this->stripe_admin_approved;
    }

    protected function casts(): array
    {
        return [
            'stripe_charges_enabled' => 'boolean',
            'stripe_payouts_enabled' => 'boolean',
            'stripe_admin_approved' => 'boolean',
        ];
    }
}
```

### WorkspaceInvitation
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Support\Str;
use RuntimeException;

final class WorkspaceInvitation extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'workspace_id',
        'invited_by',
        'email',
        'role',
        'token',
        'expires_at',
        'accepted_at',
    ];

    protected $casts = [
        'expires_at' => 'datetime',
        'accepted_at' => 'datetime',
    ];

    /**
     * Generate a unique invitation token
     */
    public static function generateToken(): string
    {
        $maxAttempts = 5;
        $attempts = 0;

        while ($attempts < $maxAttempts) {
            $token = Str::random(64);
            if (! self::where('token', $token)->exists()) {
                return $token;
            }
            $attempts++;
        }

        throw new RuntimeException('Unable to generate unique token after '.$maxAttempts.' attempts');
    }

    public function workspace(): BelongsTo
    {
        return $this->belongsTo(Workspace::class);
    }

    public function inviter(): BelongsTo
    {
        return $this->belongsTo(User::class, 'invited_by');
    }

    /**
     * Check if the invitation is expired
     */
    public function isExpired(): bool
    {
        return $this->expires_at && $this->expires_at->isPast();
    }

    /**
     * Check if the invitation has been accepted
     */
    public function isAccepted(): bool
    {
        return $this->accepted_at !== null;
    }

    /**
     * Check if the invitation is valid (not expired and not accepted)
     */
    public function isValid(): bool
    {
        return ! $this->isExpired() && ! $this->isAccepted();
    }

    /**
     * Mark the invitation as accepted
     */
    public function markAsAccepted(): void
    {
        $this->update(['accepted_at' => now()]);
    }

    /**
     * Scope for pending invitations
     */
    public function scopePending($query)
    {
        return $query->whereNull('accepted_at')
            ->where('expires_at', '>', now());
    }

    /**
     * Scope for expired invitations
     */
    public function scopeExpired($query)
    {
        return $query->whereNull('accepted_at')
            ->where('expires_at', '<=', now());
    }
}
```

### WorkspaceMembership
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

final class WorkspaceMembership extends Model
{
    use HasFactory, HasUuid;

    protected $fillable = [
        'workspace_id',
        'user_id',
        'role',
    ];

    protected $appends = [
        'permissions',
    ];

    // Relationships
    public function workspace()
    {
        return $this->belongsTo(Workspace::class);
    }

    public function user()
    {
        return $this->belongsTo(User::class);
    }

    public function role()
    {
        return $this->belongsTo(Role::class);
    }

    // Accessors
    public function getPermissionsAttribute()
    {
        return config('makerkit.workspaces.roles.'.mb_strtolower($this->role).'.permissions', []);
    }

    public function isOwner()
    {
        return $this->role === 'owner';
    }

    public function isAdmin()
    {
        return $this->role === 'admin';
    }

    public function isMember()
    {
        return $this->role === 'member';
    }
}
```

### WriterAgent
```php
<?php

declare(strict_types=1);

namespace App\Models;

use App\Concerns\HasUuid;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Support\Str;

final class WriterAgent extends Model
{
    /** @use HasFactory<\Database\Factories\WriterAgentFactory> */
    use HasFactory, HasUuid;

    public const STYLE_FORMAL = 'formal';

    public const STYLE_CASUAL = 'casual';

    public const STYLE_INVESTIGATIVE = 'investigative';

    public const STYLE_CONVERSATIONAL = 'conversational';

    public const WRITING_STYLES = [
        self::STYLE_FORMAL,
        self::STYLE_CASUAL,
        self::STYLE_INVESTIGATIVE,
        self::STYLE_CONVERSATIONAL,
    ];

    protected $fillable = [
        'name',
        'slug',
        'bio',
        'avatar',
        'writing_style',
        'persona_traits',
        'expertise_areas',
        'categories',
        'prompts',
        'articles_count',
        'is_active',
    ];

    public static function generateUniqueSlug(string $name): string
    {
        $slug = Str::slug($name);
        $originalSlug = $slug;
        $count = 1;

        while (self::where('slug', $slug)->exists()) {
            $slug = $originalSlug.'-'.$count;
            $count++;
        }

        return $slug;
    }

    public function regions(): BelongsToMany
    {
        return $this->belongsToMany(Region::class, 'writer_agent_region')
            ->withPivot('is_primary')
            ->withTimestamps();
    }

    public function posts(): HasMany
    {
        return $this->hasMany(DayNewsPost::class);
    }

    /**
     * Get the primary region for this agent.
     */
    public function getPrimaryRegionAttribute(): ?Region
    {
        return $this->regions()->wherePivot('is_primary', true)->first();
    }

    /**
     * Generate a DiceBear avatar URL for this agent.
     */
    public function getAvatarUrlAttribute(): string
    {
        if ($this->avatar) {
            return $this->avatar;
        }

        $seed = urlencode($this->name ?? $this->id);

        return "https://api.dicebear.com/7.x/personas/svg?seed={$seed}";
    }

    /**
     * Get the system prompt for article generation.
     */
    public function getSystemPromptAttribute(): ?string
    {
        return $this->prompts['system_prompt'] ?? null;
    }

    /**
     * Get the style instructions for article generation.
     */
    public function getStyleInstructionsAttribute(): ?string
    {
        return $this->prompts['style_instructions'] ?? null;
    }

    /**
     * Check if the agent handles a specific category.
     *
     * @param  array<string>|string  $categories
     */
    public function handlesCategory(array|string $categories): bool
    {
        $categoryArray = is_array($categories) ? $categories : [$categories];

        return count(array_intersect($this->categories ?? [], $categoryArray)) > 0;
    }

    /**
     * Check if the agent covers a specific region.
     */
    public function coversRegion(string $regionId): bool
    {
        return $this->regions()->where('regions.id', $regionId)->exists();
    }

    // Scopes

    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    public function scopeForRegion($query, string $regionId)
    {
        return $query->whereHas('regions', function ($q) use ($regionId) {
            $q->where('regions.id', $regionId);
        });
    }

    public function scopeForCategory($query, string $category)
    {
        return $query->whereJsonContains('categories', $category);
    }

    public function scopeByWritingStyle($query, string $style)
    {
        return $query->where('writing_style', $style);
    }

    protected static function booted(): void
    {
        self::creating(function (WriterAgent $agent): void {
            if (empty($agent->slug)) {
                $agent->slug = static::generateUniqueSlug($agent->name);
            }

            if (empty($agent->avatar)) {
                $seed = urlencode($agent->name ?? Str::uuid()->toString());
                $agent->avatar = "https://api.dicebear.com/7.x/personas/svg?seed={$seed}";
            }
        });
    }

    protected function casts(): array
    {
        return [
            'persona_traits' => 'array',
            'expertise_areas' => 'array',
            'categories' => 'array',
            'prompts' => 'array',
            'articles_count' => 'integer',
            'is_active' => 'boolean',
        ];
    }
}
```

---
## Routes

### Web Routes
```php
<?php

declare(strict_types=1);

use App\Http\Controllers\BookingController;
use App\Http\Controllers\CalendarController;
use App\Http\Controllers\CommunityController;
use App\Http\Controllers\EventCity\SitemapController as EventCitySitemapController;
use App\Http\Controllers\EventController;
use App\Http\Controllers\FollowController;
use App\Http\Controllers\HomePageController;
use App\Http\Controllers\NotificationController;
use App\Http\Controllers\PerformerController;
use App\Http\Controllers\Social\ImageUploadController;
use App\Http\Controllers\SocialController;
use App\Http\Controllers\SocialFeedController;
use App\Http\Controllers\SocialGroupController;
use App\Http\Controllers\SocialGroupPostController;
use App\Http\Controllers\SocialMessageController;
use App\Http\Controllers\TicketOrderController;
use App\Http\Controllers\TicketPageController;
use App\Http\Controllers\TicketPlanController;
use App\Http\Controllers\VenueController;
use App\Http\Controllers\HubController;
use App\Http\Controllers\HubBuilderController;
use App\Http\Controllers\HubAnalyticsController;
use App\Http\Controllers\CheckInController;
use App\Http\Controllers\PromoCodeController;
use App\Http\Controllers\TicketMarketplaceController;
use App\Http\Controllers\TicketTransferController;
use App\Http\Controllers\TicketGiftController;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Route;
use Inertia\Inertia;

// Sitemap routes
Route::get('/robots.txt', [EventCitySitemapController::class, 'robots'])->name('robots');
Route::get('/sitemap.xml', [EventCitySitemapController::class, 'index'])->name('sitemap.index');
Route::get('/sitemap-static.xml', [EventCitySitemapController::class, 'static'])->name('sitemap.static');
Route::get('/sitemap-events.xml', [EventCitySitemapController::class, 'events'])->name('sitemap.events');
Route::get('/sitemap-events-{page}.xml', [EventCitySitemapController::class, 'events'])->where('page', '[0-9]+')->name('sitemap.events.page');
Route::get('/sitemap-venues.xml', [EventCitySitemapController::class, 'venues'])->name('sitemap.venues');
Route::get('/sitemap-venues-{page}.xml', [EventCitySitemapController::class, 'venues'])->where('page', '[0-9]+')->name('sitemap.venues.page');
Route::get('/sitemap-performers.xml', [EventCitySitemapController::class, 'performers'])->name('sitemap.performers');
Route::get('/sitemap-performers-{page}.xml', [EventCitySitemapController::class, 'performers'])->where('page', '[0-9]+')->name('sitemap.performers.page');
Route::get('/sitemap-calendars.xml', [EventCitySitemapController::class, 'calendars'])->name('sitemap.calendars');
Route::get('/sitemap-community.xml', [EventCitySitemapController::class, 'community'])->name('sitemap.community');

// Public routes
Route::get('/', [HomePageController::class, 'index'])->name('home');

// Marketing pages
Route::get('/about', function () {
    return Inertia::render('event-city/about');
})->name('about');
Route::get('/contact', function () {
    return Inertia::render('event-city/contact');
})->name('contact');
Route::get('/how-it-works', function () {
    return Inertia::render('event-city/how-it-works');
})->name('how-it-works');
Route::get('/success-stories', function () {
    return Inertia::render('event-city/marketing/success-stories', [
        'stories' => [],
    ]);
})->name('success-stories');
Route::get('/advertise', function () {
    return Inertia::render('event-city/marketing/advertise');
})->name('advertise');
Route::get('/partner', function () {
    return Inertia::render('event-city/marketing/partner');
})->name('partner');
Route::get('/press', function () {
    return Inertia::render('event-city/marketing/press', [
        'pressReleases' => [],
        'mediaContacts' => [],
    ]);
})->name('press');
Route::get('/careers', function () {
    return Inertia::render('event-city/marketing/careers', [
        'jobs' => [],
    ]);
})->name('careers');
Route::get('/gear', function () {
    return Inertia::render('event-city/marketing/gear', [
        'products' => [],
        'categories' => [],
    ]);
})->name('gear');
Route::get('/calendar', [CalendarController::class, 'publicIndex'])->name('calendar.index');

// Create routes must come before {id} routes to avoid conflicts
Route::middleware(['auth', 'verified'])->group(function () {
    Route::get('/events/create', [EventController::class, 'create'])->name('events.create');
    Route::get('/performers/create', [PerformerController::class, 'create'])->name('performers.create');
    Route::get('/venues/create', [VenueController::class, 'create'])->name('venues.create');
    Route::get('/calendars/create', [CalendarController::class, 'create'])->name('calendars.create');
});

Route::get('/events', [EventController::class, 'publicIndex'])->name('events');
Route::get('/events/{event}', [EventController::class, 'show'])->name('events.show')->can('view', 'event');
Route::get('/performers', [PerformerController::class, 'publicIndex'])->name('performers');
Route::get('/performers/discovery', function () {
    return Inertia::render('event-city/performers/discovery', [
        'performers' => [],
        'filters' => [],
    ]);
})->name('performers.discovery');
Route::get('/performers/market-report', function () {
    return Inertia::render('event-city/performers/market-report', [
        'marketData' => [],
        'locations' => [],
        'genres' => [],
    ]);
})->name('performers.market-report');
Route::get('/performers/{performer}', [PerformerController::class, 'show'])->name('performers.show')->can('view', 'performer');
Route::get('/venues', [VenueController::class, 'publicIndex'])->name('venues');
Route::get('/venues/submit', function () {
    return Inertia::render('event-city/venues/submit');
})->name('venues.submit');
Route::get('/venues/{venue}', [VenueController::class, 'show'])->name('venues.show')->can('view', 'venue');

// EventCity Business Directory (unique from venues - shows all businesses with event focus)
Route::get('/businesses', [\App\Http\Controllers\EventCity\BusinessController::class, 'index'])->name('event-city.businesses.index');
Route::get('/businesses/{business:slug}', [\App\Http\Controllers\EventCity\BusinessController::class, 'show'])->name('event-city.businesses.show');

// Calendar routes
Route::get('/calendars', [CalendarController::class, 'index'])->name('calendars.index');
// Add any non-numeric calendar routes here (e.g., /calendars/marketplace, /calendars/trending, etc.)
// Route::get('/calendars/marketplace', [CalendarController::class, 'marketplace'])->name('calendars.marketplace');
Route::get('/calendars/{calendar}', [CalendarController::class, 'show'])->name('calendars.show')->can('view', 'calendar');

// Ticket routes
Route::get('/tickets', [TicketPageController::class, 'index'])->name('tickets.index');
Route::get('/events/{event}/tickets', [TicketPageController::class, 'selection'])->name('events.tickets.selection');

// Community routes (publicly accessible)
Route::get('/community', [CommunityController::class, 'index'])->name('community.index');
Route::get('/community/impact', function () {
    return Inertia::render('event-city/community/impact');
})->name('community.impact');
Route::get('/community/{id}', [CommunityController::class, 'show'])->name('community.show');
Route::get('/community/{id}/thread/{threadId}', [CommunityController::class, 'showThread'])->name('community.thread.show');

// Location API routes (public, rate-limited)
Route::prefix('api/location')->group(function () {
    // Search endpoint - higher limit for autocomplete
    Route::get('/search', [App\Http\Controllers\Api\LocationController::class, 'search'])
        ->middleware('throttle:location-search');

    // Action endpoints - lower limit to prevent abuse
    Route::middleware('throttle:location-actions')->group(function () {
        Route::post('/detect-browser', [App\Http\Controllers\Api\LocationController::class, 'detectFromBrowser']);
        Route::post('/set-region', [App\Http\Controllers\Api\LocationController::class, 'setRegion']);
        Route::post('/clear', [App\Http\Controllers\Api\LocationController::class, 'clear']);
    });
});

// API routes for frontend data
Route::middleware(['auth'])->group(function () {
    Route::get('/api/events/featured', [EventController::class, 'featured'])->name('api.events.featured');
    Route::get('/api/events/upcoming', [EventController::class, 'upcoming'])->name('api.events.upcoming');
    Route::get('/api/venues/featured', [VenueController::class, 'featured'])->name('api.venues.featured');
    Route::get('/api/performers/featured', [PerformerController::class, 'featured'])->name('api.performers.featured');
    Route::get('/api/performers/trending', [PerformerController::class, 'trending'])->name('api.performers.trending');

    // Engagement tracking API routes
    Route::post('/api/engagement/track', [App\Http\Controllers\EngagementController::class, 'track'])->name('api.engagement.track');
    Route::post('/api/engagement/session/start', [App\Http\Controllers\EngagementController::class, 'sessionStart'])->name('api.engagement.session.start');
    Route::post('/api/engagement/session/end', [App\Http\Controllers\EngagementController::class, 'sessionEnd'])->name('api.engagement.session.end');

    // Notification API routes
    Route::get('/api/notifications/unread', [NotificationController::class, 'getUnread'])->name('api.notifications.unread');
    Route::patch('/api/notifications/{notification}/read', [NotificationController::class, 'markAsRead'])->name('api.notifications.read');
    Route::patch('/api/notifications/mark-all-read', [NotificationController::class, 'markAllAsRead'])->name('api.notifications.mark-all-read');

    // Ticket API routes
    Route::get('/api/ticket-plans', [TicketPlanController::class, 'index'])->name('api.ticket-plans.index');
    Route::get('/api/events/{event}/ticket-plans', [TicketPlanController::class, 'forEvent'])->name('api.events.ticket-plans');
    Route::resource('/api/ticket-orders', TicketOrderController::class, ['as' => 'api']);

    // Follow API routes
    Route::post('/api/follow/toggle', [FollowController::class, 'toggle'])->name('api.follow.toggle');
    Route::get('/api/follow/status', [FollowController::class, 'checkStatus'])->name('api.follow.status');
});

// N8N Integration API routes (protected with API key authentication)
Route::prefix('api/n8n')->name('api.n8n.')->middleware('n8n.api')->group(function () {
    Route::get('/regions', [App\Http\Controllers\Api\N8nIntegrationController::class, 'getRegions'])->name('regions');
    Route::post('/businesses', [App\Http\Controllers\Api\N8nIntegrationController::class, 'upsertBusiness'])->name('businesses.upsert');
    Route::get('/businesses/{business}/feeds', [App\Http\Controllers\Api\N8nIntegrationController::class, 'getBusinessFeeds'])->name('businesses.feeds');
    Route::post('/feeds', [App\Http\Controllers\Api\N8nIntegrationController::class, 'upsertFeed'])->name('feeds.upsert');
    Route::get('/feeds', [App\Http\Controllers\Api\N8nIntegrationController::class, 'getAllFeeds'])->name('feeds.all');
    Route::patch('/feeds/{feed}/health', [App\Http\Controllers\Api\N8nIntegrationController::class, 'updateFeedHealth'])->name('feeds.health');
    Route::post('/articles', [App\Http\Controllers\Api\N8nIntegrationController::class, 'publishArticle'])->name('articles.publish');
    Route::patch('/articles/{article}/status', [App\Http\Controllers\Api\N8nIntegrationController::class, 'updateArticleStatus'])->name('articles.status');
});

Route::middleware(['auth', 'verified'])->group(function () {
    // Resource routes for CRUD operations (excluding index, show, and create since they're defined elsewhere)
    Route::resource('venues', VenueController::class)->except(['index', 'show', 'create']);
    Route::resource('performers', PerformerController::class)->except(['index', 'show', 'create']);
    Route::resource('events', EventController::class)->except(['index', 'show', 'create']);
    Route::resource('calendars', CalendarController::class)->except(['index', 'show', 'create']);
    Route::resource('bookings', BookingController::class);

    // Calendar management routes
    Route::post('/calendars/{calendar}/follow', [CalendarController::class, 'follow'])->name('calendars.follow');
    Route::post('/calendars/{calendar}/events', [CalendarController::class, 'addEvent'])->name('calendars.events.add');
    Route::delete('/calendars/{calendar}/events/{event}', [CalendarController::class, 'removeEvent'])->name('calendars.events.remove');
    Route::post('/calendars/{calendar}/editors', [CalendarController::class, 'addEditor'])->name('calendars.editors.add');
    Route::delete('/calendars/{calendar}/editors/{user}', [CalendarController::class, 'removeEditor'])->name('calendars.editors.remove');

    // Ticket management routes
    Route::resource('ticket-plans', TicketPlanController::class);
    Route::resource('ticket-orders', TicketOrderController::class);

    // Authenticated ticket routes
    Route::get('/tickets/my-tickets', [TicketPageController::class, 'myTickets'])->name('tickets.my-tickets');
    Route::get('/tickets/checkout/success/{ticketOrder}', [TicketOrderController::class, 'checkoutSuccess'])->name('tickets.checkout.success');
    Route::get('/tickets/checkout/cancel/{ticketOrder}', [TicketOrderController::class, 'checkoutCancel'])->name('tickets.checkout.cancel');
    
    // Public ticket verification route
    Route::get('/tickets/verify/{ticketCode}', [TicketPageController::class, 'verifyTicket'])->name('tickets.verify')->withoutMiddleware(['auth', 'verified']);

    // Hub routes
    Route::resource('hubs', HubController::class)->except(['show']);
    Route::get('/hubs/{hub:slug}', [HubController::class, 'show'])->name('hubs.show')->withoutMiddleware(['auth', 'verified']);
    Route::get('/hubs/{hub}/builder', [HubBuilderController::class, 'show'])->name('hubs.builder');
    Route::post('/hubs/{hub}/builder/design', [HubBuilderController::class, 'updateDesign'])->name('hubs.builder.design');
    Route::post('/hubs/{hub}/builder/sections', [HubBuilderController::class, 'updateSections'])->name('hubs.builder.sections');
    Route::delete('/hubs/{hub}/builder/sections/{section}', [HubBuilderController::class, 'deleteSection'])->name('hubs.builder.sections.delete');
    Route::get('/hubs/{hub}/preview', [HubBuilderController::class, 'preview'])->name('hubs.preview');
    Route::post('/hubs/{hub}/publish', [HubBuilderController::class, 'publish'])->name('hubs.publish');
    Route::get('/hubs/{hub}/analytics', [HubAnalyticsController::class, 'index'])->name('hubs.analytics');
    Route::get('/api/hubs/{hub}/analytics/stats', [HubAnalyticsController::class, 'getStats'])->name('api.hubs.analytics.stats');
    Route::post('/api/hubs/{hub}/analytics/track-view', [HubAnalyticsController::class, 'trackPageView'])->name('api.hubs.analytics.track-view');
    Route::post('/api/hubs/{hub}/analytics/track-visitor', [HubAnalyticsController::class, 'trackVisitor'])->name('api.hubs.analytics.track-visitor');

    // Check-in routes
    Route::resource('check-ins', CheckInController::class)->except(['create', 'edit']);
    Route::post('/api/events/{event}/check-in', [CheckInController::class, 'store'])->name('api.events.check-in');
    Route::get('/api/events/{event}/check-ins', [CheckInController::class, 'forEvent'])->name('api.events.check-ins');

    // Planned events routes
    Route::post('/api/events/{event}/plan', function (Request $request, Event $event) {
        $plannedEvent = PlannedEvent::firstOrCreate([
            'event_id' => $event->id,
            'user_id' => $request->user()->id,
        ], [
            'planned_at' => now(),
        ]);
        return response()->json($plannedEvent);
    })->name('api.events.plan');
    Route::delete('/api/events/{event}/unplan', function (Request $request, Event $event) {
        PlannedEvent::where('event_id', $event->id)
            ->where('user_id', $request->user()->id)
            ->delete();
        return response()->json(['success' => true]);
    })->name('api.events.unplan');

    // Promo code routes
    Route::resource('promo-codes', PromoCodeController::class);
    Route::post('/api/promo-codes/validate', [PromoCodeController::class, 'validate'])->name('api.promo-codes.validate');

    // Ticket marketplace routes
    Route::get('/tickets/marketplace', [TicketMarketplaceController::class, 'index'])->name('tickets.marketplace.index')->withoutMiddleware(['auth', 'verified']);
    Route::get('/tickets/list-for-sale', [TicketMarketplaceController::class, 'create'])->name('tickets.marketplace.create');
    Route::post('/tickets/list-for-sale', [TicketMarketplaceController::class, 'store'])->name('tickets.marketplace.store');
    Route::get('/tickets/marketplace/{listing}', [TicketMarketplaceController::class, 'show'])->name('tickets.marketplace.show')->withoutMiddleware(['auth', 'verified']);
    Route::post('/tickets/marketplace/{listing}/purchase', [TicketMarketplaceController::class, 'purchase'])->name('tickets.marketplace.purchase');
    Route::delete('/tickets/marketplace/{listing}', [TicketMarketplaceController::class, 'destroy'])->name('tickets.marketplace.destroy');

    // Ticket transfer routes
    Route::get('/tickets/transfer/{ticketOrderItem}', [TicketTransferController::class, 'create'])->name('tickets.transfer.create');
    Route::post('/tickets/transfer/{ticketOrderItem}', [TicketTransferController::class, 'store'])->name('tickets.transfer.store');
    Route::get('/tickets/transfer/accept/{token}', [TicketTransferController::class, 'accept'])->name('tickets.transfer.accept')->withoutMiddleware(['auth', 'verified']);
    Route::post('/tickets/transfer/{transfer}/complete', [TicketTransferController::class, 'complete'])->name('tickets.transfer.complete');
    Route::post('/tickets/transfer/{transfer}/cancel', [TicketTransferController::class, 'cancel'])->name('tickets.transfer.cancel');

    // Ticket gift routes
    Route::get('/tickets/gift/{ticketOrderItem}', [TicketGiftController::class, 'create'])->name('tickets.gift.create');
    Route::post('/tickets/gift/{ticketOrderItem}', [TicketGiftController::class, 'store'])->name('tickets.gift.store');
    Route::get('/tickets/gift/redeem/{token}', [TicketGiftController::class, 'redeem'])->name('tickets.gift.redeem')->withoutMiddleware(['auth', 'verified']);
    Route::post('/tickets/gift/{gift}/complete', [TicketGiftController::class, 'complete'])->name('tickets.gift.complete');
    Route::post('/tickets/gift/{gift}/cancel', [TicketGiftController::class, 'cancel'])->name('tickets.gift.cancel');

    // Dashboard routes
    Route::get('/dashboard', function (Request $request) {
        // Redirect to appropriate dashboard based on user role or default to fan dashboard
        return redirect()->route('dashboard.fan');
    })->name('dashboard');
    
    Route::get('/dashboard/fan', function (Request $request) {
        return Inertia::render('event-city/dashboard/fan', [
            'user' => $request->user(),
            'upcomingEvents' => [],
            'pastEvents' => [],
            'plannedEvents' => [],
            'stats' => [
                'total_events_attended' => 0,
                'upcoming_events' => 0,
                'total_spent' => 0,
                'favorite_performers' => 0,
            ],
        ]);
    })->name('dashboard.fan');
    Route::get('/dashboard/organizer', function (Request $request) {
        return Inertia::render('event-city/dashboard/organizer', [
            'events' => [],
            'stats' => [
                'total_events' => 0,
                'upcoming_events' => 0,
                'total_revenue' => 0,
                'total_attendees' => 0,
                'ticket_sales' => 0,
            ],
        ]);
    })->name('dashboard.organizer');
    Route::get('/dashboard/performer', function (Request $request) {
        return Inertia::render('event-city/dashboard/performer', [
            'performer' => [],
            'upcomingGigs' => [],
            'pastGigs' => [],
            'stats' => [
                'total_gigs' => 0,
                'total_revenue' => 0,
                'average_rating' => 0,
                'upcoming_shows' => 0,
            ],
        ]);
    })->name('dashboard.performer');
    Route::get('/dashboard/venue-owner', function (Request $request) {
        return Inertia::render('event-city/dashboard/venue-owner', [
            'venues' => [],
            'upcomingBookings' => [],
            'stats' => [
                'total_venues' => 0,
                'total_bookings' => 0,
                'total_revenue' => 0,
                'upcoming_bookings' => 0,
            ],
        ]);
    })->name('dashboard.venue-owner');
    Route::get('/dashboard/calendar', function (Request $request) {
        return Inertia::render('event-city/dashboard/calendar', [
            'events' => [],
            'currentDate' => now()->toDateString(),
        ]);
    })->name('dashboard.calendar');

    // Community thread management routes (require authentication)
    Route::get('/community/{id}/new-thread', [CommunityController::class, 'createThread'])->name('community.thread.create');
    Route::post('/community/{id}/threads', [CommunityController::class, 'storeThread'])->name('community.thread.store');

    // Community thread reply routes (require authentication)
    Route::post('/community/thread/{threadId}/replies', [CommunityController::class, 'storeReply'])->name('community.thread.reply.store');
    Route::patch('/community/reply/{replyId}', [CommunityController::class, 'updateReply'])->name('community.reply.update');
    Route::delete('/community/reply/{replyId}', [CommunityController::class, 'destroyReply'])->name('community.reply.destroy');
    Route::post('/community/reply/{replyId}/like', [CommunityController::class, 'likeReply'])->name('community.reply.like');

    // Notifications
    Route::get('/notifications', [NotificationController::class, 'index'])->name('notifications.index');

    // Additional booking actions
    Route::patch('/bookings/{booking}/confirm', [BookingController::class, 'confirm'])->name('bookings.confirm');
    Route::patch('/bookings/{booking}/cancel', [BookingController::class, 'cancel'])->name('bookings.cancel');

    // Social media routes
    Route::prefix('social')->name('social.')->group(function () {
        // Social feed and posts
        Route::get('/', [SocialController::class, 'index'])->name('index');

        // Feed algorithms
        Route::get('/feed', [SocialFeedController::class, 'index'])->name('feed.index');
        Route::get('/feed/for-you', [SocialFeedController::class, 'forYou'])->name('feed.for-you');
        Route::get('/feed/followed', [SocialFeedController::class, 'followed'])->name('feed.followed');

        Route::post('/posts', [SocialController::class, 'createPost'])->name('posts.create');
        Route::post('/images/upload', [ImageUploadController::class, 'upload'])->name('images.upload');
        Route::post('/posts/{post}/like', [SocialController::class, 'likePost'])->name('posts.like');
        Route::delete('/posts/{post}/like', [SocialController::class, 'unlikePost'])->name('posts.unlike');
        Route::post('/posts/{post}/comments', [SocialController::class, 'createComment'])->name('posts.comments.create');
        Route::delete('/comments/{comment}', [SocialController::class, 'deleteComment'])->name('comments.delete');

        // Friend management
        Route::post('/users/{user}/friend-request', [SocialController::class, 'sendFriendRequest'])->name('friend.request');
        Route::patch('/friendships/{friendship}/accept', [SocialController::class, 'acceptFriendRequest'])->name('friend.accept');

        // User profiles
        Route::get('/profile/{user}', [SocialController::class, 'profile'])->name('profile');
        Route::patch('/profile', [SocialController::class, 'updateProfile'])->name('profile.update');

        // Activity feed/notifications
        Route::get('/activities', [SocialController::class, 'activities'])->name('activities');
        Route::patch('/activities/read', [SocialController::class, 'markActivitiesAsRead'])->name('activities.read');

        // Friends management
        Route::prefix('friends')->name('friends.')->group(function () {
            Route::get('/', [SocialController::class, 'friendsIndex'])->name('index');
            Route::patch('/{user}/accept', [SocialController::class, 'acceptFriendRequest'])->name('accept');
            Route::delete('/{user}/decline', [SocialController::class, 'declineFriendRequest'])->name('decline');
            Route::delete('/{user}/cancel', [SocialController::class, 'cancelFriendRequest'])->name('cancel');
            Route::delete('/{user}/remove', [SocialController::class, 'removeFriend'])->name('remove');
        });

        // Messages
        Route::prefix('messages')->name('messages.')->group(function () {
            Route::get('/', [SocialMessageController::class, 'index'])->name('index');
            Route::get('/new', [SocialMessageController::class, 'newMessage'])->name('new');
            Route::post('/start', [SocialMessageController::class, 'startConversation'])->name('start');
            Route::get('/{conversation}', [SocialMessageController::class, 'show'])->name('show');
            Route::post('/{conversation}', [SocialMessageController::class, 'sendMessage'])->name('send');
        });

        // Groups
        Route::prefix('groups')->name('groups.')->group(function () {
            Route::get('/', [SocialGroupController::class, 'index'])->name('index');
            Route::get('/create', [SocialGroupController::class, 'create'])->name('create');
            Route::post('/', [SocialGroupController::class, 'store'])->name('store');
            Route::get('/{group}', [SocialGroupController::class, 'show'])->name('show');
            Route::post('/{group}/join', [SocialGroupController::class, 'join'])->name('join');
            Route::delete('/{group}/leave', [SocialGroupController::class, 'leave'])->name('leave');

            // Group invitations
            Route::post('/{group}/invite', [SocialGroupController::class, 'invite'])->name('invite');
            Route::patch('/invitations/{invitation}/respond', [SocialGroupController::class, 'respondToInvitation'])->name('invitations.respond');
            Route::get('/search-users', [SocialGroupController::class, 'searchUsers'])->name('search.users');

            // Group posts
            Route::get('/{group}/posts', [SocialGroupPostController::class, 'index'])->name('posts.index');
            Route::post('/{group}/posts', [SocialGroupPostController::class, 'store'])->name('posts.store');
            Route::get('/{group}/posts/{post}', [SocialGroupPostController::class, 'show'])->name('posts.show');
            Route::patch('/{group}/posts/{post}', [SocialGroupPostController::class, 'update'])->name('posts.update');
            Route::delete('/{group}/posts/{post}', [SocialGroupPostController::class, 'destroy'])->name('posts.destroy');
            Route::patch('/{group}/posts/{post}/pin', [SocialGroupPostController::class, 'pin'])->name('posts.pin');
        });
    });

    // Ecommerce routes
    Route::get('/shop', [App\Http\Controllers\ProductController::class, 'discover'])->name('shop.discover')->withoutMiddleware(['auth', 'verified']);

    Route::prefix('stores')->name('stores.')->group(function () {
        // Public store list
        Route::get('/', [App\Http\Controllers\StoreController::class, 'index'])->name('index')->withoutMiddleware(['auth', 'verified']);

        // Authenticated store management (must come before /{slug} route)
        Route::get('/my-stores', [App\Http\Controllers\StoreController::class, 'myStores'])->name('my-stores');
        Route::get('/create', [App\Http\Controllers\StoreController::class, 'create'])->name('create');
        Route::post('/', [App\Http\Controllers\StoreController::class, 'store'])->name('store');

        // Public store show (must come after specific routes) - uses slug for SEO-friendly URLs
        Route::get('/{slug}', [App\Http\Controllers\StoreController::class, 'show'])->name('show')->withoutMiddleware(['auth', 'verified']);

        // Store management routes with store ID parameter
        Route::get('/{store:id}/edit', [App\Http\Controllers\StoreController::class, 'edit'])->name('edit');
        Route::patch('/{store:id}', [App\Http\Controllers\StoreController::class, 'update'])->name('update');

        // Stripe Connect routes - use ID for authenticated operations
        Route::match(['get', 'post'], '/{store:id}/connect-stripe', [App\Http\Controllers\StoreController::class, 'connectStripe'])->name('connect-stripe');
        Route::get('/{store:id}/connect-return', [App\Http\Controllers\StoreController::class, 'connectReturn'])->name('connect-return')->withoutMiddleware(['auth', 'verified']);
        Route::get('/{store:id}/connect-refresh', [App\Http\Controllers\StoreController::class, 'connectRefresh'])->name('connect-refresh')->withoutMiddleware(['auth', 'verified']);
        Route::get('/{store:id}/stripe-dashboard', [App\Http\Controllers\StoreController::class, 'stripeDashboard'])->name('stripe-dashboard');
    });

    // Product routes - using store ID for authenticated routes
    Route::prefix('stores/{store:id}')->name('products.')->group(function () {
        Route::middleware(['auth', 'verified'])->group(function () {
            Route::get('/products/create', [App\Http\Controllers\ProductController::class, 'create'])->name('create');
            Route::post('/products', [App\Http\Controllers\ProductController::class, 'store'])->name('store');
        });

        Route::get('/products/{product:id}', [App\Http\Controllers\ProductController::class, 'show'])->name('show')->withoutMiddleware(['auth', 'verified']);

        Route::middleware(['auth', 'verified'])->group(function () {
            Route::get('/products/{product:id}/edit', [App\Http\Controllers\ProductController::class, 'edit'])->name('edit');
            Route::patch('/products/{product:id}', [App\Http\Controllers\ProductController::class, 'update'])->name('update');
            Route::delete('/products/{product:id}', [App\Http\Controllers\ProductController::class, 'destroy'])->name('destroy');
        });
    });

    // Order routes
    Route::prefix('orders')->name('orders.')->middleware(['auth', 'verified'])->group(function () {
        Route::get('/', [App\Http\Controllers\OrderController::class, 'index'])->name('index');
        Route::get('/{order}', [App\Http\Controllers\OrderController::class, 'show'])->name('show');
        Route::patch('/{order}/status', [App\Http\Controllers\OrderController::class, 'updateStatus'])->name('update-status');
    });

    // Checkout routes
    Route::post('/checkout', [App\Http\Controllers\OrderController::class, 'checkout'])->name('checkout');
    Route::get('/checkout/success/{order}', [App\Http\Controllers\OrderController::class, 'success'])->name('checkout.success');
    Route::get('/checkout/cancel/{order}', [App\Http\Controllers\OrderController::class, 'cancel'])->name('checkout.cancel');

    // Cart routes
    Route::prefix('cart')->name('cart.')->group(function () {
        Route::get('/', [App\Http\Controllers\CartController::class, 'index'])->name('index')->withoutMiddleware(['auth', 'verified']);
        Route::post('/add', [App\Http\Controllers\CartController::class, 'add'])->name('add')->withoutMiddleware(['auth', 'verified']);
        Route::patch('/{cartItem}', [App\Http\Controllers\CartController::class, 'update'])->name('update')->withoutMiddleware(['auth', 'verified']);
        Route::delete('/{cartItem}', [App\Http\Controllers\CartController::class, 'remove'])->name('remove')->withoutMiddleware(['auth', 'verified']);
        Route::delete('/', [App\Http\Controllers\CartController::class, 'clear'])->name('clear')->withoutMiddleware(['auth', 'verified']);
        Route::get('/count', [App\Http\Controllers\CartController::class, 'count'])->name('count')->withoutMiddleware(['auth', 'verified']);
    });

    // Cart API routes
    Route::get('/api/cart/items', [App\Http\Controllers\CartController::class, 'items'])->withoutMiddleware(['auth', 'verified']);
});

// Stripe webhook (public route, no auth/CSRF)
Route::post('/stripe/webhook', App\Http\Controllers\StripeWebhookController::class)->name('stripe.webhook');

require __DIR__.'/workspace.php';
require __DIR__.'/settings.php';
require __DIR__.'/auth.php';
require __DIR__.'/ads.php';
require __DIR__.'/email-tracking.php';
require __DIR__.'/admin.php';
```

### API Routes
```php
<?php

declare(strict_types=1);

use App\Http\Controllers\Api\NotificationController;
use App\Http\Controllers\OrganizationController;
use App\Http\Controllers\OrganizationRelationshipController;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Route;

Route::get('/user', function (Request $request) {
    return $request->user();
})->middleware('auth:sanctum');

// Organization Routes
Route::prefix('organizations')->group(function () {
    Route::get('/search', [OrganizationController::class, 'search']);
    Route::get('/{organization}/content', [OrganizationController::class, 'getContent']);
    Route::post('/{organization}/relate', [OrganizationController::class, 'relate']);
    Route::get('/{organization}/hierarchy', [OrganizationController::class, 'hierarchy']);
});

// Organization Relationship Routes
Route::prefix('organization-relationships')->group(function () {
    Route::post('/', [OrganizationRelationshipController::class, 'store']);
    Route::post('/bulk', [OrganizationRelationshipController::class, 'bulkStore']);
    Route::put('/{relationship}', [OrganizationRelationshipController::class, 'update']);
    Route::delete('/{relationship}', [OrganizationRelationshipController::class, 'destroy']);
});

// Notification Routes
Route::prefix('notifications')->group(function () {
    // Public endpoints
    Route::get('vapid-key', [NotificationController::class, 'getVapidKey']);
    
    // Authenticated endpoints
    Route::middleware('auth:sanctum')->group(function () {
        // Web Push
        Route::post('web-push/register', [NotificationController::class, 'registerWebPush']);
        
        // SMS
        Route::post('sms/request-verification', [NotificationController::class, 'requestPhoneVerification']);
        Route::post('sms/verify-and-subscribe', [NotificationController::class, 'verifyPhoneAndSubscribe']);
        
        // Management
        Route::get('subscriptions', [NotificationController::class, 'getSubscriptions']);
        Route::patch('subscriptions/{subscription}', [NotificationController::class, 'updatePreferences']);
        Route::delete('subscriptions/{subscription}', [NotificationController::class, 'unsubscribe']);
    });
});

```

### Compiled Route List
```
// ... existing code ...

    public function publicIndex(Request $request): Response
    {
        $viewMode = $request->query('view', 'list');
        $selectedDate = $request->query('date') ? new \DateTime($request->query('date')) : new \DateTime();
        
        $query = Event::published()
            ->upcoming()
            ->with(['venue', 'performer']);

        // Filter by date based on view mode
        if ($viewMode === 'today') {
            $query->whereDate('event_date', $selectedDate->format('Y-m-d'));
        } elseif ($viewMode === '7days') {
            $endDate = clone $selectedDate;
            $endDate->modify('+7 days');
            $query->whereBetween('event_date', [$selectedDate->format('Y-m-d'), $endDate->format('Y-m-d')]);
        } elseif ($viewMode === 'month') {
            $startDate = clone $selectedDate;
            $startDate->modify('first day of this month');
            $endDate = clone $selectedDate;
            $endDate->modify('last day of this month');
            $query->whereBetween('event_date', [$startDate->format('Y-m-d'), $endDate->format('Y-m-d')]);
        }

        $events = $query->orderBy('event_date', 'asc')->get();

        return Inertia::render('event-city/calendar/index', [
            'events' => $events,
            'selectedDate' => $selectedDate->format('Y-m-d'),
            'viewMode' => $viewMode,
        ]);
    }

// ... existing code ...
// ... existing code ...

    public function publicIndex(Request $request): Response
    {
        $viewMode = $request->query('view', 'list');
        $selectedDate = $request->query('date') ? new \DateTime($request->query('date')) : new \DateTime();
        
        $query = Event::published()
            ->upcoming()
            ->with(['venue', 'performer']);

        // Filter by date based on view mode
        if ($viewMode === 'today') {
            $query->whereDate('event_date', $selectedDate->format('Y-m-d'));
        } elseif ($viewMode === '7days') {
            $endDate = clone $selectedDate;
            $endDate->modify('+7 days');
            $query->whereBetween('event_date', [$selectedDate->format('Y-m-d'), $endDate->format('Y-m-d')]);
        } elseif ($viewMode === 'month') {
            $startDate = clone $selectedDate;
            $startDate->modify('first day of this month');
            $endDate = clone $selectedDate;
            $endDate->modify('last day of this month');
            $query->whereBetween('event_date', [$startDate->format('Y-m-d'), $endDate->format('Y-m-d')]);
        }

        $events = $query->orderBy('event_date', 'asc')->get();

        return Inertia::render('event-city/calendar/index', [
            'events' => $events,
            'selectedDate' => $selectedDate->format('Y-m-d'),
            'viewMode' => $viewMode,
        ]);
    }

// ... existing code ...
// ... existing code ...

    public function publicIndex(Request $request): Response
    {
        $viewMode = $request->query('view', 'list');
        $selectedDate = $request->query('date') ? new \DateTime($request->query('date')) : new \DateTime();
        
        $query = Event::published()
            ->upcoming()
            ->with(['venue', 'performer']);

        // Filter by date based on view mode
        if ($viewMode === 'today') {
            $query->whereDate('event_date', $selectedDate->format('Y-m-d'));
        } elseif ($viewMode === '7days') {
            $endDate = clone $selectedDate;
            $endDate->modify('+7 days');
            $query->whereBetween('event_date', [$selectedDate->format('Y-m-d'), $endDate->format('Y-m-d')]);
        } elseif ($viewMode === 'month') {
            $startDate = clone $selectedDate;
            $startDate->modify('first day of this month');
            $endDate = clone $selectedDate;
            $endDate->modify('last day of this month');
            $query->whereBetween('event_date', [$startDate->format('Y-m-d'), $endDate->format('Y-m-d')]);
        }

        $events = $query->orderBy('event_date', 'asc')->get();

        return Inertia::render('event-city/calendar/index', [
            'events' => $events,
            'selectedDate' => $selectedDate->format('Y-m-d'),
            'viewMode' => $viewMode,
        ]);
    }

// ... existing code ...

   ReflectionException 

  Class "App\Http\Controllers\CalendarController" does not exist

  at vendor/laravel/framework/src/Illuminate/Foundation/Console/RouteListCommand.php:235
    231             if ($this->isFrameworkController($route)) {
    232                 return false;
    233             }
    234 
   235             $path = (new ReflectionClass($route->getControllerClass()))
    236                 ->getFileName();
    237         } else {
    238             return false;
    239         }

      [2m+3 vendor frames [22m

  4   [internal]:0
      Illuminate\Foundation\Console\RouteListCommand::{closure:Illuminate\Foundation\Console\RouteListCommand::getRoutes():117}(Object(Illuminate\Routing\Route))
      [2m+17 vendor frames [22m

  22  artisan:16
      Illuminate\Foundation\Application::handleCommand(Object(Symfony\Component\Console\Input\ArgvInput))

(could not compile)
```

---
## Database Migrations

### 0001_01_01_000000_create_users_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('users', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password')->nullable();
            $table->rememberToken();
            $table->timestamps();
        });

        Schema::create('password_reset_tokens', function (Blueprint $table) {
            $table->string('email')->primary();
            $table->string('token');
            $table->timestamp('created_at')->nullable();
        });

        Schema::create('sessions', function (Blueprint $table) {
            $table->string('id')->primary();
            $table->foreignUuid('user_id')->nullable()->index();
            $table->string('ip_address', 45)->nullable();
            $table->text('user_agent')->nullable();
            $table->longText('payload');
            $table->integer('last_activity')->index();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('users');
        Schema::dropIfExists('password_reset_tokens');
        Schema::dropIfExists('sessions');
    }
};
```

### 0001_01_01_000001_create_cache_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('cache', function (Blueprint $table) {
            $table->string('key')->primary();
            $table->mediumText('value');
            $table->integer('expiration');
        });

        Schema::create('cache_locks', function (Blueprint $table) {
            $table->string('key')->primary();
            $table->string('owner');
            $table->integer('expiration');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('cache');
        Schema::dropIfExists('cache_locks');
    }
};
```

### 0001_01_01_000002_create_jobs_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('jobs', function (Blueprint $table) {
            $table->id();
            $table->string('queue')->index();
            $table->longText('payload');
            $table->unsignedTinyInteger('attempts');
            $table->unsignedInteger('reserved_at')->nullable();
            $table->unsignedInteger('available_at');
            $table->unsignedInteger('created_at');
        });

        Schema::create('job_batches', function (Blueprint $table) {
            $table->string('id')->primary();
            $table->string('name');
            $table->integer('total_jobs');
            $table->integer('pending_jobs');
            $table->integer('failed_jobs');
            $table->longText('failed_job_ids');
            $table->mediumText('options')->nullable();
            $table->integer('cancelled_at')->nullable();
            $table->integer('created_at');
            $table->integer('finished_at')->nullable();
        });

        Schema::create('failed_jobs', function (Blueprint $table) {
            $table->id();
            $table->string('uuid')->unique();
            $table->text('connection');
            $table->text('queue');
            $table->longText('payload');
            $table->longText('exception');
            $table->timestamp('failed_at')->useCurrent();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('jobs');
        Schema::dropIfExists('job_batches');
        Schema::dropIfExists('failed_jobs');
    }
};
```

### 2017_07_06_000000_create_table_magic_links.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

final class CreateTableMagicLinks extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('magic_links', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('token', 255);
            $table->text('action');
            $table->unsignedTinyInteger('num_visits')->default(0);
            $table->unsignedTinyInteger('max_visits')->nullable();
            $table->timestamp('available_at')->nullable();
            $table->string('access_code')->nullable();
            $table->timestamps();

            $table->index('available_at');
            $table->index('max_visits');
        });
    }

    /**
     * Reverse the migrations.
     *
     * @return void
     */
    public function down()
    {
        Schema::dropIfExists('magic_links');
    }
}
```

### 2025_01_15_000001_add_reviews_and_ratings_to_day_news_posts_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Only run if day_news_posts table exists
        if (Schema::hasTable('day_news_posts')) {
            Schema::table('day_news_posts', function (Blueprint $table) {
                if (!Schema::hasColumn('day_news_posts', 'average_rating')) {
                    $table->decimal('average_rating', 3, 2)->nullable()->after('view_count');
                }
                if (!Schema::hasColumn('day_news_posts', 'total_reviews')) {
                    $table->unsignedInteger('total_reviews')->default(0)->after('average_rating');
                }
                
                // Only add index if column exists
                if (Schema::hasColumn('day_news_posts', 'average_rating')) {
                    $indexes = Schema::getConnection()->getDoctrineSchemaManager()->listTableIndexes('day_news_posts');
                    if (!isset($indexes['day_news_posts_average_rating_index'])) {
                        $table->index('average_rating');
                    }
                }
            });
        }
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('day_news_posts', function (Blueprint $table) {
            $table->dropIndex(['average_rating']);
            $table->dropColumn(['average_rating', 'total_reviews']);
        });
    }
};

```

### 2025_01_15_000002_add_day_news_activity_types.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Note: MySQL doesn't support ALTER ENUM directly, so we need to modify the column
        // This migration adds Day News activity types to the existing enum
        
        $driver = DB::getDriverName();
        
        if ($driver === 'mysql') {
            // For MySQL, we need to alter the column type
            DB::statement("ALTER TABLE social_activities MODIFY COLUMN type ENUM(
                'post_like', 'post_comment', 'post_share',
                'friend_request', 'friend_accept',
                'group_invite', 'group_join', 'group_post',
                'profile_follow',
                'article_like', 'article_comment', 'article_share', 'article_view',
                'tag_follow', 'author_follow'
            ) NOT NULL");
        } elseif ($driver === 'pgsql') {
            // For PostgreSQL, we can use ALTER TYPE
            DB::statement("ALTER TYPE social_activities_type_enum ADD VALUE IF NOT EXISTS 'article_like'");
            DB::statement("ALTER TYPE social_activities_type_enum ADD VALUE IF NOT EXISTS 'article_comment'");
            DB::statement("ALTER TYPE social_activities_type_enum ADD VALUE IF NOT EXISTS 'article_share'");
            DB::statement("ALTER TYPE social_activities_type_enum ADD VALUE IF NOT EXISTS 'article_view'");
            DB::statement("ALTER TYPE social_activities_type_enum ADD VALUE IF NOT EXISTS 'tag_follow'");
            DB::statement("ALTER TYPE social_activities_type_enum ADD VALUE IF NOT EXISTS 'author_follow'");
        } elseif ($driver === 'sqlite') {
            // SQLite stores ENUMs as strings, so new values will work without modification
            // No action needed - the application will validate the enum values
        }
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Note: Removing enum values is complex and may not be fully reversible
        // In practice, you may need to recreate the table or leave the values
        // This is a common limitation with ENUM types
    }
};

```

### 2025_01_15_000003_create_article_comments_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('article_comments', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignId('article_id')->constrained('day_news_posts')->cascadeOnDelete();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->uuid('parent_id')->nullable();
            $table->text('content');
            $table->boolean('is_active')->default(true);
            $table->boolean('is_pinned')->default(false);
            $table->unsignedInteger('reports_count')->default(0);
            $table->timestamps();

            $table->index(['article_id', 'parent_id', 'created_at']);
            $table->index(['user_id', 'created_at']);
            $table->index(['article_id', 'is_active', 'created_at']);
            
            // Self-referencing foreign key for replies
            $table->foreign('parent_id')->references('id')->on('article_comments')->onDelete('cascade');
        });

        // Article comment likes table
        Schema::create('article_comment_likes', function (Blueprint $table) {
            $table->id();
            $table->uuid('comment_id')->constrained('article_comments')->cascadeOnDelete();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['comment_id', 'user_id']);
            $table->index(['comment_id', 'created_at']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('article_comment_likes');
        Schema::dropIfExists('article_comments');
    }
};

```

### 2025_01_15_000004_create_tags_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('tags', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('name');
            $table->string('slug')->unique();
            $table->text('description')->nullable();
            $table->unsignedInteger('article_count')->default(0);
            $table->unsignedInteger('followers_count')->default(0);
            $table->boolean('is_trending')->default(false);
            $table->unsignedInteger('trending_score')->default(0);
            $table->timestamps();

            $table->index('slug');
            $table->index('is_trending');
            $table->index(['is_trending', 'trending_score']);
        });

        // Pivot table for tags and articles
        Schema::create('day_news_post_tag', function (Blueprint $table) {
            $table->id();
            $table->foreignId('day_news_post_id')->constrained()->cascadeOnDelete();
            $table->uuid('tag_id')->constrained('tags')->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['day_news_post_id', 'tag_id']);
            $table->index('tag_id');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('day_news_post_tag');
        Schema::dropIfExists('tags');
    }
};

```

### 2025_01_15_000005_create_search_tables.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Search history table
        Schema::create('search_history', function (Blueprint $table) {
            $table->id();
            $table->foreignUuid('user_id')->nullable()->constrained('users')->nullOnDelete();
            $table->string('query');
            $table->unsignedInteger('results_count')->default(0);
            $table->json('filters')->nullable();
            $table->string('ip_address')->nullable();
            $table->timestamps();

            $table->index(['user_id', 'created_at']);
            $table->index(['query', 'created_at']);
            $table->index('created_at');
        });

        // Search suggestions table
        Schema::create('search_suggestions', function (Blueprint $table) {
            $table->id();
            $table->string('query')->unique();
            $table->unsignedInteger('popularity')->default(1);
            $table->unsignedInteger('click_count')->default(0);
            $table->timestamps();

            $table->index('popularity');
            $table->index('query');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('search_suggestions');
        Schema::dropIfExists('search_history');
    }
};

```

### 2025_01_15_000006_create_comment_reports_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('comment_reports', function (Blueprint $table) {
            $table->id();
            $table->uuid('comment_id')->constrained('article_comments')->cascadeOnDelete();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->string('reason'); // spam, harassment, inappropriate, other
            $table->text('details')->nullable();
            $table->enum('status', ['pending', 'reviewed', 'resolved', 'dismissed'])->default('pending');
            $table->timestamps();

            $table->unique(['comment_id', 'user_id']); // One report per user per comment
            $table->index(['status', 'created_at']);
            $table->index('comment_id');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('comment_reports');
    }
};

```

### 2025_01_15_000007_create_announcements_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('announcements', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->foreignUuid('workspace_id')->nullable()->constrained()->nullOnDelete();
            $table->enum('type', [
                'wedding',
                'engagement',
                'birth',
                'graduation',
                'anniversary',
                'celebration',
                'general',
                'community_event',
                'public_notice',
                'emergency_alert',
                'meeting',
                'volunteer_opportunity',
                'road_closure',
                'school_announcement',
            ]);
            $table->string('title');
            $table->text('content');
            $table->string('image')->nullable();
            $table->string('location')->nullable();
            $table->date('event_date')->nullable();
            $table->enum('status', ['draft', 'pending', 'published', 'expired', 'removed'])->default('draft');
            $table->timestamp('published_at')->nullable();
            $table->timestamp('expires_at')->nullable();
            $table->unsignedInteger('views_count')->default(0);
            $table->unsignedInteger('reactions_count')->default(0);
            $table->unsignedInteger('comments_count')->default(0);
            $table->timestamps();

            $table->index(['type', 'status']);
            $table->index(['status', 'published_at']);
            $table->index(['user_id', 'status']);
            $table->index('event_date');
        });

        // Announcement regions pivot table
        Schema::create('announcement_region', function (Blueprint $table) {
            $table->id();
            $table->uuid('announcement_id')->constrained('announcements')->cascadeOnDelete();
            $table->foreignUuid('region_id')->constrained()->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['announcement_id', 'region_id']);
        });

        // Announcement reactions (using polymorphic Rating model)
        // No separate table needed - using existing ratings table
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('announcement_region');
        Schema::dropIfExists('announcements');
    }
};

```

### 2025_01_15_000008_create_classifieds_tables.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('classifieds', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->foreignUuid('workspace_id')->nullable()->constrained()->nullOnDelete();
            $table->enum('category', [
                'for_sale',
                'housing',
                'jobs',
                'services',
                'community',
                'personals',
            ]);
            $table->string('subcategory')->nullable();
            $table->string('title');
            $table->text('description');
            $table->decimal('price', 10, 2)->nullable();
            $table->string('price_type')->nullable(); // fixed, negotiable, contact_for_pricing
            $table->string('condition')->nullable(); // new, like_new, excellent, good, fair, poor
            $table->string('location');
            $table->boolean('is_featured')->default(false);
            $table->enum('status', ['draft', 'pending_payment', 'active', 'expired', 'sold', 'removed'])->default('draft');
            $table->timestamp('posted_at')->nullable();
            $table->timestamp('expires_at')->nullable();
            $table->unsignedInteger('views_count')->default(0);
            $table->timestamps();

            $table->index(['category', 'status']);
            $table->index(['status', 'posted_at']);
            $table->index(['user_id', 'status']);
            $table->index('expires_at');
        });

        // Classified images table
        Schema::create('classified_images', function (Blueprint $table) {
            $table->id();
            $table->uuid('classified_id')->constrained('classifieds')->cascadeOnDelete();
            $table->string('image_path');
            $table->string('image_disk')->default('public');
            $table->unsignedInteger('order')->default(0);
            $table->timestamps();

            $table->index(['classified_id', 'order']);
        });

        // Classified regions pivot table
        Schema::create('classified_region', function (Blueprint $table) {
            $table->id();
            $table->uuid('classified_id')->constrained('classifieds')->cascadeOnDelete();
            $table->foreignUuid('region_id')->constrained()->cascadeOnDelete();
            $table->unsignedInteger('days')->default(7); // How many days to show in this region
            $table->timestamps();

            $table->unique(['classified_id', 'region_id']);
        });

        // Classified payments table
        Schema::create('classified_payments', function (Blueprint $table) {
            $table->id();
            $table->uuid('classified_id')->constrained('classifieds')->cascadeOnDelete();
            $table->foreignUuid('workspace_id')->constrained()->cascadeOnDelete();
            $table->string('stripe_payment_intent_id')->nullable();
            $table->string('stripe_checkout_session_id')->nullable();
            $table->integer('amount'); // in cents
            $table->string('currency', 3)->default('usd');
            $table->enum('status', ['pending', 'paid', 'failed', 'refunded'])->default('pending');
            $table->json('regions_data')->nullable(); // Store region and days info
            $table->unsignedInteger('total_days')->default(7);
            $table->timestamps();

            $table->index('classified_id');
            $table->index('workspace_id');
            $table->index('stripe_checkout_session_id');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('classified_payments');
        Schema::dropIfExists('classified_region');
        Schema::dropIfExists('classified_images');
        Schema::dropIfExists('classifieds');
    }
};

```

### 2025_01_15_000009_create_coupons_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('coupons', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->foreignUuid('business_id')->nullable()->constrained('businesses')->nullOnDelete();
            $table->string('title');
            $table->text('description')->nullable();
            $table->enum('discount_type', ['percentage', 'fixed_amount', 'buy_one_get_one', 'free_item'])->default('percentage');
            $table->decimal('discount_value', 10, 2)->nullable(); // Percentage or fixed amount
            $table->text('terms')->nullable();
            $table->string('code')->unique()->nullable(); // Optional coupon code
            $table->string('image')->nullable();
            $table->string('business_name');
            $table->string('business_location')->nullable();
            $table->date('start_date');
            $table->date('end_date');
            $table->unsignedInteger('usage_limit')->nullable(); // Max number of uses
            $table->unsignedInteger('used_count')->default(0);
            $table->enum('status', ['draft', 'active', 'expired', 'disabled'])->default('draft');
            $table->unsignedInteger('views_count')->default(0);
            $table->unsignedInteger('clicks_count')->default(0);
            $table->timestamps();

            $table->index(['status', 'start_date', 'end_date']);
            $table->index(['business_id', 'status']);
            $table->index('code');
            $table->index('end_date');
        });

        // Coupon regions pivot table
        Schema::create('coupon_region', function (Blueprint $table) {
            $table->id();
            $table->uuid('coupon_id')->constrained('coupons')->cascadeOnDelete();
            $table->foreignUuid('region_id')->constrained()->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['coupon_id', 'region_id']);
        });

        // Coupon usage tracking
        Schema::create('coupon_usages', function (Blueprint $table) {
            $table->id();
            $table->uuid('coupon_id')->constrained('coupons')->cascadeOnDelete();
            $table->foreignUuid('user_id')->nullable()->constrained('users')->nullOnDelete();
            $table->string('ip_address')->nullable();
            $table->timestamps();

            $table->index(['coupon_id', 'created_at']);
            $table->index('user_id');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('coupon_usages');
        Schema::dropIfExists('coupon_region');
        Schema::dropIfExists('coupons');
    }
};

```

### 2025_01_15_000010_create_photos_tables.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('photo_albums', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->foreignUuid('workspace_id')->nullable()->constrained()->nullOnDelete();
            $table->string('title');
            $table->text('description')->nullable();
            $table->string('cover_image')->nullable();
            $table->enum('visibility', ['public', 'private', 'community'])->default('public');
            $table->unsignedInteger('photos_count')->default(0);
            $table->unsignedInteger('views_count')->default(0);
            $table->timestamps();

            $table->index(['user_id', 'visibility']);
            $table->index('created_at');
        });

        Schema::create('photos', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->uuid('album_id')->nullable()->constrained('photo_albums')->nullOnDelete();
            $table->string('title');
            $table->text('description')->nullable();
            $table->string('image_path');
            $table->string('image_disk')->default('public');
            $table->string('thumbnail_path')->nullable();
            $table->string('category')->nullable(); // Nature, Events, Recreation, Community, Sports, etc.
            $table->enum('status', ['pending', 'approved', 'rejected'])->default('pending');
            $table->unsignedInteger('width')->nullable();
            $table->unsignedInteger('height')->nullable();
            $table->unsignedBigInteger('file_size')->nullable(); // in bytes
            $table->unsignedInteger('views_count')->default(0);
            $table->unsignedInteger('likes_count')->default(0);
            $table->unsignedInteger('comments_count')->default(0);
            $table->timestamps();

            $table->index(['user_id', 'status']);
            $table->index(['album_id', 'created_at']);
            $table->index(['category', 'status']);
            $table->index('created_at');
        });

        Schema::create('photo_album_photo', function (Blueprint $table) {
            $table->id();
            $table->uuid('album_id')->constrained('photo_albums')->cascadeOnDelete();
            $table->uuid('photo_id')->constrained('photos')->cascadeOnDelete();
            $table->unsignedInteger('order')->default(0);
            $table->timestamps();

            $table->unique(['album_id', 'photo_id']);
            $table->index(['album_id', 'order']);
        });

        Schema::create('photo_region', function (Blueprint $table) {
            $table->id();
            $table->uuid('photo_id')->constrained('photos')->cascadeOnDelete();
            $table->foreignUuid('region_id')->constrained()->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['photo_id', 'region_id']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('photo_region');
        Schema::dropIfExists('photo_album_photo');
        Schema::dropIfExists('photos');
        Schema::dropIfExists('photo_albums');
    }
};

```

### 2025_01_15_000011_add_author_fields_to_users_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::table('users', function (Blueprint $table) {
            // Check if columns already exist
            if (Schema::hasColumn('users', 'bio')) {
                return;
            }
            $table->text('bio')->nullable()->after('email');
            $table->string('author_slug')->nullable()->unique()->after('bio');
            $table->decimal('trust_score', 5, 2)->default(0.00)->after('author_slug');
            $table->enum('trust_tier', ['bronze', 'silver', 'gold', 'platinum'])->nullable()->after('trust_score');
            $table->boolean('is_verified_author')->default(false)->after('trust_tier');
            $table->json('author_metadata')->nullable()->after('is_verified_author');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('users', function (Blueprint $table) {
            $table->dropColumn([
                'bio',
                'author_slug',
                'trust_score',
                'trust_tier',
                'is_verified_author',
                'author_metadata',
            ]);
        });
    }
};

```

### 2025_01_15_000012_create_legal_notices_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('legal_notices', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->nullable()->constrained('users')->nullOnDelete();
            $table->foreignUuid('workspace_id')->nullable()->constrained()->nullOnDelete();
            $table->enum('type', [
                'foreclosure',
                'probate',
                'name_change',
                'business_formation',
                'public_hearing',
                'zoning',
                'tax_sale',
                'other',
            ]);
            $table->string('case_number')->nullable();
            $table->string('title');
            $table->text('content');
            $table->string('court')->nullable();
            $table->date('publish_date');
            $table->date('expiry_date')->nullable();
            $table->enum('status', ['active', 'expires_soon', 'expired', 'removed'])->default('active');
            $table->json('metadata')->nullable(); // Store additional case-specific data
            $table->unsignedInteger('views_count')->default(0);
            $table->timestamps();

            $table->index(['type', 'status']);
            $table->index(['status', 'publish_date']);
            $table->index(['publish_date', 'expiry_date']);
            $table->index('case_number');
        });

        Schema::create('legal_notice_region', function (Blueprint $table) {
            $table->id();
            $table->uuid('legal_notice_id')->constrained('legal_notices')->cascadeOnDelete();
            $table->foreignUuid('region_id')->constrained()->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['legal_notice_id', 'region_id']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('legal_notice_region');
        Schema::dropIfExists('legal_notices');
    }
};

```

### 2025_01_15_000013_create_memorials_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('memorials', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->foreignUuid('workspace_id')->nullable()->constrained()->nullOnDelete();
            $table->string('name');
            $table->string('years'); // e.g., "1932 - 2023"
            $table->date('date_of_passing');
            $table->text('obituary');
            $table->string('image')->nullable();
            $table->string('location')->nullable();
            $table->date('service_date')->nullable();
            $table->string('service_location')->nullable();
            $table->text('service_details')->nullable();
            $table->boolean('is_featured')->default(false);
            $table->enum('status', ['draft', 'published', 'removed'])->default('draft');
            $table->timestamp('published_at')->nullable();
            $table->unsignedInteger('views_count')->default(0);
            $table->unsignedInteger('reactions_count')->default(0);
            $table->unsignedInteger('comments_count')->default(0);
            $table->timestamps();

            $table->index(['status', 'published_at']);
            $table->index(['date_of_passing', 'status']);
            $table->index('is_featured');
        });

        Schema::create('memorial_region', function (Blueprint $table) {
            $table->id();
            $table->uuid('memorial_id')->constrained('memorials')->cascadeOnDelete();
            $table->foreignUuid('region_id')->constrained()->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['memorial_id', 'region_id']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('memorial_region');
        Schema::dropIfExists('memorials');
    }
};

```

### 2025_01_15_000014_create_podcasts_tables.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('creator_profiles', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->string('display_name');
            $table->string('slug')->unique();
            $table->text('bio')->nullable();
            $table->string('avatar')->nullable();
            $table->string('cover_image')->nullable();
            $table->json('social_links')->nullable(); // Twitter, Instagram, etc.
            $table->enum('status', ['pending', 'approved', 'rejected', 'suspended'])->default('pending');
            $table->unsignedInteger('followers_count')->default(0);
            $table->unsignedInteger('podcasts_count')->default(0);
            $table->unsignedInteger('episodes_count')->default(0);
            $table->unsignedInteger('total_listens')->default(0);
            $table->timestamps();

            $table->index(['status', 'created_at']);
            $table->index('slug');
        });

        Schema::create('podcasts', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('creator_profile_id')->constrained('creator_profiles')->cascadeOnDelete();
            $table->string('title');
            $table->string('slug')->unique();
            $table->text('description')->nullable();
            $table->string('cover_image')->nullable();
            $table->string('category')->nullable();
            $table->enum('status', ['draft', 'published', 'archived'])->default('draft');
            $table->timestamp('published_at')->nullable();
            $table->unsignedInteger('episodes_count')->default(0);
            $table->unsignedInteger('subscribers_count')->default(0);
            $table->unsignedInteger('total_listens')->default(0);
            $table->unsignedInteger('total_duration')->default(0); // in seconds
            $table->timestamps();

            $table->index(['creator_profile_id', 'status']);
            $table->index(['status', 'published_at']);
            $table->index('slug');
        });

        Schema::create('podcast_episodes', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('podcast_id')->constrained('podcasts')->cascadeOnDelete();
            $table->string('title');
            $table->string('slug')->unique();
            $table->text('description')->nullable();
            $table->text('show_notes')->nullable();
            $table->string('audio_file_path');
            $table->string('audio_file_disk')->default('public');
            $table->unsignedInteger('duration')->nullable(); // in seconds
            $table->unsignedBigInteger('file_size')->nullable(); // in bytes
            $table->string('episode_number')->nullable();
            $table->enum('status', ['draft', 'published', 'archived'])->default('draft');
            $table->timestamp('published_at')->nullable();
            $table->unsignedInteger('listens_count')->default(0);
            $table->unsignedInteger('downloads_count')->default(0);
            $table->unsignedInteger('likes_count')->default(0);
            $table->unsignedInteger('comments_count')->default(0);
            $table->timestamps();

            $table->index(['podcast_id', 'status']);
            $table->index(['status', 'published_at']);
            $table->index('slug');
        });

        Schema::create('podcast_region', function (Blueprint $table) {
            $table->id();
            $table->uuid('podcast_id')->constrained('podcasts')->cascadeOnDelete();
            $table->foreignUuid('region_id')->constrained()->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['podcast_id', 'region_id']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('podcast_region');
        Schema::dropIfExists('podcast_episodes');
        Schema::dropIfExists('podcasts');
        Schema::dropIfExists('creator_profiles');
    }
};

```

### 2025_05_03_144545_create_social_accounts_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('social_accounts', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained('users', 'id')->onDelete('cascade');
            $table->string('provider');
            $table->string('provider_id')->unique();
            $table->string('name')->nullable();
            $table->longText('token')->nullable();
            $table->longText('refresh_token')->nullable();
            $table->longText('avatar')->nullable();
            $table->longText('code')->nullable();
            $table->timestamp('expires_at')->nullable();
            $table->timestamps();

            $table->index(['provider', 'user_id', 'provider_id', 'expires_at']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('social_accounts');
    }
};
```

### 2025_05_03_154707_create_workspaces_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('workspaces', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('owner_id')->constrained('users', 'id');
            $table->string('name');
            $table->string('slug')->unique();
            $table->longText('logo')->nullable();
            $table->string('timezone')->default('UTC');
            $table->string('stripe_connect_id')->nullable()->unique();
            $table->boolean('stripe_charges_enabled')->default(false);
            $table->boolean('stripe_payouts_enabled')->default(false);
            $table->boolean('stripe_admin_approved')->default(false);
            $table->timestamps();

            $table->index(['owner_id']);
        });

        Schema::table('users', function (Blueprint $table) {
            $table->foreignUuid('current_workspace_id')->nullable()->constrained('workspaces');
        });

        Schema::create('roles', function (Blueprint $table) {
            $table->text('name')->primary();
            $table->timestamps();
        });

        Schema::create('workspace_memberships', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('workspace_id')->constrained('workspaces');
            $table->foreignUuid('user_id')->constrained('users');
            $table->text('role');
            $table->foreign('role')->references('name')->on('roles');
            $table->timestamps();

            $table->index(['workspace_id', 'user_id', 'role']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('workspaces');
        Schema::dropIfExists('roles');
        Schema::dropIfExists('workspace_memberships');

        Schema::table('users', function (Blueprint $table) {
            $table->dropConstrainedForeignId('current_workspace_id');
        });
    }
};
```

### 2025_05_07_230832_create_default_roles.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Support\Facades\DB;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        DB::table('roles')->insert([
            ['name' => 'owner'],
            ['name' => 'admin'],
            ['name' => 'member'],
        ]);
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        DB::table('roles')->whereIn('name', ['owner', 'admin', 'member'])->delete();
    }
};
```

### 2025_07_16_171440_create_workspace_invitations_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('workspace_invitations', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('workspace_id')->constrained('workspaces')->cascadeOnDelete();
            $table->foreignUuid('invited_by')->nullable()->constrained('users', 'id')->nullOnDelete();
            $table->string('email');
            $table->string('role');
            $table->string('token')->unique();
            $table->timestamp('expires_at');
            $table->timestamp('accepted_at')->nullable();
            $table->timestamps();

            $table->foreign('role')->references('name')->on('roles');
            $table->index(['email', 'workspace_id']);
            $table->index(['token']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('workspace_invitations');
    }
};
```

### 2025_08_22_192832_create_credits_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up()
    {
        Schema::create('credits', function (Blueprint $table) {
            $table->id();
            $table->uuidMorphs('creditable');
            $table->decimal('amount', 10, 2);
            $table->decimal('running_balance', 10, 2);
            $table->string('description', 255)->nullable();
            $table->string('type');
            $table->json('metadata')->nullable();
            $table->timestamps();
            $table->softDeletes();

            $table->index('type');
            $table->index('created_at');
            $table->index(['creditable_id', 'creditable_type', 'created_at']);
            $table->index(['creditable_id', 'creditable_type', 'running_balance']);
            $table->index(['creditable_id', 'creditable_type', 'deleted_at']);
        });
    }

    public function down()
    {
        Schema::dropIfExists('credits');
    }
};
```

### 2025_09_15_160356_create_venues_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('venues', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('name');
            $table->text('description');
            $table->json('images')->nullable(); // Array of image URLs
            $table->boolean('verified')->default(false);
            $table->string('venue_type');
            $table->integer('capacity');

            // Pricing structure
            $table->decimal('price_per_hour', 10, 2);
            $table->decimal('price_per_event', 10, 2);
            $table->decimal('price_per_day', 10, 2);

            // Rating and reviews (computed from separate models)
            $table->decimal('average_rating', 3, 2)->default(0);
            $table->integer('total_reviews')->default(0);

            // Location information
            $table->string('address');
            $table->string('neighborhood')->nullable();
            $table->decimal('latitude', 10, 8)->nullable();
            $table->decimal('longitude', 11, 8)->nullable();
            $table->string('google_place_id')->nullable()->index();
            $table->string('postal_code')->nullable();

            // Additional venue information
            $table->json('amenities')->nullable(); // Array of amenities
            $table->json('event_types')->nullable(); // Array of supported event types
            $table->json('unavailable_dates')->nullable(); // Array of unavailable dates
            $table->integer('last_booked_days_ago')->nullable();
            $table->integer('response_time_hours')->default(24);
            $table->date('listed_date')->nullable();

            // Status and ownership - workspace-centric
            $table->enum('status', ['active', 'inactive', 'pending', 'suspended'])->default('active');
            $table->foreignUuid('workspace_id')->constrained('workspaces')->onDelete('cascade');
            $table->foreignUuid('created_by')->nullable()->constrained('users')->onDelete('set null');

            $table->timestamps();

            // Indexes
            $table->index(['venue_type', 'status']);
            $table->index(['latitude', 'longitude']);
            $table->index('capacity');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('venues');
    }
};
```

### 2025_09_15_160414_create_performers_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('performers', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('name');
            $table->string('profile_image')->nullable();
            $table->json('genres'); // Array of genres
            $table->decimal('average_rating', 3, 2)->default(0);
            $table->integer('total_reviews')->default(0);
            $table->integer('follower_count')->default(0);
            $table->text('bio')->nullable();
            $table->integer('years_active')->default(0);
            $table->integer('shows_played')->default(0);
            $table->string('home_city');

            // Performer capabilities and status
            $table->boolean('is_verified')->default(false);
            $table->boolean('is_touring_now')->default(false);
            $table->boolean('available_for_booking')->default(true);
            $table->boolean('has_merchandise')->default(false);
            $table->boolean('has_original_music')->default(false);
            $table->boolean('offers_meet_and_greet')->default(false);
            $table->boolean('takes_requests')->default(false);
            $table->boolean('available_for_private_events')->default(true);
            $table->boolean('is_family_friendly')->default(true);
            $table->boolean('has_samples')->default(false);

            // Performance metrics
            $table->integer('trending_score')->default(0);
            $table->decimal('distance_miles', 8, 2)->nullable();
            $table->date('added_date')->nullable();
            $table->boolean('introductory_pricing')->default(false);

            // Pricing structure
            $table->decimal('base_price', 10, 2)->nullable();
            $table->string('currency', 3)->default('USD');
            $table->integer('minimum_booking_hours')->default(1);
            $table->decimal('travel_fee_per_mile', 8, 2)->nullable();
            $table->decimal('setup_fee', 10, 2)->nullable();
            $table->text('cancellation_policy')->nullable();

            // Account information - workspace-centric
            $table->enum('status', ['active', 'inactive', 'pending', 'suspended'])->default('active');
            $table->foreignUuid('workspace_id')->constrained('workspaces')->onDelete('cascade');
            $table->foreignUuid('created_by')->nullable()->constrained('users')->onDelete('set null');

            $table->timestamps();

            // Indexes
            $table->index(['status', 'available_for_booking']);
            $table->index('trending_score');
            $table->index('home_city');
            $table->index('is_verified');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('performers');
    }
};
```

### 2025_09_15_160428_create_events_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('events', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('title');
            $table->string('image')->nullable();
            $table->dateTime('event_date');
            $table->string('time');
            $table->text('description');

            // Event organization
            $table->json('badges')->nullable(); // Array of badges
            $table->json('subcategories')->nullable(); // Array of subcategories
            $table->string('category')->nullable();

            // Pricing
            $table->boolean('is_free')->default(false);
            $table->decimal('price_min', 10, 2)->default(0);
            $table->decimal('price_max', 10, 2)->default(0);

            // Community and engagement
            $table->decimal('community_rating', 3, 2)->default(0);
            $table->integer('member_attendance')->default(0);
            $table->integer('member_recommendations')->default(0);
            $table->string('discussion_thread_id')->nullable();
            $table->text('curator_notes')->nullable();

            // Location
            $table->decimal('latitude', 10, 8)->nullable();
            $table->decimal('longitude', 11, 8)->nullable();
            $table->string('google_place_id')->nullable()->index();
            $table->string('postal_code')->nullable();

            // Relationships - workspace-centric
            $table->foreignUuid('venue_id')->nullable()->constrained('venues')->onDelete('set null');
            $table->foreignUuid('performer_id')->nullable()->constrained('performers')->onDelete('set null');
            $table->foreignUuid('workspace_id')->constrained('workspaces')->onDelete('cascade');
            $table->foreignUuid('created_by')->nullable()->constrained('users')->onDelete('set null'); // Event creator

            // Event status
            $table->enum('status', ['draft', 'published', 'cancelled', 'completed'])->default('draft');

            $table->timestamps();

            // Indexes
            $table->index(['status', 'event_date']);
            $table->index(['venue_id', 'event_date']);
            $table->index(['performer_id', 'event_date']);
            $table->index('category');
            $table->index('community_rating');
            $table->index(['latitude', 'longitude']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('events');
    }
};
```

### 2025_09_15_160437_create_bookings_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('bookings', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('booking_number')->unique();
            $table->enum('status', ['pending', 'confirmed', 'cancelled', 'completed', 'rejected', 'refunded'])->default('pending');
            $table->enum('booking_type', ['event', 'venue', 'performer']);

            // Booking relationships (polymorphic-like but explicit) - workspace-centric
            $table->foreignUuid('event_id')->nullable()->constrained('events')->onDelete('cascade');
            $table->foreignUuid('venue_id')->nullable()->constrained('venues')->onDelete('cascade');
            $table->foreignUuid('performer_id')->nullable()->constrained('performers')->onDelete('cascade');
            $table->foreignUuid('workspace_id')->constrained('workspaces')->onDelete('cascade');
            $table->foreignUuid('created_by')->nullable()->constrained('users')->onDelete('set null');

            // Contact information
            $table->string('contact_name');
            $table->string('contact_email');
            $table->string('contact_phone')->nullable();
            $table->string('contact_company')->nullable();

            // Event details (for venue and performer bookings)
            $table->date('event_date')->nullable();
            $table->time('start_time')->nullable();
            $table->time('end_time')->nullable();
            $table->string('event_type')->nullable();
            $table->integer('expected_guests')->nullable();
            $table->integer('expected_audience')->nullable(); // For performer bookings

            // Event booking specific fields
            $table->integer('ticket_quantity')->nullable();
            $table->string('ticket_type')->nullable();
            $table->decimal('price_per_ticket', 10, 2)->nullable();

            // Payment information
            $table->enum('payment_status', ['pending', 'paid', 'partially_paid', 'failed', 'refunded', 'cancelled'])->default('pending');
            $table->decimal('total_amount', 10, 2);
            $table->string('currency', 3)->default('USD');
            $table->decimal('paid_amount', 10, 2)->default(0);
            $table->string('payment_method')->nullable();
            $table->string('transaction_id')->nullable();
            $table->timestamp('payment_date')->nullable();
            $table->decimal('refund_amount', 10, 2)->default(0);
            $table->timestamp('refund_date')->nullable();

            // Additional information
            $table->text('notes')->nullable();
            $table->json('special_requests')->nullable();
            $table->json('setup_requirements')->nullable(); // For venue bookings
            $table->json('catering_requirements')->nullable(); // For venue bookings
            $table->json('performance_requirements')->nullable(); // For performer bookings
            $table->json('sound_requirements')->nullable(); // For performer bookings

            // Status timestamps
            $table->timestamp('confirmed_at')->nullable();
            $table->timestamp('cancelled_at')->nullable();
            $table->string('cancellation_reason')->nullable();

            $table->timestamps();

            // Indexes
            $table->index(['booking_type', 'status']);
            $table->index(['event_date', 'status']);
            $table->index('payment_status');
            $table->index('contact_email');
            $table->index(['venue_id', 'event_date']);
            $table->index(['performer_id', 'event_date']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('bookings');
    }
};
```

### 2025_09_15_160601_create_upcoming_shows_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('upcoming_shows', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('performer_id')->constrained('performers')->onDelete('cascade');
            $table->date('date');
            $table->string('venue');
            $table->boolean('tickets_available')->default(true);
            $table->string('ticket_url')->nullable();
            $table->decimal('ticket_price', 10, 2)->nullable();
            $table->text('description')->nullable();
            $table->timestamps();

            // Indexes
            $table->index(['performer_id', 'date']);
            $table->index('date');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('upcoming_shows');
    }
};
```

### 2025_09_15_163335_create_reviews_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('reviews', function (Blueprint $table) {
            $table->uuid('id')->primary();

            // Polymorphic relationship to any reviewable entity
            $table->uuidMorphs('reviewable'); // reviewable_type, reviewable_id

            // User who wrote the review (not workspace-specific)
            $table->foreignUuid('user_id')->constrained('users')->onDelete('cascade');

            // Review content
            $table->string('title');
            $table->text('content');
            $table->integer('rating')->unsigned(); // 1-5 stars

            // Review metadata
            $table->boolean('is_verified')->default(false);
            $table->boolean('is_featured')->default(false);
            $table->json('helpful_votes')->nullable(); // Array of user IDs who found it helpful
            $table->integer('helpful_count')->default(0);

            // Moderation
            $table->enum('status', ['pending', 'approved', 'rejected', 'hidden'])->default('pending');
            $table->timestamp('approved_at')->nullable();
            $table->foreignUuid('approved_by')->nullable()->constrained('users')->onDelete('set null');
            $table->string('rejection_reason')->nullable();

            $table->timestamps();

            // Indexes
            $table->index(['reviewable_type', 'reviewable_id'], 'reviews_reviewable_idx');
            $table->index(['user_id', 'reviewable_type', 'reviewable_id'], 'reviews_user_reviewable_idx');
            $table->index(['rating', 'status'], 'reviews_rating_status_idx');
            $table->index('status', 'reviews_status_idx');

            // Prevent duplicate reviews from same user for same entity
            $table->unique(['user_id', 'reviewable_type', 'reviewable_id'], 'unique_user_review');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('reviews');
    }
};
```

### 2025_09_15_163344_create_ratings_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('ratings', function (Blueprint $table) {
            $table->uuid('id')->primary();

            // Polymorphic relationship to any ratable entity
            $table->uuidMorphs('ratable'); // ratable_type, ratable_id

            // User who gave the rating (not workspace-specific)
            $table->foreignUuid('user_id')->constrained('users')->onDelete('cascade');

            // Rating value
            $table->integer('rating')->unsigned(); // 1-5 stars

            // Optional context for quick ratings without full reviews
            $table->string('context')->nullable(); // e.g., 'service', 'quality', 'value', 'overall'
            $table->text('notes')->nullable(); // Brief notes

            // Rating source/type
            $table->enum('type', ['booking', 'general', 'event_attendance'])->default('general');
            $table->foreignUuid('booking_id')->nullable()->constrained('bookings')->onDelete('cascade');

            $table->timestamps();

            // Indexes
            $table->index(['ratable_type', 'ratable_id'], 'ratings_ratable_idx');
            $table->index(['user_id', 'ratable_type', 'ratable_id'], 'ratings_user_ratable_idx');
            $table->index(['rating', 'type'], 'ratings_rating_type_idx');
            $table->index('context', 'ratings_context_idx');

            // Prevent duplicate ratings from same user for same entity in same context
            $table->unique(['user_id', 'ratable_type', 'ratable_id', 'context'], 'unique_user_rating');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('ratings');
    }
};
```

### 2025_09_18_153847_create_community_system_tables.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Create communities table
        Schema::create('communities', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('slug')->unique();
            $table->string('name');
            $table->text('description');
            $table->string('image')->nullable();
            $table->json('categories')->nullable();
            $table->json('thread_types')->nullable();
            $table->json('popular_tags')->nullable();
            $table->text('guidelines')->nullable();
            $table->boolean('is_featured')->default(false);
            $table->integer('total_events')->default(0);
            $table->integer('active_today')->default(0);
            $table->timestamp('last_activity')->nullable();
            $table->boolean('is_active')->default(true);
            $table->foreignUuid('workspace_id')->constrained()->cascadeOnDelete();
            $table->foreignUuid('created_by')->constrained('users')->cascadeOnDelete();
            $table->timestamps();
        });

        // Create community_threads table
        Schema::create('community_threads', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('title');
            $table->text('content');
            $table->text('preview')->nullable();
            $table->string('type'); // Discussion, Question, Announcement, Resource, Event
            $table->json('tags')->nullable();
            $table->json('images')->nullable();
            $table->boolean('is_pinned')->default(false);
            $table->boolean('is_locked')->default(false);
            $table->boolean('is_featured')->default(false);
            $table->timestamp('last_reply_at')->nullable();
            $table->foreignUuid('last_reply_by')->nullable()->constrained('users')->nullOnDelete();
            $table->foreignUuid('community_id')->constrained()->cascadeOnDelete();
            $table->foreignUuid('author_id')->constrained('users')->cascadeOnDelete();
            $table->timestamps();

            // Indexes for performance
            $table->index(['community_id', 'created_at']);
            $table->index(['community_id', 'type']);
            $table->index(['community_id', 'is_pinned']);
        });

        // Create community_thread_views table
        Schema::create('community_thread_views', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('thread_id')->constrained('community_threads')->cascadeOnDelete();
            $table->foreignUuid('user_id')->nullable()->constrained('users')->nullOnDelete(); // Nullable for guest views
            $table->string('session_id')->nullable(); // For tracking guest views
            $table->timestamp('viewed_at')->useCurrent();
            $table->timestamps();

            // Remove the combined unique constraint
            // $table->unique(['thread_id', 'user_id', 'session_id']);
            $table->index(['thread_id', 'viewed_at']);
        });

        // Add conditional unique constraints after table creation
        Schema::table('community_thread_views', function (Blueprint $table) {
            $table->unique(['thread_id', 'user_id'])->whereNotNull('user_id');
            $table->unique(['thread_id', 'session_id'])->whereNotNull('session_id');
        });

        // Create community_members table
        Schema::create('community_members', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('community_id')->constrained()->cascadeOnDelete();
            $table->foreignUuid('user_id')->constrained()->cascadeOnDelete();
            $table->enum('role', ['member', 'moderator', 'admin'])->default('member');
            $table->timestamp('joined_at')->useCurrent();
            $table->boolean('is_active')->default(true);
            $table->timestamp('last_activity_at')->nullable();
            $table->timestamps();

            // Prevent duplicate memberships
            $table->unique(['community_id', 'user_id']);

            // Indexes for performance
            $table->index(['community_id', 'is_active']);
            $table->index(['user_id', 'is_active']);
            $table->index('last_activity_at');
        });

        // Create community_thread_replies table
        Schema::create('community_thread_replies', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('thread_id')->constrained('community_threads')->cascadeOnDelete();
            $table->foreignUuid('user_id')->constrained()->cascadeOnDelete();
            $table->text('content');
            $table->json('images')->nullable();
            $table->boolean('is_solution')->default(false); // For question threads
            $table->boolean('is_pinned')->default(false);
            $table->boolean('is_edited')->default(false);
            $table->timestamp('edited_at')->nullable();
            $table->uuid('reply_to_id')->nullable(); // Define the column first
            $table->timestamps();

            // Indexes for performance
            $table->index(['thread_id', 'created_at']);
            $table->index(['thread_id', 'is_pinned']);
            $table->index(['thread_id', 'is_solution']);
            $table->index(['user_id', 'created_at']);
            $table->index('reply_to_id');
        });

        // Create community_thread_reply_likes table
        Schema::create('community_thread_reply_likes', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('reply_id')->constrained('community_thread_replies')->cascadeOnDelete();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['reply_id', 'user_id']); // Prevent duplicate likes
        });

        // Add the self-referencing foreign key constraint after the table is created for PostgreSQL compatibility
        Schema::table('community_thread_replies', function (Blueprint $table) {
            $table->foreign('reply_to_id')
                ->references('id')
                ->on('community_thread_replies')
                ->nullOnDelete();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop the foreign key before dropping the table
        Schema::table('community_thread_replies', function (Blueprint $table) {
            $table->dropForeign(['community_thread_replies_reply_to_id_foreign']);
        });

        Schema::dropIfExists('community_thread_reply_likes');
        Schema::dropIfExists('community_thread_replies');
        Schema::dropIfExists('community_members');

        // Drop conditional unique constraints
        Schema::table('community_thread_views', function (Blueprint $table) {
            $table->dropUnique(['thread_id', 'user_id']);
            $table->dropUnique(['thread_id', 'session_id']);
        });

        Schema::dropIfExists('community_threads');
        Schema::dropIfExists('community_thread_views');
        Schema::dropIfExists('communities');
    }
};
```

### 2025_09_23_191514_create_social_features_tables.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Social posts table
        Schema::create('social_posts', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained()->cascadeOnDelete();
            $table->text('content');
            $table->json('media')->nullable(); // Store image/video URLs
            $table->enum('visibility', ['public', 'friends', 'private'])->default('public');
            $table->json('location')->nullable(); // Store location data
            $table->boolean('is_active')->default(true);
            $table->timestamps();

            $table->index(['user_id', 'created_at']);
            $table->index(['visibility', 'is_active', 'created_at']);
        });

        // Post likes table
        Schema::create('social_post_likes', function (Blueprint $table) {
            $table->id();
            $table->foreignUuid('post_id')->constrained('social_posts')->cascadeOnDelete();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['post_id', 'user_id']);
            $table->index(['post_id', 'created_at']);
        });

        // Post comments table
        Schema::create('social_post_comments', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('post_id')->constrained('social_posts')->cascadeOnDelete();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->uuid('parent_id')->nullable();
            $table->text('content');
            $table->boolean('is_active')->default(true);
            $table->timestamps();

            $table->index(['post_id', 'parent_id', 'created_at']);
            $table->index(['user_id', 'created_at']);
        });

        // Add self-referencing foreign key after table creation
        Schema::table('social_post_comments', function (Blueprint $table) {
            $table->foreign('parent_id')->references('id')->on('social_post_comments')->onDelete('cascade');
        });

        // Comment likes table
        Schema::create('social_comment_likes', function (Blueprint $table) {
            $table->id();
            $table->foreignUuid('comment_id')->constrained('social_post_comments')->cascadeOnDelete();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['comment_id', 'user_id']);
        });

        // Post shares table
        Schema::create('social_post_shares', function (Blueprint $table) {
            $table->id();
            $table->foreignUuid('post_id')->constrained('social_posts')->cascadeOnDelete();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->text('message')->nullable(); // Optional message when sharing
            $table->timestamps();

            $table->index(['post_id', 'created_at']);
            $table->index(['user_id', 'created_at']);
        });

        // Friends/connections table
        Schema::create('social_friendships', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->foreignUuid('friend_id')->constrained('users')->cascadeOnDelete();
            $table->enum('status', ['pending', 'accepted', 'blocked'])->default('pending');
            $table->timestamp('requested_at')->useCurrent();
            $table->timestamp('responded_at')->nullable();
            $table->timestamps();

            $table->unique(['user_id', 'friend_id']);
            $table->index(['user_id', 'status']);
            $table->index(['friend_id', 'status']);
        });

        // Social groups table
        Schema::create('social_groups', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('name');
            $table->text('description')->nullable();
            $table->string('cover_image')->nullable();
            $table->foreignUuid('creator_id')->constrained('users')->cascadeOnDelete();
            $table->enum('privacy', ['public', 'private', 'secret'])->default('public');
            $table->boolean('is_active')->default(true);
            $table->json('settings')->nullable(); // Group-specific settings
            $table->timestamps();

            $table->index(['privacy', 'is_active', 'created_at']);
            $table->index(['creator_id', 'created_at']);
        });

        // Group memberships table
        Schema::create('social_group_members', function (Blueprint $table) {
            $table->id();
            $table->foreignUuid('group_id')->constrained('social_groups')->cascadeOnDelete();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->enum('role', ['admin', 'moderator', 'member'])->default('member');
            $table->enum('status', ['pending', 'approved', 'banned'])->default('approved');
            $table->timestamp('joined_at')->useCurrent();
            $table->timestamps();

            $table->unique(['group_id', 'user_id']);
            $table->index(['group_id', 'status', 'role']);
            $table->index(['user_id', 'status']);
        });

        // Group posts table
        Schema::create('social_group_posts', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('group_id')->constrained('social_groups')->cascadeOnDelete();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->text('content');
            $table->json('media')->nullable();
            $table->boolean('is_pinned')->default(false);
            $table->boolean('is_active')->default(true);
            $table->timestamps();

            $table->index(['group_id', 'is_pinned', 'created_at']);
            $table->index(['user_id', 'created_at']);
        });

        // User profiles table (extended social profile info)
        Schema::create('social_user_profiles', function (Blueprint $table) {
            $table->id();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->text('bio')->nullable();
            $table->string('website')->nullable();
            $table->string('location')->nullable();
            $table->date('birth_date')->nullable();
            $table->enum('profile_visibility', ['public', 'friends', 'private'])->default('public');
            $table->json('interests')->nullable(); // Array of interests/hobbies
            $table->string('cover_photo')->nullable();
            $table->json('social_links')->nullable(); // Links to other social platforms
            $table->boolean('show_email')->default(false);
            $table->boolean('show_location')->default(true);
            $table->timestamps();

            $table->unique('user_id');
        });

        // User followers table (for public profile following)
        Schema::create('social_user_follows', function (Blueprint $table) {
            $table->id();
            $table->foreignUuid('follower_id')->constrained('users')->cascadeOnDelete();
            $table->foreignUuid('following_id')->constrained('users')->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['follower_id', 'following_id']);
            $table->index(['follower_id', 'created_at']);
            $table->index(['following_id', 'created_at']);
        });

        // Group invitations table
        Schema::create('social_group_invitations', function (Blueprint $table) {
            $table->id();
            $table->foreignUuid('group_id')->constrained('social_groups')->cascadeOnDelete();
            $table->foreignUuid('inviter_id')->constrained('users')->cascadeOnDelete();
            $table->foreignUuid('invited_id')->constrained('users')->cascadeOnDelete();
            $table->string('message')->nullable();
            $table->enum('status', ['pending', 'accepted', 'declined'])->default('pending');
            $table->timestamp('expires_at')->nullable();
            $table->timestamps();

            $table->unique(['group_id', 'invited_id']);
            $table->index(['invited_id', 'status']);
            $table->index(['group_id', 'status']);
        });

        // Activity feed/notifications table
        Schema::create('social_activities', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete(); // User who will see this activity
            $table->foreignUuid('actor_id')->constrained('users')->cascadeOnDelete(); // User who performed the action
            $table->enum('type', [
                'post_like', 'post_comment', 'post_share',
                'friend_request', 'friend_accept',
                'group_invite', 'group_join', 'group_post',
                'profile_follow',
            ]);
            $table->string('subject_type');
            $table->uuid('subject_id'); // The thing that was acted upon (post, comment, etc.)
            $table->index(['subject_type', 'subject_id']);
            $table->json('data')->nullable(); // Additional data specific to the activity type
            $table->boolean('is_read')->default(false);
            $table->timestamps();

            $table->index(['user_id', 'is_read', 'created_at']);
            $table->index(['actor_id', 'created_at']);
            $table->index(['type', 'created_at']);
        });

        // Add social-related columns to users table
        Schema::table('users', function (Blueprint $table) {
            $table->boolean('is_private_profile')->default(false);
            $table->boolean('allow_friend_requests')->default(true);
            $table->boolean('allow_group_invites')->default(true);
            $table->timestamp('last_active_at')->nullable();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop tables in reverse order to handle foreign key constraints
        Schema::dropIfExists('social_activities');
        Schema::dropIfExists('social_group_invitations');
        Schema::dropIfExists('social_user_follows');
        Schema::dropIfExists('social_user_profiles');
        Schema::dropIfExists('social_group_posts');
        Schema::dropIfExists('social_group_members');
        Schema::dropIfExists('social_groups');
        Schema::dropIfExists('social_friendships');
        Schema::dropIfExists('social_post_shares');
        Schema::dropIfExists('social_comment_likes');
        Schema::dropIfExists('social_post_comments');
        Schema::dropIfExists('social_post_likes');
        Schema::dropIfExists('social_posts');

        // Remove columns from users table
        Schema::table('users', function (Blueprint $table) {
            $table->dropColumn([
                'is_private_profile',
                'allow_friend_requests',
                'allow_group_invites',
                'last_active_at',
            ]);
        });
    }
};
```

### 2025_09_25_124919_create_notifications_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('notifications', function (Blueprint $table) {
            $table->id();
            $table->uuid('user_id');
            $table->string('type');
            $table->json('data');
            $table->boolean('read')->default(false);
            $table->string('title');
            $table->text('message');
            $table->string('action_url')->nullable();
            $table->timestamps();

            $table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');
            $table->index(['user_id', 'read']);
            $table->index('created_at');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('notifications');
    }
};
```

### 2025_09_25_135743_create_messaging_system.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Create conversations table
        Schema::create('conversations', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('type')->default('private'); // private, group
            $table->string('title')->nullable(); // For group conversations
            $table->json('metadata')->nullable(); // For additional conversation data
            $table->timestamp('last_message_at')->nullable();
            $table->timestamps();

            $table->index(['type', 'last_message_at']);
        });

        // Create conversation_participants table
        Schema::create('conversation_participants', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('conversation_id');
            $table->uuid('user_id');
            $table->timestamp('joined_at');
            $table->timestamp('last_read_at')->nullable();
            $table->boolean('is_admin')->default(false);
            $table->timestamps();

            $table->foreign('conversation_id')->references('id')->on('conversations')->onDelete('cascade');
            $table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');

            $table->unique(['conversation_id', 'user_id']);
            $table->index(['user_id', 'last_read_at']);
        });

        // Create messages table
        Schema::create('messages', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('conversation_id');
            $table->uuid('sender_id');
            $table->text('content');
            $table->string('type')->default('text'); // text, image, file, system
            $table->json('metadata')->nullable(); // For file attachments, system message data, etc.
            $table->timestamp('edited_at')->nullable();
            $table->timestamps();

            $table->foreign('conversation_id')->references('id')->on('conversations')->onDelete('cascade');
            $table->foreign('sender_id')->references('id')->on('users')->onDelete('cascade');

            $table->index(['conversation_id', 'created_at']);
            $table->index(['sender_id', 'created_at']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('messages');
        Schema::dropIfExists('conversation_participants');
        Schema::dropIfExists('conversations');
    }
};
```

### 2025_09_26_222707_create_ticket_system_tables.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('ticket_plans', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('event_id');
            $table->string('name');
            $table->text('description')->nullable();
            $table->decimal('price', 10, 2);
            $table->integer('max_quantity');
            $table->integer('available_quantity');
            $table->boolean('is_active')->default(true);
            $table->json('metadata')->nullable();
            $table->integer('sort_order')->default(0);
            $table->timestamps();

            $table->foreign('event_id')->references('id')->on('events')->onDelete('cascade');
            $table->index(['event_id', 'is_active']);
        });

        Schema::create('ticket_orders', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('event_id');
            $table->uuid('user_id');
            $table->string('status')->default('pending');
            $table->decimal('subtotal', 10, 2);
            $table->decimal('fees', 10, 2)->default(0);
            $table->decimal('discount', 10, 2)->default(0);
            $table->decimal('total', 10, 2);
            $table->json('promo_code')->nullable();
            $table->json('billing_info')->nullable();
            $table->string('payment_intent_id')->nullable();
            $table->string('payment_status')->default('pending');
            $table->timestamp('completed_at')->nullable();
            $table->timestamps();

            $table->foreign('event_id')->references('id')->on('events')->onDelete('cascade');
            $table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');
            $table->index(['user_id', 'status']);
            $table->index(['event_id', 'status']);
        });

        Schema::create('ticket_order_items', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('ticket_order_id');
            $table->uuid('ticket_plan_id');
            $table->integer('quantity');
            $table->decimal('unit_price', 10, 2);
            $table->decimal('total_price', 10, 2);
            $table->timestamps();

            $table->foreign('ticket_order_id')->references('id')->on('ticket_orders')->onDelete('cascade');
            $table->foreign('ticket_plan_id')->references('id')->on('ticket_plans')->onDelete('cascade');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('ticket_order_items');
        Schema::dropIfExists('ticket_orders');
        Schema::dropIfExists('ticket_plans');
    }
};
```

### 2025_09_30_144841_create_follows_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('follows', function (Blueprint $table) {
            $table->id();
            $table->foreignUuid('user_id')->constrained()->cascadeOnDelete();
            $table->uuidMorphs('followable');
            $table->timestamps();

            $table->unique(['user_id', 'followable_type', 'followable_id']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('follows');
    }
};
```

### 2025_10_02_175440_create_stores_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('stores', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('workspace_id')->constrained()->cascadeOnDelete();
            $table->string('name');
            $table->string('slug')->unique();
            $table->text('description')->nullable();
            $table->string('logo')->nullable();
            $table->string('banner')->nullable();
            $table->string('status')->default('pending'); // pending, approved, rejected, suspended
            $table->text('rejection_reason')->nullable();
            $table->timestamp('approved_at')->nullable();
            $table->timestamps();
            $table->softDeletes();
        });

        Schema::create('products', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('store_id')->constrained()->cascadeOnDelete();
            $table->string('name');
            $table->string('slug');
            $table->text('description')->nullable();
            $table->json('images')->nullable();
            $table->decimal('price', 10, 2);
            $table->decimal('compare_at_price', 10, 2)->nullable();
            $table->integer('quantity')->default(0);
            $table->boolean('track_inventory')->default(true);
            $table->string('sku')->nullable();
            $table->boolean('is_active')->default(true);
            $table->boolean('is_featured')->default(false);
            $table->string('stripe_price_id')->nullable();
            $table->string('stripe_product_id')->nullable();
            $table->json('metadata')->nullable();
            $table->timestamps();
            $table->softDeletes();

            $table->unique(['store_id', 'slug']);
        });

        Schema::create('orders', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('order_number')->unique();
            $table->foreignUuid('store_id')->constrained()->cascadeOnDelete();
            $table->foreignUuid('user_id')->nullable()->constrained()->nullOnDelete();
            $table->string('customer_email');
            $table->string('customer_name')->nullable();
            $table->decimal('subtotal', 10, 2);
            $table->decimal('tax', 10, 2)->default(0);
            $table->decimal('shipping', 10, 2)->default(0);
            $table->decimal('total', 10, 2);
            $table->string('status')->default('pending'); // pending, processing, completed, cancelled, refunded
            $table->string('payment_status')->default('pending'); // pending, paid, failed, refunded
            $table->string('stripe_payment_intent_id')->nullable();
            $table->string('stripe_charge_id')->nullable();
            $table->json('shipping_address')->nullable();
            $table->json('billing_address')->nullable();
            $table->text('notes')->nullable();
            $table->timestamp('paid_at')->nullable();
            $table->timestamps();
            $table->softDeletes();
        });

        Schema::create('order_items', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('order_id')->constrained()->cascadeOnDelete();
            $table->foreignUuid('product_id')->nullable()->constrained()->nullOnDelete();
            $table->string('product_name');
            $table->text('product_description')->nullable();
            $table->decimal('price', 10, 2);
            $table->integer('quantity');
            $table->decimal('total', 10, 2);
            $table->json('metadata')->nullable();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('order_items');
        Schema::dropIfExists('orders');
        Schema::dropIfExists('products');
        Schema::dropIfExists('stores');
    }
};
```

### 2025_10_02_211800_create_carts_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up(): void
    {
        Schema::create('carts', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->nullable()->constrained()->cascadeOnDelete();
            $table->string('session_id')->nullable()->index();
            $table->timestamps();

            $table->index(['user_id', 'session_id']);
        });

        Schema::create('cart_items', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('cart_id')->constrained()->cascadeOnDelete();
            $table->foreignUuid('product_id')->constrained()->cascadeOnDelete();
            $table->foreignUuid('store_id')->constrained()->cascadeOnDelete();
            $table->integer('quantity')->default(1);
            $table->decimal('price', 10, 2);
            $table->timestamps();

            $table->unique(['cart_id', 'product_id']);
        });
    }

    public function down(): void
    {
        Schema::dropIfExists('cart_items');
        Schema::dropIfExists('carts');
    }
};
```

### 2025_10_06_143426_create_calendars_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('calendars', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained()->cascadeOnDelete();
            $table->string('title');
            $table->text('description');
            $table->string('category');
            $table->string('image')->nullable();
            $table->text('about')->nullable();
            $table->string('location')->nullable();
            $table->string('update_frequency')->default('weekly');
            $table->decimal('subscription_price', 10, 2)->default(0);
            $table->boolean('is_private')->default(false);
            $table->boolean('is_verified')->default(false);
            $table->integer('followers_count')->default(0);
            $table->integer('events_count')->default(0);
            $table->timestamps();
        });

        Schema::create('calendar_followers', function (Blueprint $table) {
            $table->id();
            $table->foreignUuid('calendar_id')->constrained()->cascadeOnDelete();
            $table->foreignUuid('user_id')->constrained()->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['calendar_id', 'user_id']);
        });

        Schema::create('calendar_roles', function (Blueprint $table) {
            $table->id();
            $table->foreignUuid('calendar_id')->constrained()->cascadeOnDelete();
            $table->foreignUuid('user_id')->constrained()->cascadeOnDelete();
            $table->string('role')->default('editor');
            $table->timestamps();

            $table->unique(['calendar_id', 'user_id']);
        });

        Schema::create('calendar_events', function (Blueprint $table) {
            $table->id();
            $table->foreignUuid('calendar_id')->constrained()->cascadeOnDelete();
            $table->foreignUuid('event_id')->constrained()->cascadeOnDelete();
            $table->foreignUuid('added_by')->nullable()->constrained('users')->nullOnDelete();
            $table->integer('position')->default(0);
            $table->timestamps();

            $table->unique(['calendar_id', 'event_id']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('calendar_events');
        Schema::dropIfExists('calendar_roles');
        Schema::dropIfExists('calendar_followers');
        Schema::dropIfExists('calendars');
    }
};
```

### 2025_10_28_134749_create_region_news_system_tables.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Regions table - hierarchical geographic regions
        Schema::create('regions', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('name');
            $table->string('slug')->unique();
            $table->enum('type', ['state', 'county', 'city', 'neighborhood']);
            $table->uuid('parent_id')->nullable();
            $table->text('description')->nullable();
            $table->boolean('is_active')->default(true);
            $table->integer('display_order')->default(0);
            $table->json('metadata')->nullable();
            $table->decimal('latitude', 10, 7)->nullable();
            $table->decimal('longitude', 10, 7)->nullable();
            $table->timestamps();

            $table->index('slug');
            $table->index('type');
            $table->index('parent_id');
            $table->index('is_active');
            $table->index(['latitude', 'longitude']);
        });

        // Add self-referencing foreign key after table creation
        Schema::table('regions', function (Blueprint $table) {
            $table->foreign('parent_id')
                ->references('id')
                ->on('regions')
                ->onDelete('cascade');
        });

        // Region zipcodes table - links zipcodes to regions
        Schema::create('region_zipcodes', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('region_id')->constrained('regions')->onDelete('cascade');
            $table->string('zipcode', 10);
            $table->boolean('is_primary')->default(false);
            $table->timestamps();

            $table->unique(['region_id', 'zipcode']);
            $table->index('zipcode');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('region_zipcodes');
        Schema::dropIfExists('regions');
    }
};
```

### 2025_11_04_210900_create_day_news_tables.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Day News Posts table
        Schema::create('day_news_posts', function (Blueprint $table) {
            $table->id();
            $table->foreignUuid('workspace_id')->nullable()->constrained()->nullOnDelete();
            $table->foreignUuid('author_id')->nullable()->constrained('users')->nullOnDelete();
            $table->enum('type', ['article', 'announcement', 'notice', 'ad', 'schedule']);
            $table->enum('category', [
                'local_news',
                'business',
                'sports',
                'entertainment',
                'community',
                'education',
                'health',
                'politics',
                'crime',
                'weather',
                'events',
                'obituary',
                'missing_person',
                'emergency',
                'public_notice',
                'other',
            ])->nullable();
            $table->string('title');
            $table->string('slug')->unique();
            $table->text('content');
            $table->text('excerpt')->nullable();
            $table->string('featured_image')->nullable();
            $table->json('metadata')->nullable();
            $table->enum('status', ['draft', 'published', 'expired', 'removed'])->default('draft');
            $table->timestamp('published_at')->nullable();
            $table->timestamp('expires_at')->nullable();
            $table->unsignedBigInteger('view_count')->default(0);
            $table->timestamps();

            $table->index(['workspace_id', 'status']);
            $table->index(['type', 'status']);
            $table->index(['published_at', 'status']);
            $table->index('slug');
        });

        // Day News Post Payments table
        Schema::create('day_news_post_payments', function (Blueprint $table) {
            $table->id();
            $table->foreignId('post_id')->constrained('day_news_posts')->cascadeOnDelete();
            $table->foreignUuid('workspace_id')->constrained()->cascadeOnDelete();
            $table->string('stripe_payment_intent_id')->nullable();
            $table->string('stripe_checkout_session_id')->nullable();
            $table->integer('amount');
            $table->string('currency', 3)->default('usd');
            $table->enum('status', ['pending', 'paid', 'failed', 'refunded'])->default('pending');
            $table->enum('payment_type', ['post', 'ad']);
            $table->integer('ad_days')->nullable();
            $table->timestamps();

            $table->index('post_id');
            $table->index('workspace_id');
            $table->index('stripe_payment_intent_id');
            $table->index('stripe_checkout_session_id');
        });

        // Advertisements table (generic for all platforms)
        Schema::create('advertisements', function (Blueprint $table) {
            $table->id();
            $table->enum('platform', ['day_news', 'event_city', 'downtown_guide']);
            $table->string('advertable_type');
            $table->string('advertable_id');
            $table->enum('placement', ['sidebar', 'banner', 'inline', 'featured'])->default('sidebar');
            $table->json('regions')->nullable();
            $table->unsignedBigInteger('impressions_count')->default(0);
            $table->unsignedBigInteger('clicks_count')->default(0);
            $table->timestamp('starts_at');
            $table->timestamp('expires_at');
            $table->boolean('is_active')->default(true);
            $table->timestamps();

            $table->index(['platform', 'is_active']);
            $table->index('expires_at');
            $table->index(['advertable_type', 'advertable_id']);
        });

        // Day News Post Region pivot table
        Schema::create('day_news_post_region', function (Blueprint $table) {
            $table->id();
            $table->foreignId('day_news_post_id')->constrained()->cascadeOnDelete();
            $table->foreignUuid('region_id')->constrained()->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['day_news_post_id', 'region_id']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('day_news_post_region');
        Schema::dropIfExists('advertisements');
        Schema::dropIfExists('day_news_post_payments');
        Schema::dropIfExists('day_news_posts');
    }
};
```

### 2025_11_04_210901_add_reviews_and_ratings_to_day_news_posts_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::table('day_news_posts', function (Blueprint $table) {
            $table->decimal('average_rating', 3, 2)->nullable()->after('view_count');
            $table->unsignedInteger('total_reviews')->default(0)->after('average_rating');
            
            $table->index('average_rating');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('day_news_posts', function (Blueprint $table) {
            $table->dropIndex(['average_rating']);
            $table->dropColumn(['average_rating', 'total_reviews']);
        });
    }
};

```

### 2025_11_04_210902_add_day_news_activity_types.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Note: MySQL doesn't support ALTER ENUM directly, so we need to modify the column
        // This migration adds Day News activity types to the existing enum
        
        $driver = DB::getDriverName();
        
        if ($driver === 'mysql') {
            // For MySQL, we need to alter the column type
            DB::statement("ALTER TABLE social_activities MODIFY COLUMN type ENUM(
                'post_like', 'post_comment', 'post_share',
                'friend_request', 'friend_accept',
                'group_invite', 'group_join', 'group_post',
                'profile_follow',
                'article_like', 'article_comment', 'article_share', 'article_view',
                'tag_follow', 'author_follow'
            ) NOT NULL");
        } elseif ($driver === 'pgsql') {
            // For PostgreSQL, we can use ALTER TYPE
            DB::statement("ALTER TYPE social_activities_type_enum ADD VALUE IF NOT EXISTS 'article_like'");
            DB::statement("ALTER TYPE social_activities_type_enum ADD VALUE IF NOT EXISTS 'article_comment'");
            DB::statement("ALTER TYPE social_activities_type_enum ADD VALUE IF NOT EXISTS 'article_share'");
            DB::statement("ALTER TYPE social_activities_type_enum ADD VALUE IF NOT EXISTS 'article_view'");
            DB::statement("ALTER TYPE social_activities_type_enum ADD VALUE IF NOT EXISTS 'tag_follow'");
            DB::statement("ALTER TYPE social_activities_type_enum ADD VALUE IF NOT EXISTS 'author_follow'");
        } elseif ($driver === 'sqlite') {
            // SQLite stores ENUMs as strings, so new values will work without modification
            // No action needed - the application will validate the enum values
        }
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Note: Removing enum values is complex and may not be fully reversible
        // In practice, you may need to recreate the table or leave the values
        // This is a common limitation with ENUM types
    }
};

```

### 2025_11_04_210903_create_article_comments_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        if (Schema::hasTable('article_comments')) {
            return;
        }
        
        Schema::create('article_comments', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignId('article_id')->constrained('day_news_posts')->cascadeOnDelete();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->uuid('parent_id')->nullable();
            $table->text('content');
            $table->boolean('is_active')->default(true);
            $table->boolean('is_pinned')->default(false);
            $table->unsignedInteger('reports_count')->default(0);
            $table->timestamps();

            $table->index(['article_id', 'parent_id', 'created_at']);
            $table->index(['user_id', 'created_at']);
            $table->index(['article_id', 'is_active', 'created_at']);
            
            // Self-referencing foreign key for replies
            $table->foreign('parent_id')->references('id')->on('article_comments')->onDelete('cascade');
        });

        // Article comment likes table
        Schema::create('article_comment_likes', function (Blueprint $table) {
            $table->id();
            $table->uuid('comment_id')->constrained('article_comments')->cascadeOnDelete();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['comment_id', 'user_id']);
            $table->index(['comment_id', 'created_at']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('article_comment_likes');
        Schema::dropIfExists('article_comments');
    }
};

```

### 2025_11_04_210904_create_tags_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        if (Schema::hasTable('tags')) {
            return;
        }
        
        Schema::create('tags', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('name');
            $table->string('slug')->unique();
            $table->text('description')->nullable();
            $table->unsignedInteger('article_count')->default(0);
            $table->unsignedInteger('followers_count')->default(0);
            $table->boolean('is_trending')->default(false);
            $table->unsignedInteger('trending_score')->default(0);
            $table->timestamps();

            $table->index('slug');
            $table->index('is_trending');
            $table->index(['is_trending', 'trending_score']);
        });

        // Pivot table for tags and articles
        Schema::create('day_news_post_tag', function (Blueprint $table) {
            $table->id();
            $table->foreignId('day_news_post_id')->constrained()->cascadeOnDelete();
            $table->uuid('tag_id')->constrained('tags')->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['day_news_post_id', 'tag_id']);
            $table->index('tag_id');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('day_news_post_tag');
        Schema::dropIfExists('tags');
    }
};

```

### 2025_11_04_210905_create_search_tables.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        if (Schema::hasTable('search_history')) {
            return;
        }
        
        // Search history table
        Schema::create('search_history', function (Blueprint $table) {
            $table->id();
            $table->foreignUuid('user_id')->nullable()->constrained('users')->nullOnDelete();
            $table->string('query');
            $table->unsignedInteger('results_count')->default(0);
            $table->json('filters')->nullable();
            $table->string('ip_address')->nullable();
            $table->timestamps();

            $table->index(['user_id', 'created_at']);
            $table->index(['query', 'created_at']);
            $table->index('created_at');
        });

        // Search suggestions table
        Schema::create('search_suggestions', function (Blueprint $table) {
            $table->id();
            $table->string('query')->unique();
            $table->unsignedInteger('popularity')->default(1);
            $table->unsignedInteger('click_count')->default(0);
            $table->timestamps();

            $table->index('popularity');
            $table->index('query');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('search_suggestions');
        Schema::dropIfExists('search_history');
    }
};

```

### 2025_11_04_210906_create_comment_reports_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        if (Schema::hasTable('comment_reports')) {
            return;
        }
        
        Schema::create('comment_reports', function (Blueprint $table) {
            $table->id();
            $table->uuid('comment_id')->constrained('article_comments')->cascadeOnDelete();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->string('reason'); // spam, harassment, inappropriate, other
            $table->text('details')->nullable();
            $table->enum('status', ['pending', 'reviewed', 'resolved', 'dismissed'])->default('pending');
            $table->timestamps();

            $table->unique(['comment_id', 'user_id']); // One report per user per comment
            $table->index(['status', 'created_at']);
            $table->index('comment_id');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('comment_reports');
    }
};

```

### 2025_11_04_210907_create_announcements_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        if (Schema::hasTable('announcements')) {
            return;
        }
        
        Schema::create('announcements', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->foreignUuid('workspace_id')->nullable()->constrained()->nullOnDelete();
            $table->enum('type', [
                'wedding',
                'engagement',
                'birth',
                'graduation',
                'anniversary',
                'celebration',
                'general',
                'community_event',
                'public_notice',
                'emergency_alert',
                'meeting',
                'volunteer_opportunity',
                'road_closure',
                'school_announcement',
            ]);
            $table->string('title');
            $table->text('content');
            $table->string('image')->nullable();
            $table->string('location')->nullable();
            $table->date('event_date')->nullable();
            $table->enum('status', ['draft', 'pending', 'published', 'expired', 'removed'])->default('draft');
            $table->timestamp('published_at')->nullable();
            $table->timestamp('expires_at')->nullable();
            $table->unsignedInteger('views_count')->default(0);
            $table->unsignedInteger('reactions_count')->default(0);
            $table->unsignedInteger('comments_count')->default(0);
            $table->timestamps();

            $table->index(['type', 'status']);
            $table->index(['status', 'published_at']);
            $table->index(['user_id', 'status']);
            $table->index('event_date');
        });

        // Announcement regions pivot table
        Schema::create('announcement_region', function (Blueprint $table) {
            $table->id();
            $table->uuid('announcement_id')->constrained('announcements')->cascadeOnDelete();
            $table->foreignUuid('region_id')->constrained()->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['announcement_id', 'region_id']);
        });

        // Announcement reactions (using polymorphic Rating model)
        // No separate table needed - using existing ratings table
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('announcement_region');
        Schema::dropIfExists('announcements');
    }
};

```

### 2025_11_04_210908_create_classifieds_tables.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        if (Schema::hasTable('classifieds')) {
            return;
        }
        
        Schema::create('classifieds', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->foreignUuid('workspace_id')->nullable()->constrained()->nullOnDelete();
            $table->enum('category', [
                'for_sale',
                'housing',
                'jobs',
                'services',
                'community',
                'personals',
            ]);
            $table->string('subcategory')->nullable();
            $table->string('title');
            $table->text('description');
            $table->decimal('price', 10, 2)->nullable();
            $table->string('price_type')->nullable(); // fixed, negotiable, contact_for_pricing
            $table->string('condition')->nullable(); // new, like_new, excellent, good, fair, poor
            $table->string('location');
            $table->boolean('is_featured')->default(false);
            $table->enum('status', ['draft', 'pending_payment', 'active', 'expired', 'sold', 'removed'])->default('draft');
            $table->timestamp('posted_at')->nullable();
            $table->timestamp('expires_at')->nullable();
            $table->unsignedInteger('views_count')->default(0);
            $table->timestamps();

            $table->index(['category', 'status']);
            $table->index(['status', 'posted_at']);
            $table->index(['user_id', 'status']);
            $table->index('expires_at');
        });

        // Classified images table
        Schema::create('classified_images', function (Blueprint $table) {
            $table->id();
            $table->uuid('classified_id')->constrained('classifieds')->cascadeOnDelete();
            $table->string('image_path');
            $table->string('image_disk')->default('public');
            $table->unsignedInteger('order')->default(0);
            $table->timestamps();

            $table->index(['classified_id', 'order']);
        });

        // Classified regions pivot table
        Schema::create('classified_region', function (Blueprint $table) {
            $table->id();
            $table->uuid('classified_id')->constrained('classifieds')->cascadeOnDelete();
            $table->foreignUuid('region_id')->constrained()->cascadeOnDelete();
            $table->unsignedInteger('days')->default(7); // How many days to show in this region
            $table->timestamps();

            $table->unique(['classified_id', 'region_id']);
        });

        // Classified payments table
        Schema::create('classified_payments', function (Blueprint $table) {
            $table->id();
            $table->uuid('classified_id')->constrained('classifieds')->cascadeOnDelete();
            $table->foreignUuid('workspace_id')->constrained()->cascadeOnDelete();
            $table->string('stripe_payment_intent_id')->nullable();
            $table->string('stripe_checkout_session_id')->nullable();
            $table->integer('amount'); // in cents
            $table->string('currency', 3)->default('usd');
            $table->enum('status', ['pending', 'paid', 'failed', 'refunded'])->default('pending');
            $table->json('regions_data')->nullable(); // Store region and days info
            $table->unsignedInteger('total_days')->default(7);
            $table->timestamps();

            $table->index('classified_id');
            $table->index('workspace_id');
            $table->index('stripe_checkout_session_id');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('classified_payments');
        Schema::dropIfExists('classified_region');
        Schema::dropIfExists('classified_images');
        Schema::dropIfExists('classifieds');
    }
};

```

### 2025_11_04_210909_create_coupons_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        if (Schema::hasTable('coupons')) {
            return;
        }
        
        Schema::create('coupons', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->foreignUuid('business_id')->nullable()->constrained('businesses')->nullOnDelete();
            $table->string('title');
            $table->text('description')->nullable();
            $table->enum('discount_type', ['percentage', 'fixed_amount', 'buy_one_get_one', 'free_item'])->default('percentage');
            $table->decimal('discount_value', 10, 2)->nullable(); // Percentage or fixed amount
            $table->text('terms')->nullable();
            $table->string('code')->unique()->nullable(); // Optional coupon code
            $table->string('image')->nullable();
            $table->string('business_name');
            $table->string('business_location')->nullable();
            $table->date('start_date');
            $table->date('end_date');
            $table->unsignedInteger('usage_limit')->nullable(); // Max number of uses
            $table->unsignedInteger('used_count')->default(0);
            $table->enum('status', ['draft', 'active', 'expired', 'disabled'])->default('draft');
            $table->unsignedInteger('views_count')->default(0);
            $table->unsignedInteger('clicks_count')->default(0);
            $table->timestamps();

            $table->index(['status', 'start_date', 'end_date']);
            $table->index(['business_id', 'status']);
            $table->index('code');
            $table->index('end_date');
        });

        // Coupon regions pivot table
        Schema::create('coupon_region', function (Blueprint $table) {
            $table->id();
            $table->uuid('coupon_id')->constrained('coupons')->cascadeOnDelete();
            $table->foreignUuid('region_id')->constrained()->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['coupon_id', 'region_id']);
        });

        // Coupon usage tracking
        Schema::create('coupon_usages', function (Blueprint $table) {
            $table->id();
            $table->uuid('coupon_id')->constrained('coupons')->cascadeOnDelete();
            $table->foreignUuid('user_id')->nullable()->constrained('users')->nullOnDelete();
            $table->string('ip_address')->nullable();
            $table->timestamps();

            $table->index(['coupon_id', 'created_at']);
            $table->index('user_id');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('coupon_usages');
        Schema::dropIfExists('coupon_region');
        Schema::dropIfExists('coupons');
    }
};

```

### 2025_11_04_210910_create_photos_tables.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        if (Schema::hasTable('photo_albums')) {
            return;
        }
        
        Schema::create('photo_albums', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->foreignUuid('workspace_id')->nullable()->constrained()->nullOnDelete();
            $table->string('title');
            $table->text('description')->nullable();
            $table->string('cover_image')->nullable();
            $table->enum('visibility', ['public', 'private', 'community'])->default('public');
            $table->unsignedInteger('photos_count')->default(0);
            $table->unsignedInteger('views_count')->default(0);
            $table->timestamps();

            $table->index(['user_id', 'visibility']);
            $table->index('created_at');
        });

        Schema::create('photos', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->uuid('album_id')->nullable()->constrained('photo_albums')->nullOnDelete();
            $table->string('title');
            $table->text('description')->nullable();
            $table->string('image_path');
            $table->string('image_disk')->default('public');
            $table->string('thumbnail_path')->nullable();
            $table->string('category')->nullable(); // Nature, Events, Recreation, Community, Sports, etc.
            $table->enum('status', ['pending', 'approved', 'rejected'])->default('pending');
            $table->unsignedInteger('width')->nullable();
            $table->unsignedInteger('height')->nullable();
            $table->unsignedBigInteger('file_size')->nullable(); // in bytes
            $table->unsignedInteger('views_count')->default(0);
            $table->unsignedInteger('likes_count')->default(0);
            $table->unsignedInteger('comments_count')->default(0);
            $table->timestamps();

            $table->index(['user_id', 'status']);
            $table->index(['album_id', 'created_at']);
            $table->index(['category', 'status']);
            $table->index('created_at');
        });

        Schema::create('photo_album_photo', function (Blueprint $table) {
            $table->id();
            $table->uuid('album_id')->constrained('photo_albums')->cascadeOnDelete();
            $table->uuid('photo_id')->constrained('photos')->cascadeOnDelete();
            $table->unsignedInteger('order')->default(0);
            $table->timestamps();

            $table->unique(['album_id', 'photo_id']);
            $table->index(['album_id', 'order']);
        });

        Schema::create('photo_region', function (Blueprint $table) {
            $table->id();
            $table->uuid('photo_id')->constrained('photos')->cascadeOnDelete();
            $table->foreignUuid('region_id')->constrained()->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['photo_id', 'region_id']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('photo_region');
        Schema::dropIfExists('photo_album_photo');
        Schema::dropIfExists('photos');
        Schema::dropIfExists('photo_albums');
    }
};

```

### 2025_11_04_210911_add_author_fields_to_users_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::table('users', function (Blueprint $table) {
            if (!Schema::hasColumn('users', 'bio')) {
                $table->text('bio')->nullable()->after('email');
            }
            if (!Schema::hasColumn('users', 'author_slug')) {
                $table->string('author_slug')->nullable()->unique()->after('bio');
            }
            if (!Schema::hasColumn('users', 'trust_score')) {
                $table->decimal('trust_score', 5, 2)->default(0.00)->after('author_slug');
            }
            if (!Schema::hasColumn('users', 'trust_tier')) {
                $table->enum('trust_tier', ['bronze', 'silver', 'gold', 'platinum'])->nullable()->after('trust_score');
            }
            if (!Schema::hasColumn('users', 'is_verified_author')) {
                $table->boolean('is_verified_author')->default(false)->after('trust_tier');
            }
            if (!Schema::hasColumn('users', 'author_metadata')) {
                $table->json('author_metadata')->nullable()->after('is_verified_author');
            }
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('users', function (Blueprint $table) {
            $table->dropColumn([
                'bio',
                'author_slug',
                'trust_score',
                'trust_tier',
                'is_verified_author',
                'author_metadata',
            ]);
        });
    }
};

```

### 2025_11_04_210912_create_legal_notices_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        if (Schema::hasTable('legal_notices')) {
            return;
        }
        
        Schema::create('legal_notices', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->nullable()->constrained('users')->nullOnDelete();
            $table->foreignUuid('workspace_id')->nullable()->constrained()->nullOnDelete();
            $table->enum('type', [
                'foreclosure',
                'probate',
                'name_change',
                'business_formation',
                'public_hearing',
                'zoning',
                'tax_sale',
                'other',
            ]);
            $table->string('case_number')->nullable();
            $table->string('title');
            $table->text('content');
            $table->string('court')->nullable();
            $table->date('publish_date');
            $table->date('expiry_date')->nullable();
            $table->enum('status', ['active', 'expires_soon', 'expired', 'removed'])->default('active');
            $table->json('metadata')->nullable(); // Store additional case-specific data
            $table->unsignedInteger('views_count')->default(0);
            $table->timestamps();

            $table->index(['type', 'status']);
            $table->index(['status', 'publish_date']);
            $table->index(['publish_date', 'expiry_date']);
            $table->index('case_number');
        });

        Schema::create('legal_notice_region', function (Blueprint $table) {
            $table->id();
            $table->uuid('legal_notice_id')->constrained('legal_notices')->cascadeOnDelete();
            $table->foreignUuid('region_id')->constrained()->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['legal_notice_id', 'region_id']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('legal_notice_region');
        Schema::dropIfExists('legal_notices');
    }
};

```

### 2025_11_04_210913_create_memorials_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        if (Schema::hasTable('memorials')) {
            return;
        }
        
        Schema::create('memorials', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->foreignUuid('workspace_id')->nullable()->constrained()->nullOnDelete();
            $table->string('name');
            $table->string('years'); // e.g., "1932 - 2023"
            $table->date('date_of_passing');
            $table->text('obituary');
            $table->string('image')->nullable();
            $table->string('location')->nullable();
            $table->date('service_date')->nullable();
            $table->string('service_location')->nullable();
            $table->text('service_details')->nullable();
            $table->boolean('is_featured')->default(false);
            $table->enum('status', ['draft', 'published', 'removed'])->default('draft');
            $table->timestamp('published_at')->nullable();
            $table->unsignedInteger('views_count')->default(0);
            $table->unsignedInteger('reactions_count')->default(0);
            $table->unsignedInteger('comments_count')->default(0);
            $table->timestamps();

            $table->index(['status', 'published_at']);
            $table->index(['date_of_passing', 'status']);
            $table->index('is_featured');
        });

        Schema::create('memorial_region', function (Blueprint $table) {
            $table->id();
            $table->uuid('memorial_id')->constrained('memorials')->cascadeOnDelete();
            $table->foreignUuid('region_id')->constrained()->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['memorial_id', 'region_id']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('memorial_region');
        Schema::dropIfExists('memorials');
    }
};

```

### 2025_11_04_210914_create_podcasts_tables.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        if (Schema::hasTable('creator_profiles')) {
            return;
        }
        
        Schema::create('creator_profiles', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained('users')->cascadeOnDelete();
            $table->string('display_name');
            $table->string('slug')->unique();
            $table->text('bio')->nullable();
            $table->string('avatar')->nullable();
            $table->string('cover_image')->nullable();
            $table->json('social_links')->nullable(); // Twitter, Instagram, etc.
            $table->enum('status', ['pending', 'approved', 'rejected', 'suspended'])->default('pending');
            $table->unsignedInteger('followers_count')->default(0);
            $table->unsignedInteger('podcasts_count')->default(0);
            $table->unsignedInteger('episodes_count')->default(0);
            $table->unsignedInteger('total_listens')->default(0);
            $table->timestamps();

            $table->index(['status', 'created_at']);
            $table->index('slug');
        });

        Schema::create('podcasts', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('creator_profile_id')->constrained('creator_profiles')->cascadeOnDelete();
            $table->string('title');
            $table->string('slug')->unique();
            $table->text('description')->nullable();
            $table->string('cover_image')->nullable();
            $table->string('category')->nullable();
            $table->enum('status', ['draft', 'published', 'archived'])->default('draft');
            $table->timestamp('published_at')->nullable();
            $table->unsignedInteger('episodes_count')->default(0);
            $table->unsignedInteger('subscribers_count')->default(0);
            $table->unsignedInteger('total_listens')->default(0);
            $table->unsignedInteger('total_duration')->default(0); // in seconds
            $table->timestamps();

            $table->index(['creator_profile_id', 'status']);
            $table->index(['status', 'published_at']);
            $table->index('slug');
        });

        Schema::create('podcast_episodes', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('podcast_id')->constrained('podcasts')->cascadeOnDelete();
            $table->string('title');
            $table->string('slug')->unique();
            $table->text('description')->nullable();
            $table->text('show_notes')->nullable();
            $table->string('audio_file_path');
            $table->string('audio_file_disk')->default('public');
            $table->unsignedInteger('duration')->nullable(); // in seconds
            $table->unsignedBigInteger('file_size')->nullable(); // in bytes
            $table->string('episode_number')->nullable();
            $table->enum('status', ['draft', 'published', 'archived'])->default('draft');
            $table->timestamp('published_at')->nullable();
            $table->unsignedInteger('listens_count')->default(0);
            $table->unsignedInteger('downloads_count')->default(0);
            $table->unsignedInteger('likes_count')->default(0);
            $table->unsignedInteger('comments_count')->default(0);
            $table->timestamps();

            $table->index(['podcast_id', 'status']);
            $table->index(['status', 'published_at']);
            $table->index('slug');
        });

        Schema::create('podcast_region', function (Blueprint $table) {
            $table->id();
            $table->uuid('podcast_id')->constrained('podcasts')->cascadeOnDelete();
            $table->foreignUuid('region_id')->constrained()->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['podcast_id', 'region_id']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('podcast_region');
        Schema::dropIfExists('podcast_episodes');
        Schema::dropIfExists('podcasts');
        Schema::dropIfExists('creator_profiles');
    }
};

```

### 2025_11_17_105200_create_n8n_rss_integration_tables.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

/**
 * N8N RSS Feed Integration Migration
 *
 * Creates all tables needed for N8N to manage businesses scraped from Google SERP API,
 * track their RSS feeds, and automatically generate Day News articles from feed content.
 *
 * Tables created:
 * - businesses: Stores businesses from Google SERP API
 * - business_region: Pivot table for businesses in multiple regions
 * - rss_feeds: Tracks RSS feeds for each business
 * - rss_feed_items: Individual items from RSS feeds
 *
 * Also adds RSS feed tracking fields to existing day_news_posts table.
 */
return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // 1. Businesses table
        Schema::create('businesses', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('workspace_id')->nullable()->constrained()->cascadeOnDelete();
            $table->string('google_place_id')->unique();
            $table->string('name');
            $table->string('slug')->unique();
            $table->text('description')->nullable();
            $table->string('website')->nullable();
            $table->string('phone')->nullable();
            $table->string('email')->nullable();
            $table->string('address')->nullable();
            $table->string('city')->nullable();
            $table->string('state')->nullable();
            $table->string('postal_code')->nullable();
            $table->string('country')->default('USA');
            $table->decimal('latitude', 10, 8)->nullable();
            $table->decimal('longitude', 11, 8)->nullable();
            $table->json('categories')->nullable();
            $table->decimal('rating', 3, 2)->nullable();
            $table->integer('reviews_count')->default(0);
            $table->json('opening_hours')->nullable();
            $table->json('images')->nullable();
            $table->json('serp_metadata')->nullable();

            // SERP API: Multiple identifier support for different Google services
            $table->string('data_id')->nullable();
            $table->string('data_cid')->nullable();
            $table->string('lsig')->nullable();
            $table->string('provider_id')->nullable();
            $table->string('local_services_cid')->nullable();
            $table->string('local_services_bid')->nullable();
            $table->string('local_services_pid')->nullable();

            // SERP API: Source and sync tracking
            $table->string('serp_source')->nullable(); // 'local', 'local_services', 'maps'
            $table->timestamp('serp_last_synced_at')->nullable();

            // SERP API: Enhanced business type classification
            $table->string('primary_type')->nullable(); // e.g., 'Electrician', 'Restaurant'
            $table->string('type_id')->nullable();
            $table->json('type_ids')->nullable(); // Multiple type IDs from Google

            // SERP API: Price level
            $table->string('price_level')->nullable(); // '$', '$$', '$$$', '$$$$'

            // SERP API: Enhanced hours information
            $table->string('open_state')->nullable(); // 'Open', 'Closed', 'Open 24 hours'
            $table->string('hours_display')->nullable(); // Human-readable hours string

            // SERP API: Local Services specific fields
            $table->string('google_badge')->nullable(); // 'GOOGLE GUARANTEED', etc.
            $table->json('service_area')->nullable(); // Array of regions served
            $table->integer('years_in_business')->nullable();
            $table->integer('bookings_nearby')->nullable();

            // SERP API: Enhanced verification status
            $table->string('verification_status')->default('unverified'); // 'unverified', 'claimed', 'verified', 'google_guaranteed'
            $table->timestamp('verified_at')->nullable();
            $table->timestamp('claimed_at')->nullable();
            $table->boolean('is_verified')->default(false); // Keep for backward compatibility

            // SERP API: Service options (dine-in, takeout, delivery, etc.)
            $table->json('service_options')->nullable();

            // SERP API: Action URLs
            $table->string('reserve_url')->nullable();
            $table->string('order_online_url')->nullable();

            $table->string('status')->default('active');
            $table->nullableUuidMorphs('claimable');
            $table->timestamps();
            $table->softDeletes();

            $table->index('google_place_id');
            $table->index('workspace_id');
            $table->index('status');
            $table->index('is_verified');
            $table->index('verification_status');
            $table->index('primary_type');
            $table->index('serp_source');
            $table->index('data_id');
            $table->index('data_cid');
            $table->index(['latitude', 'longitude']);
        });

        // 2. Business-Region pivot table
        Schema::create('business_region', function (Blueprint $table) {
            $table->id();
            $table->foreignUuid('business_id')->constrained()->cascadeOnDelete();
            $table->foreignUuid('region_id')->constrained()->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['business_id', 'region_id']);
        });

        // 3. RSS Feeds table
        Schema::create('rss_feeds', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('business_id')->constrained()->cascadeOnDelete();
            $table->string('url')->index();
            $table->string('feed_type')->default('other');
            $table->string('title')->nullable();
            $table->text('description')->nullable();
            $table->string('status')->default('active');
            $table->string('health_status')->default('healthy');
            $table->timestamp('last_checked_at')->nullable();
            $table->timestamp('last_successful_fetch_at')->nullable();
            $table->text('last_error')->nullable();
            $table->integer('fetch_frequency')->default(60);
            $table->integer('total_items_count')->default(0);
            $table->json('metadata')->nullable();
            $table->boolean('auto_approved')->default(true);
            $table->timestamps();
            $table->softDeletes();

            $table->index('business_id');
            $table->index('status');
            $table->index('health_status');
            $table->index('feed_type');
            $table->index(['business_id', 'url']);
        });

        // 4. RSS Feed Items table
        Schema::create('rss_feed_items', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('rss_feed_id')->constrained()->cascadeOnDelete();
            $table->string('guid');
            $table->string('title');
            $table->text('description')->nullable();
            $table->text('content')->nullable();
            $table->string('url')->nullable();
            $table->string('author')->nullable();
            $table->timestamp('published_at')->nullable();
            $table->json('categories')->nullable();
            $table->json('metadata')->nullable();
            $table->boolean('processed')->default(false);
            $table->timestamp('processed_at')->nullable();
            $table->timestamps();
            $table->softDeletes();

            $table->index('rss_feed_id');
            $table->index('processed');
            $table->index('published_at');
            $table->unique(['rss_feed_id', 'guid']);
        });

        // 5. Add RSS feed tracking to existing day_news_posts table
        Schema::table('day_news_posts', function (Blueprint $table) {
            $table->foreignUuid('rss_feed_id')->nullable()->after('author_id')->constrained()->nullOnDelete();
            $table->foreignUuid('rss_feed_item_id')->nullable()->after('rss_feed_id')->constrained()->nullOnDelete();
            $table->string('source_type')->nullable()->after('rss_feed_item_id');

            $table->index('rss_feed_id');
            $table->index('rss_feed_item_id');
            $table->index('source_type');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Remove RSS feed fields from day_news_posts
        Schema::table('day_news_posts', function (Blueprint $table) {
            $table->dropForeign(['rss_feed_id']);
            $table->dropForeign(['rss_feed_item_id']);
            $table->dropIndex(['rss_feed_id']);
            $table->dropIndex(['rss_feed_item_id']);
            $table->dropIndex(['source_type']);
            $table->dropColumn(['rss_feed_id', 'rss_feed_item_id', 'source_type']);
        });

        // Drop tables in reverse order (respecting foreign key constraints)
        Schema::dropIfExists('rss_feed_items');
        Schema::dropIfExists('rss_feeds');
        Schema::dropIfExists('business_region');
        Schema::dropIfExists('businesses');
    }
};
```

### 2025_11_25_123429_create_news_workflow_tables.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Table 1: Raw news articles from SERP API
        Schema::create('news_articles', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('region_id')->index();
            $table->uuid('business_id')->nullable()->index();
            $table->string('source_type'); // 'business' or 'category'
            $table->string('source_name');
            $table->text('title');
            $table->text('url')->unique();
            $table->text('content_snippet')->nullable();
            $table->text('full_content')->nullable();
            $table->string('source_publisher')->nullable();
            $table->timestamp('published_at')->nullable();
            $table->json('metadata')->nullable(); // Raw SERP data
            $table->string('content_hash')->index(); // Deduplication
            $table->boolean('processed')->default(false)->index();
            $table->timestamps();

            $table->foreign('region_id')->references('id')->on('regions')->cascadeOnDelete();
            $table->foreign('business_id')->references('id')->on('businesses')->cascadeOnDelete();
        });

        // Table 2: AI-generated article drafts tracking workflow progress
        Schema::create('news_article_drafts', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('news_article_id')->index();
            $table->uuid('region_id')->index();
            $table->string('status'); // shortlisted, outline_generated, ready_for_generation, ready_for_publishing, published, rejected
            $table->decimal('relevance_score', 5, 2)->nullable(); // Phase 3 AI scoring (0-100)
            $table->decimal('quality_score', 5, 2)->nullable(); // Phase 5 AI scoring (0-100)
            $table->decimal('fact_check_confidence', 5, 2)->nullable(); // Phase 4 average confidence (0-100) - STORED FOR UI
            $table->json('topic_tags')->nullable(); // Topic diversity tracking
            $table->text('outline')->nullable(); // Phase 4 generated outline
            $table->text('generated_title')->nullable(); // Phase 6
            $table->text('generated_content')->nullable(); // Phase 6
            $table->text('generated_excerpt')->nullable(); // Phase 6
            $table->json('seo_metadata')->nullable(); // title, description, keywords
            $table->string('featured_image_url')->nullable();
            $table->json('ai_metadata')->nullable(); // Model used, tokens, etc.
            $table->unsignedBigInteger('published_post_id')->nullable(); // Links to day_news_posts
            $table->text('rejection_reason')->nullable();
            $table->timestamps();

            $table->foreign('news_article_id')->references('id')->on('news_articles')->cascadeOnDelete();
            $table->foreign('region_id')->references('id')->on('regions')->cascadeOnDelete();
            $table->foreign('published_post_id')->references('id')->on('day_news_posts')->nullOnDelete();

            $table->index('status');
            $table->index('quality_score'); // For hybrid auto-publish filtering
        });

        // Table 3: Fact-checking verification results per claim
        Schema::create('news_fact_checks', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('draft_id')->index();
            $table->text('claim'); // Extracted claim to verify
            $table->text('verification_result'); // verified, unverified, contradicted
            $table->decimal('confidence_score', 5, 2); // 0-100
            $table->json('sources')->nullable(); // Array of URLs used for verification
            $table->text('scraped_evidence')->nullable(); // Evidence from ScrapingBee
            $table->json('metadata')->nullable();
            $table->timestamps();

            $table->foreign('draft_id')->references('id')->on('news_article_drafts')->cascadeOnDelete();
        });

        // Table 4: Workflow execution tracking for observability
        Schema::create('news_workflow_runs', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('region_id')->nullable()->index();
            $table->string('phase'); // business_discovery, news_collection, etc.
            $table->string('status'); // running, completed, failed
            $table->timestamp('started_at');
            $table->timestamp('completed_at')->nullable();
            $table->integer('items_processed')->default(0);
            $table->json('summary')->nullable(); // Stats, counts, etc.
            $table->text('error_message')->nullable();
            $table->json('error_trace')->nullable();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('news_fact_checks');
        Schema::dropIfExists('news_article_drafts');
        Schema::dropIfExists('news_articles');
        Schema::dropIfExists('news_workflow_runs');
    }
};
```

### 2025_11_26_201944_add_event_extraction_support.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Add source tracking to events table
        Schema::table('events', function (Blueprint $table) {
            $table->foreignUuid('source_news_article_id')
                ->nullable()
                ->after('created_by')
                ->constrained('news_articles')
                ->nullOnDelete();

            $table->string('source_type')
                ->default('manual')
                ->after('source_news_article_id');

            $table->index('source_type');
        });

        // Create event-region pivot table for many-to-many relationship
        Schema::create('event_region', function (Blueprint $table) {
            $table->id();
            $table->foreignUuid('event_id')->constrained('events')->cascadeOnDelete();
            $table->foreignUuid('region_id')->constrained('regions')->cascadeOnDelete();
            $table->timestamps();

            $table->unique(['event_id', 'region_id']);
        });

        // Create event extraction drafts table for AI-extracted events
        Schema::create('event_extraction_drafts', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('news_article_id')->constrained('news_articles')->cascadeOnDelete();
            $table->foreignUuid('region_id')->constrained('regions')->cascadeOnDelete();

            // Status: pending -> detected -> extracted -> validated -> published/rejected
            $table->string('status')->default('pending');

            // AI confidence scores (0-100)
            $table->decimal('detection_confidence', 5, 2)->nullable();
            $table->decimal('extraction_confidence', 5, 2)->nullable();
            $table->decimal('quality_score', 5, 2)->nullable();

            // Extracted event data (JSON before creating Event)
            $table->json('extracted_data')->nullable();

            // Matched/created references
            $table->foreignUuid('matched_venue_id')->nullable()->constrained('venues')->nullOnDelete();
            $table->foreignUuid('matched_performer_id')->nullable()->constrained('performers')->nullOnDelete();
            $table->foreignUuid('published_event_id')->nullable()->constrained('events')->nullOnDelete();

            // AI metadata (model, tokens, etc.)
            $table->json('ai_metadata')->nullable();

            // Error tracking
            $table->text('rejection_reason')->nullable();

            $table->timestamps();

            // Indexes
            $table->index('status');
            $table->index('quality_score');
            $table->index(['news_article_id', 'region_id']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('event_extraction_drafts');
        Schema::dropIfExists('event_region');

        Schema::table('events', function (Blueprint $table) {
            $table->dropForeign(['source_news_article_id']);
            $table->dropIndex(['source_type']);
            $table->dropColumn(['source_news_article_id', 'source_type']);
        });
    }
};
```

### 2025_11_27_124219_add_news_feature_enhancements.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Add storage fields to news_article_drafts
        Schema::table('news_article_drafts', function (Blueprint $table) {
            $table->string('featured_image_path')->nullable()->after('featured_image_url');
            $table->string('featured_image_disk')->nullable()->default('public')->after('featured_image_path');
        });

        // Add storage fields to day_news_posts
        Schema::table('day_news_posts', function (Blueprint $table) {
            $table->string('featured_image_path')->nullable()->after('featured_image');
            $table->string('featured_image_disk')->nullable()->default('public')->after('featured_image_path');
        });

        // Add storage fields to events
        Schema::table('events', function (Blueprint $table) {
            $table->string('image_path')->nullable()->after('image');
            $table->string('image_disk')->nullable()->default('public')->after('image_path');
        });

        // Add relevance scoring to news_articles
        Schema::table('news_articles', function (Blueprint $table) {
            $table->decimal('relevance_score', 5, 2)->nullable()->after('processed');
            $table->json('relevance_topic_tags')->nullable()->after('relevance_score');
            $table->text('relevance_rationale')->nullable()->after('relevance_topic_tags');
            $table->timestamp('scored_at')->nullable()->after('relevance_rationale');

            // Index for performance when selecting scored articles
            $table->index(['region_id', 'relevance_score', 'processed']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('news_article_drafts', function (Blueprint $table) {
            $table->dropColumn(['featured_image_path', 'featured_image_disk']);
        });

        Schema::table('day_news_posts', function (Blueprint $table) {
            $table->dropColumn(['featured_image_path', 'featured_image_disk']);
        });

        Schema::table('events', function (Blueprint $table) {
            $table->dropColumn(['image_path', 'image_disk']);
        });

        Schema::table('news_articles', function (Blueprint $table) {
            $table->dropIndex(['region_id', 'relevance_score', 'processed']);
            $table->dropColumn(['relevance_score', 'relevance_topic_tags', 'relevance_rationale', 'scored_at']);
        });
    }
};
```

### 2025_12_10_215831_create_news_fetch_frequencies_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('news_fetch_frequencies', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('category')->index();
            $table->string('category_type'); // 'news_category' or 'business_category'
            $table->string('frequency_type'); // 'daily', 'weekly', 'monthly', 'custom_days'
            $table->unsignedInteger('custom_interval_days')->nullable();
            $table->timestamp('last_fetched_at')->nullable()->index();
            $table->boolean('is_enabled')->default(true)->index();
            $table->json('metadata')->nullable();
            $table->timestamps();

            $table->unique(['category', 'category_type']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('news_fetch_frequencies');
    }
};
```

### 2025_12_11_163649_create_news_workflow_settings_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('news_workflow_settings', function (Blueprint $table) {
            $table->id();
            $table->string('key')->unique();
            $table->string('value');
            $table->string('type')->default('boolean');
            $table->text('description')->nullable();
            $table->timestamps();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('news_workflow_settings');
    }
};
```

### 2025_12_12_174756_extend_featured_image_url_length.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * Unsplash URLs can exceed 255 characters due to long query parameters.
     * Change featured_image_url from varchar(255) to text.
     */
    public function up(): void
    {
        Schema::table('news_article_drafts', function (Blueprint $table) {
            $table->text('featured_image_url')->nullable()->change();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('news_article_drafts', function (Blueprint $table) {
            $table->string('featured_image_url')->nullable()->change();
        });
    }
};
```

### 2025_12_16_112702_create_writer_agents_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('writer_agents', function (Blueprint $table) {
            $table->uuid('id')->primary();

            // Identity
            $table->string('name');
            $table->string('slug')->unique();
            $table->text('bio')->nullable();
            $table->string('avatar')->nullable();

            // Persona configuration
            $table->string('writing_style')->default('conversational');
            $table->json('persona_traits')->nullable();
            $table->json('expertise_areas')->nullable();

            // Specializations
            $table->json('categories')->default('[]');

            // AI Prompts
            $table->json('prompts')->default('{}');

            // Statistics
            $table->unsignedInteger('articles_count')->default(0);

            // Status
            $table->boolean('is_active')->default(true);

            $table->timestamps();

            // Indexes
            $table->index('is_active');
            $table->index('writing_style');
        });

        Schema::create('writer_agent_region', function (Blueprint $table) {
            $table->id();
            $table->foreignUuid('writer_agent_id')->constrained('writer_agents')->cascadeOnDelete();
            $table->foreignUuid('region_id')->constrained('regions')->cascadeOnDelete();
            $table->boolean('is_primary')->default(false);
            $table->timestamps();

            $table->unique(['writer_agent_id', 'region_id']);
            $table->index('region_id');
        });

        Schema::table('day_news_posts', function (Blueprint $table) {
            $table->foreignUuid('writer_agent_id')
                ->nullable()
                ->after('author_id')
                ->constrained('writer_agents')
                ->nullOnDelete();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('day_news_posts', function (Blueprint $table) {
            $table->dropForeign(['writer_agent_id']);
            $table->dropColumn('writer_agent_id');
        });

        Schema::dropIfExists('writer_agent_region');
        Schema::dropIfExists('writer_agents');
    }
};
```

### 2025_12_20_000001_add_organization_fields_to_businesses_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::table('businesses', function (Blueprint $table) {
            // Organization type and level
            $table->string('organization_type')->default('business')->after('status');
            // Values: 'business', 'government', 'non_profit', 'religious', 'educational', 'healthcare', 'other'
            
            $table->string('organization_level')->default('local')->after('organization_type');
            // Values: 'local', 'regional', 'state', 'national', 'international'
            
            // Organization hierarchy
            $table->uuid('parent_organization_id')->nullable()->after('organization_level');
            
            // Organization category (specific type)
            $table->string('organization_category')->nullable()->after('parent_organization_id');
            // Values: 'city_government', 'county_government', 'state_government', 'federal_government',
            // 'law_enforcement', 'fire_department', 'school_district', etc.
            
            // Organization flag
            $table->boolean('is_organization')->default(false)->after('organization_category');
            
            // Organization identifier (FIPS code, EIN, etc.)
            $table->string('organization_identifier')->nullable()->after('is_organization');
            
            // Organization hierarchy path (JSON)
            $table->json('organization_hierarchy')->nullable()->after('organization_identifier');
            
            // Foreign key for parent organization
            $table->foreign('parent_organization_id')
                ->references('id')
                ->on('businesses')
                ->nullOnDelete();
            
            // Indexes
            $table->index('organization_type');
            $table->index('organization_level');
            $table->index('parent_organization_id');
            $table->index('is_organization');
            $table->index('organization_category');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('businesses', function (Blueprint $table) {
            $table->dropForeign(['parent_organization_id']);
            $table->dropIndex(['organization_type']);
            $table->dropIndex(['organization_level']);
            $table->dropIndex(['parent_organization_id']);
            $table->dropIndex(['is_organization']);
            $table->dropIndex(['organization_category']);
            
            $table->dropColumn([
                'organization_type',
                'organization_level',
                'parent_organization_id',
                'organization_category',
                'is_organization',
                'organization_identifier',
                'organization_hierarchy',
            ]);
        });
    }
};

```

### 2025_12_20_000002_create_organization_relationships_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('organization_relationships', function (Blueprint $table) {
            $table->uuid('id')->primary();
            
            // Organization (Business)
            $table->uuid('organization_id');
            
            // Polymorphic relationship to any content type
            $table->string('relatable_type'); // e.g., 'App\Models\DayNewsPost', 'App\Models\Event', etc.
            $table->uuid('relatable_id');
            
            // Relationship type
            $table->string('relationship_type')->default('related');
            // Values: 'related', 'sponsored', 'featured', 'partner', 'host', 'organizer', 'venue',
            // 'sponsor', 'author', 'source', 'subject'
            
            // Primary relationship flag
            $table->boolean('is_primary')->default(false);
            
            // Additional metadata
            $table->json('metadata')->nullable();
            
            $table->timestamps();
            $table->softDeletes();
            
            // Foreign key
            $table->foreign('organization_id')
                ->references('id')
                ->on('businesses')
                ->cascadeOnDelete();
            
            // Unique constraint: same organization can't have duplicate relationships
            $table->unique(['organization_id', 'relatable_type', 'relatable_id', 'relationship_type'], 'org_rel_unique');
            
            // Indexes
            $table->index(['relatable_type', 'relatable_id']);
            $table->index('relationship_type');
            $table->index('is_primary');
            $table->index('organization_id');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('organization_relationships');
    }
};

```

### 2025_12_20_000003_create_organization_hierarchies_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('organization_hierarchies', function (Blueprint $table) {
            $table->uuid('id')->primary();
            
            // Organization
            $table->uuid('organization_id');
            
            // Parent organization
            $table->uuid('parent_id')->nullable();
            
            // Hierarchy level (0 = root, 1 = first level child, etc.)
            $table->integer('level')->default(0);
            
            // Full path (e.g., "Rotary International > District 123 > Springfield Chapter")
            $table->string('path', 500)->nullable();
            
            $table->timestamps();
            
            // Foreign keys
            $table->foreign('organization_id')
                ->references('id')
                ->on('businesses')
                ->cascadeOnDelete();
            
            $table->foreign('parent_id')
                ->references('id')
                ->on('businesses')
                ->nullOnDelete();
            
            // Unique constraint
            $table->unique(['organization_id', 'parent_id']);
            
            // Indexes
            $table->index('organization_id');
            $table->index('parent_id');
            $table->index('level');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('organization_hierarchies');
    }
};

```

### 2025_12_20_142746_create_hubs_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('hubs', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('workspace_id');
            $table->uuid('created_by');
            $table->string('name');
            $table->string('slug')->unique();
            $table->text('description')->nullable();
            $table->string('image')->nullable();
            $table->string('banner_image')->nullable();
            $table->text('about')->nullable();
            $table->string('category')->nullable();
            $table->string('subcategory')->nullable();
            $table->string('location')->nullable();
            $table->string('website')->nullable();
            $table->json('social_links')->nullable();
            $table->string('contact_email')->nullable();
            $table->string('contact_phone')->nullable();
            $table->boolean('is_active')->default(true);
            $table->boolean('is_featured')->default(false);
            $table->boolean('is_verified')->default(false);
            $table->json('design_settings')->nullable();
            $table->json('monetization_settings')->nullable();
            $table->json('permissions')->nullable();
            $table->boolean('analytics_enabled')->default(true);
            $table->boolean('articles_enabled')->default(true);
            $table->boolean('community_enabled')->default(true);
            $table->boolean('events_enabled')->default(true);
            $table->boolean('gallery_enabled')->default(true);
            $table->boolean('performers_enabled')->default(true);
            $table->boolean('venues_enabled')->default(true);
            $table->integer('followers_count')->default(0);
            $table->integer('events_count')->default(0);
            $table->integer('articles_count')->default(0);
            $table->integer('members_count')->default(0);
            $table->timestamp('last_activity_at')->nullable();
            $table->timestamp('published_at')->nullable();
            $table->timestamps();

            $table->foreign('workspace_id')->references('id')->on('workspaces')->onDelete('cascade');
            $table->foreign('created_by')->references('id')->on('users')->onDelete('cascade');
            $table->index(['workspace_id', 'is_active']);
            $table->index(['slug']);
            $table->index(['is_featured', 'is_active']);
            $table->index(['published_at']);
        });

        Schema::create('hub_sections', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('hub_id');
            $table->string('type');
            $table->string('title');
            $table->text('description')->nullable();
            $table->json('content')->nullable();
            $table->json('settings')->nullable();
            $table->boolean('is_visible')->default(true);
            $table->integer('sort_order')->default(0);
            $table->timestamps();

            $table->foreign('hub_id')->references('id')->on('hubs')->onDelete('cascade');
            $table->index(['hub_id', 'sort_order']);
            $table->index(['hub_id', 'is_visible']);
        });

        Schema::create('hub_members', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('hub_id');
            $table->uuid('user_id');
            $table->string('role')->default('member');
            $table->json('permissions')->nullable();
            $table->timestamp('joined_at');
            $table->boolean('is_active')->default(true);
            $table->timestamps();

            $table->foreign('hub_id')->references('id')->on('hubs')->onDelete('cascade');
            $table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');
            $table->unique(['hub_id', 'user_id']);
            $table->index(['hub_id', 'role']);
            $table->index(['hub_id', 'is_active']);
        });

        Schema::create('hub_roles', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('hub_id');
            $table->string('name');
            $table->string('slug');
            $table->text('description')->nullable();
            $table->json('permissions')->nullable();
            $table->boolean('is_system')->default(false);
            $table->integer('sort_order')->default(0);
            $table->timestamps();

            $table->foreign('hub_id')->references('id')->on('hubs')->onDelete('cascade');
            $table->unique(['hub_id', 'slug']);
            $table->index(['hub_id', 'sort_order']);
        });

        Schema::create('hub_analytics', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('hub_id');
            $table->date('date');
            $table->integer('page_views')->default(0);
            $table->integer('unique_visitors')->default(0);
            $table->integer('events_created')->default(0);
            $table->integer('events_published')->default(0);
            $table->integer('articles_created')->default(0);
            $table->integer('articles_published')->default(0);
            $table->integer('members_joined')->default(0);
            $table->integer('followers_gained')->default(0);
            $table->decimal('engagement_score', 10, 2)->default(0);
            $table->decimal('revenue', 10, 2)->default(0);
            $table->json('metadata')->nullable();
            $table->timestamps();

            $table->foreign('hub_id')->references('id')->on('hubs')->onDelete('cascade');
            $table->unique(['hub_id', 'date']);
            $table->index(['hub_id', 'date']);
        });

        Schema::table('events', function (Blueprint $table) {
            $table->uuid('hub_id')->nullable()->after('workspace_id');
            $table->foreign('hub_id')->references('id')->on('hubs')->onDelete('set null');
            $table->index(['hub_id']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('events', function (Blueprint $table) {
            $table->dropForeign(['hub_id']);
            $table->dropColumn('hub_id');
        });

        Schema::dropIfExists('hub_analytics');
        Schema::dropIfExists('hub_roles');
        Schema::dropIfExists('hub_members');
        Schema::dropIfExists('hub_sections');
        Schema::dropIfExists('hubs');
    }
};
```

### 2025_12_20_142758_create_check_ins_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('check_ins', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('event_id');
            $table->uuid('user_id');
            $table->timestamp('checked_in_at');
            $table->string('location')->nullable();
            $table->decimal('latitude', 10, 8)->nullable();
            $table->decimal('longitude', 11, 8)->nullable();
            $table->text('notes')->nullable();
            $table->boolean('is_public')->default(true);
            $table->timestamps();

            $table->foreign('event_id')->references('id')->on('events')->onDelete('cascade');
            $table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');
            $table->unique(['event_id', 'user_id']);
            $table->index(['event_id', 'checked_in_at']);
            $table->index(['user_id', 'checked_in_at']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('check_ins');
    }
};
```

### 2025_12_20_142759_create_planned_events_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('planned_events', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('event_id');
            $table->uuid('user_id');
            $table->timestamp('planned_at');
            $table->boolean('reminder_sent')->default(false);
            $table->timestamp('reminder_sent_at')->nullable();
            $table->text('notes')->nullable();
            $table->timestamps();

            $table->foreign('event_id')->references('id')->on('events')->onDelete('cascade');
            $table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');
            $table->unique(['event_id', 'user_id']);
            $table->index(['user_id', 'planned_at']);
            $table->index(['event_id']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('planned_events');
    }
};
```

### 2025_12_20_142800_create_promo_codes_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('promo_codes', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('code')->unique();
            $table->text('description')->nullable();
            $table->string('type'); // percentage or fixed
            $table->decimal('value', 10, 2);
            $table->decimal('min_purchase', 10, 2)->nullable();
            $table->decimal('max_discount', 10, 2)->nullable();
            $table->integer('usage_limit')->nullable();
            $table->integer('used_count')->default(0);
            $table->boolean('is_active')->default(true);
            $table->timestamp('starts_at')->nullable();
            $table->timestamp('expires_at')->nullable();
            $table->json('applicable_to')->nullable(); // event_ids, event_categories, etc.
            $table->json('metadata')->nullable();
            $table->timestamps();

            $table->index(['code', 'is_active']);
            $table->index(['expires_at']);
        });

        Schema::create('promo_code_usages', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('promo_code_id');
            $table->uuid('user_id');
            $table->uuid('ticket_order_id');
            $table->decimal('discount_amount', 10, 2);
            $table->decimal('original_amount', 10, 2);
            $table->decimal('final_amount', 10, 2);
            $table->timestamp('used_at');
            $table->timestamps();

            $table->foreign('promo_code_id')->references('id')->on('promo_codes')->onDelete('cascade');
            $table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');
            $table->foreign('ticket_order_id')->references('id')->on('ticket_orders')->onDelete('cascade');
            $table->index(['promo_code_id', 'used_at']);
            $table->index(['user_id', 'used_at']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('promo_code_usages');
        Schema::dropIfExists('promo_codes');
    }
};
```

### 2025_12_20_142801_create_ticket_listings_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('ticket_listings', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('ticket_order_item_id');
            $table->uuid('seller_id');
            $table->uuid('event_id');
            $table->decimal('price', 10, 2);
            $table->integer('quantity');
            $table->string('status')->default('active'); // active, sold, cancelled, expired
            $table->text('description')->nullable();
            $table->timestamp('expires_at')->nullable();
            $table->timestamp('sold_at')->nullable();
            $table->uuid('sold_to')->nullable();
            $table->timestamps();

            $table->foreign('ticket_order_item_id')->references('id')->on('ticket_order_items')->onDelete('cascade');
            $table->foreign('seller_id')->references('id')->on('users')->onDelete('cascade');
            $table->foreign('event_id')->references('id')->on('events')->onDelete('cascade');
            $table->foreign('sold_to')->references('id')->on('users')->onDelete('set null');
            $table->index(['event_id', 'status']);
            $table->index(['seller_id', 'status']);
            $table->index(['status', 'expires_at']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('ticket_listings');
    }
};
```

### 2025_12_20_142801_create_ticket_transfers_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('ticket_transfers', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('ticket_order_item_id');
            $table->uuid('from_user_id');
            $table->uuid('to_user_id')->nullable();
            $table->string('to_email');
            $table->string('status')->default('pending'); // pending, completed, cancelled, expired
            $table->string('transfer_token')->unique();
            $table->text('message')->nullable();
            $table->timestamp('transferred_at')->nullable();
            $table->timestamp('expires_at')->nullable();
            $table->timestamps();

            $table->foreign('ticket_order_item_id')->references('id')->on('ticket_order_items')->onDelete('cascade');
            $table->foreign('from_user_id')->references('id')->on('users')->onDelete('cascade');
            $table->foreign('to_user_id')->references('id')->on('users')->onDelete('set null');
            $table->index(['from_user_id', 'status']);
            $table->index(['to_email', 'status']);
            $table->index(['transfer_token']);
            $table->index(['status', 'expires_at']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('ticket_transfers');
    }
};
```

### 2025_12_20_142802_create_ticket_gifts_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('ticket_gifts', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('ticket_order_item_id');
            $table->uuid('gifter_id');
            $table->string('recipient_email');
            $table->string('recipient_name')->nullable();
            $table->uuid('recipient_user_id')->nullable();
            $table->string('status')->default('pending'); // pending, redeemed, cancelled, expired
            $table->string('gift_token')->unique();
            $table->text('message')->nullable();
            $table->timestamp('gifted_at')->nullable();
            $table->timestamp('redeemed_at')->nullable();
            $table->timestamp('expires_at')->nullable();
            $table->timestamps();

            $table->foreign('ticket_order_item_id')->references('id')->on('ticket_order_items')->onDelete('cascade');
            $table->foreign('gifter_id')->references('id')->on('users')->onDelete('cascade');
            $table->foreign('recipient_user_id')->references('id')->on('users')->onDelete('set null');
            $table->index(['gifter_id', 'status']);
            $table->index(['recipient_email', 'status']);
            $table->index(['gift_token']);
            $table->index(['status', 'expires_at']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('ticket_gifts');
    }
};
```

### 2025_12_20_182429_add_qr_code_to_ticket_order_items_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::table('ticket_order_items', function (Blueprint $table) {
            $table->string('ticket_code')->unique()->nullable()->after('total_price');
            $table->string('qr_code')->nullable()->after('ticket_code');
            $table->index('ticket_code');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('ticket_order_items', function (Blueprint $table) {
            $table->dropIndex(['ticket_code']);
            $table->dropColumn(['ticket_code', 'qr_code']);
        });
    }
};
```

### 2025_12_22_143009_create_industries_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('industries', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('name');
            $table->string('slug')->unique();
            $table->text('description')->nullable();
            $table->string('icon', 100)->nullable();
            $table->uuid('parent_id')->nullable();
            
            // Template Configuration
            $table->uuid('default_template_id')->nullable();
            $table->json('available_features')->nullable();
            $table->json('required_fields')->nullable();
            
            // SEO
            $table->string('seo_title')->nullable();
            $table->text('seo_description')->nullable();
            $table->string('schema_type', 100)->nullable(); // LocalBusiness, Restaurant, etc.
            
            // Display
            $table->integer('display_order')->default(0);
            $table->boolean('is_active')->default(true);
            
            $table->timestamps();
            
            $table->foreign('parent_id')->references('id')->on('industries')->nullOnDelete();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('industries');
    }
};
```

### 2025_12_22_143016_create_business_templates_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('business_templates', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('name');
            $table->string('slug')->unique();
            $table->text('description')->nullable();
            $table->uuid('industry_id')->nullable();
            
            // Template Configuration
            $table->json('layout_config')->nullable();
            $table->json('available_tabs')->nullable();
            $table->json('default_tabs')->nullable();
            $table->json('ai_features')->nullable();
            
            // Styling
            $table->json('theme_config')->nullable();
            $table->json('component_overrides')->nullable();
            
            // SEO Template
            $table->json('seo_template')->nullable();
            $table->json('schema_template')->nullable();
            
            $table->boolean('is_premium')->default(false);
            $table->boolean('is_active')->default(true);
            
            $table->timestamps();
            
            $table->foreign('industry_id')->references('id')->on('industries')->nullOnDelete();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('business_templates');
    }
};
```

### 2025_12_22_143020_create_business_subscriptions_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('business_subscriptions', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('business_id');
            
            // Subscription Status
            $table->string('tier', 50)->default('trial'); // trial, basic, standard, premium, enterprise
            $table->string('status', 50)->default('active'); // active, expired, cancelled, suspended
            
            // Trial Period (90 days)
            $table->timestamp('trial_started_at')->useCurrent();
            $table->timestamp('trial_expires_at');
            $table->timestamp('trial_converted_at')->nullable();
            
            // Active Subscription
            $table->timestamp('subscription_started_at')->nullable();
            $table->timestamp('subscription_expires_at')->nullable();
            $table->boolean('auto_renew')->default(true);
            
            // Billing
            $table->string('stripe_subscription_id')->nullable();
            $table->string('stripe_customer_id')->nullable();
            $table->decimal('monthly_amount', 10, 2)->nullable();
            $table->string('billing_cycle', 20)->default('monthly'); // monthly, annual
            
            // AI Services Enabled
            $table->json('ai_services_enabled')->default('[]');
            
            // Metadata
            $table->uuid('claimed_by_id')->nullable();
            $table->timestamp('claimed_at')->nullable();
            $table->timestamp('downgraded_at')->nullable();
            
            $table->timestamps();
            
            $table->foreign('business_id')->references('id')->on('businesses')->cascadeOnDelete();
            $table->foreign('claimed_by_id')->references('id')->on('users')->nullOnDelete();
            
            $table->index('business_id');
            $table->index('status');
            $table->index('tier');
            $table->index('trial_expires_at');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('business_subscriptions');
    }
};
```

### 2025_12_22_143022_create_alphasite_communities_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('alphasite_communities', function (Blueprint $table) {
            $table->uuid('id')->primary();
            
            // Location
            $table->string('city');
            $table->string('state', 100);
            $table->string('country', 100)->default('US');
            $table->string('slug')->unique();
            
            // Display
            $table->string('name');
            $table->text('description')->nullable();
            $table->string('hero_image_url', 500)->nullable();
            $table->string('logo_url', 500)->nullable();
            
            // Statistics (cached)
            $table->integer('total_businesses')->default(0);
            $table->integer('premium_businesses')->default(0);
            $table->integer('total_categories')->default(0);
            
            // SEO
            $table->string('seo_title')->nullable();
            $table->text('seo_description')->nullable();
            
            // Settings
            $table->json('featured_categories')->nullable();
            $table->boolean('is_active')->default(true);
            $table->timestamp('launched_at')->nullable();
            
            $table->timestamps();
            
            $table->index('slug');
            $table->index(['city', 'state']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('alphasite_communities');
    }
};
```

### 2025_12_22_143022_create_communities_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        if (Schema::hasTable('communities')) {
            return;
        }
        
        Schema::create('communities', function (Blueprint $table) {
            $table->uuid('id')->primary();
            
            // Location
            $table->string('city');
            $table->string('state', 100);
            $table->string('country', 100)->default('US');
            $table->string('slug')->unique();
            
            // Display
            $table->string('name');
            $table->text('description')->nullable();
            $table->string('hero_image_url', 500)->nullable();
            $table->string('logo_url', 500)->nullable();
            
            // Statistics (cached)
            $table->integer('total_businesses')->default(0);
            $table->integer('premium_businesses')->default(0);
            $table->integer('total_categories')->default(0);
            
            // SEO
            $table->string('seo_title')->nullable();
            $table->text('seo_description')->nullable();
            
            // Settings
            $table->json('featured_categories')->nullable();
            $table->boolean('is_active')->default(true);
            $table->timestamp('launched_at')->nullable();
            
            $table->timestamps();
            
            $table->index('slug');
            $table->index(['city', 'state']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('communities');
    }
};
```

### 2025_12_22_143025_create_smb_crm_customers_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('smb_crm_customers', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('business_id');
            
            // Customer Information
            $table->string('first_name')->nullable();
            $table->string('last_name')->nullable();
            $table->string('email')->nullable();
            $table->string('phone', 50)->nullable();
            
            // Source
            $table->string('source', 100)->nullable();
            $table->json('source_details')->nullable();
            
            // Status
            $table->string('status', 50)->default('lead'); // lead, prospect, customer, inactive, churned
            $table->date('customer_since')->nullable();
            $table->timestamp('last_interaction_at')->nullable();
            
            // AI-Generated Insights
            $table->integer('health_score')->nullable();
            $table->decimal('lifetime_value', 10, 2)->nullable();
            $table->decimal('predicted_churn_risk', 5, 4)->nullable();
            $table->text('ai_notes')->nullable();
            
            // Preferences (from surveys/interactions)
            $table->json('preferences')->nullable();
            $table->json('tags')->nullable();
            
            $table->timestamps();
            $table->softDeletes();
            
            $table->foreign('business_id')->references('id')->on('businesses')->cascadeOnDelete();
            
            $table->index('business_id');
            $table->index(['business_id', 'email']);
            $table->index(['business_id', 'status']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('smb_crm_customers');
    }
};
```

### 2025_12_22_143028_create_smb_crm_interactions_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('smb_crm_interactions', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('business_id');
            $table->uuid('customer_id')->nullable();
            
            // Interaction Details
            $table->string('interaction_type', 50); // ai_chat, phone, email, in_person, booking, order
            $table->string('channel', 50)->nullable();
            $table->string('direction', 20)->nullable(); // inbound, outbound
            
            // Content
            $table->string('subject', 500)->nullable();
            $table->text('content')->nullable();
            $table->text('summary')->nullable();
            
            // AI Handling
            $table->string('handled_by', 50)->nullable(); // ai, human, ai_escalated
            $table->string('ai_service_used', 100)->nullable();
            $table->decimal('ai_confidence_score', 5, 4)->nullable();
            $table->text('escalated_reason')->nullable();
            
            // Outcome
            $table->string('outcome', 100)->nullable();
            $table->string('sentiment', 50)->nullable();
            
            // Metadata
            $table->integer('duration_seconds')->nullable();
            $table->json('metadata')->nullable();
            
            $table->timestamp('created_at')->useCurrent();
            
            $table->foreign('business_id')->references('id')->on('businesses')->cascadeOnDelete();
            $table->foreign('customer_id')->references('id')->on('smb_crm_customers')->nullOnDelete();
            
            $table->index('business_id');
            $table->index('customer_id');
            $table->index('interaction_type');
            $table->index('created_at');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('smb_crm_interactions');
    }
};
```

### 2025_12_22_143030_create_business_faqs_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('business_faqs', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('business_id');
            
            // FAQ Content
            $table->text('question');
            $table->text('answer');
            
            // Categorization
            $table->string('category', 100)->nullable();
            $table->json('tags')->nullable();
            
            // AI Training
            $table->json('variations')->nullable();
            $table->json('follow_up_questions')->nullable();
            
            // Usage Tracking
            $table->integer('times_used')->default(0);
            $table->integer('helpful_votes')->default(0);
            $table->integer('unhelpful_votes')->default(0);
            
            // Status
            $table->boolean('is_active')->default(true);
            $table->integer('display_order')->default(0);
            
            $table->timestamps();
            
            $table->foreign('business_id')->references('id')->on('businesses')->cascadeOnDelete();
            
            $table->index('business_id');
            $table->index(['business_id', 'category']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('business_faqs');
    }
};
```

### 2025_12_22_143032_create_business_surveys_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('business_surveys', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('business_id');
            
            // Survey Definition
            $table->string('name');
            $table->text('description')->nullable();
            $table->string('survey_type', 50)->nullable();
            
            // Questions (JSON array)
            $table->json('questions');
            
            // Triggers
            $table->string('trigger_type', 50)->nullable();
            $table->json('trigger_config')->nullable();
            
            // Status
            $table->boolean('is_active')->default(true);
            $table->integer('responses_count')->default(0);
            $table->decimal('average_score', 3, 2)->nullable();
            
            $table->timestamps();
            
            $table->foreign('business_id')->references('id')->on('businesses')->cascadeOnDelete();
            
            $table->index('business_id');
        });
        
        Schema::create('business_survey_responses', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('survey_id');
            $table->uuid('business_id');
            $table->uuid('customer_id')->nullable();
            
            // Response Data
            $table->json('responses');
            $table->decimal('overall_score', 3, 2)->nullable();
            
            // AI Analysis
            $table->string('sentiment', 50)->nullable();
            $table->text('ai_summary')->nullable();
            $table->json('action_items')->nullable();
            
            // Metadata
            $table->timestamp('completed_at')->useCurrent();
            $table->string('source', 50)->nullable();
            
            $table->timestamps();
            
            $table->foreign('survey_id')->references('id')->on('business_surveys')->cascadeOnDelete();
            $table->foreign('business_id')->references('id')->on('businesses')->cascadeOnDelete();
            $table->foreign('customer_id')->references('id')->on('smb_crm_customers')->nullOnDelete();
            
            $table->index('survey_id');
            $table->index('business_id');
            $table->index('customer_id');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('business_survey_responses');
        Schema::dropIfExists('business_surveys');
    }
};
```

### 2025_12_22_143034_add_alphasite_fields_to_businesses_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::table('businesses', function (Blueprint $table) {
            // AlphaSite-Specific Fields
            $table->string('alphasite_subdomain', 255)->unique()->nullable()->after('slug');
            $table->uuid('template_id')->nullable()->after('alphasite_subdomain');
            $table->boolean('ai_services_enabled')->default(false)->after('template_id');
            $table->timestamp('premium_enrolled_at')->nullable()->after('ai_services_enabled');
            $table->timestamp('premium_expires_at')->nullable()->after('premium_enrolled_at');
            $table->string('subscription_tier', 50)->default('free')->after('premium_expires_at');
            $table->json('homepage_content')->nullable()->after('subscription_tier');
            $table->json('social_links')->nullable()->after('homepage_content');
            $table->json('amenities')->nullable()->after('social_links');
            $table->boolean('featured')->default(false)->after('amenities');
            $table->boolean('promoted')->default(false)->after('featured');
            $table->json('seo_metadata')->nullable()->after('promoted');
            $table->uuid('industry_id')->nullable()->after('seo_metadata');
            
            // Foreign keys
            $table->foreign('template_id')->references('id')->on('business_templates')->nullOnDelete();
            $table->foreign('industry_id')->references('id')->on('industries')->nullOnDelete();
            
            // Indexes
            $table->index('alphasite_subdomain');
            $table->index('industry_id');
            $table->index('template_id');
            $table->index('subscription_tier');
            $table->index('featured');
            $table->index(['city', 'state']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('businesses', function (Blueprint $table) {
            $table->dropForeign(['template_id']);
            $table->dropForeign(['industry_id']);
            $table->dropIndex(['alphasite_subdomain']);
            $table->dropIndex(['industry_id']);
            $table->dropIndex(['template_id']);
            $table->dropIndex(['subscription_tier']);
            $table->dropIndex(['featured']);
            $table->dropIndex(['city', 'state']);
            
            $table->dropColumn([
                'alphasite_subdomain',
                'template_id',
                'ai_services_enabled',
                'premium_enrolled_at',
                'premium_expires_at',
                'subscription_tier',
                'homepage_content',
                'social_links',
                'amenities',
                'featured',
                'promoted',
                'seo_metadata',
                'industry_id',
            ]);
        });
    }
};
```

### 2025_12_22_143036_create_achievements_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('achievements', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('business_id');
            
            $table->string('title');
            $table->text('description')->nullable();
            $table->string('source_name')->nullable();
            $table->string('source_url', 500)->nullable();
            
            $table->string('achievement_type', 100)->nullable();
            $table->date('achievement_date')->nullable();
            $table->date('expiration_date')->nullable();
            
            $table->string('icon', 100)->nullable();
            $table->string('badge_image_url', 500)->nullable();
            
            $table->boolean('is_verified')->default(false);
            $table->integer('display_order')->default(0);
            $table->boolean('is_featured')->default(false);
            
            $table->timestamps();
            $table->softDeletes();
            
            $table->foreign('business_id')->references('id')->on('businesses')->cascadeOnDelete();
            
            $table->index('business_id');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('achievements');
    }
};
```

### 2025_12_22_174842_create_cross_domain_auth_tokens_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('cross_domain_auth_tokens', function (Blueprint $table) {
            $table->id();
            $table->foreignId('user_id')->constrained()->onDelete('cascade');
            $table->string('token', 64)->unique();
            $table->string('source_domain')->nullable(); // Domain where login occurred
            $table->json('target_domains')->nullable(); // Domains to sync to
            $table->timestamp('expires_at');
            $table->boolean('used')->default(false);
            $table->timestamps();

            $table->index(['token', 'expires_at', 'used']);
            $table->index('user_id');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('cross_domain_auth_tokens');
    }
};
```

### 2025_12_23_152656_add_alphasite_and_local_voices_to_advertisements_platform_enum.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // For PostgreSQL, we need to alter the enum type
        if (DB::getDriverName() === 'pgsql') {
            DB::statement("ALTER TYPE advertisements_platform_enum ADD VALUE IF NOT EXISTS 'alphasite'");
            DB::statement("ALTER TYPE advertisements_platform_enum ADD VALUE IF NOT EXISTS 'local_voices'");
        } else {
            // For MySQL/SQLite, we need to recreate the column
            // SQLite doesn't support ALTER TABLE DROP COLUMN easily, skip for testing
            if (DB::connection()->getDriverName() === 'sqlite') {
                // For SQLite in testing, the enum values are already correct in the original migration
                // This migration can be skipped
                return;
            }
            
            Schema::table('advertisements', function (Blueprint $table) {
                $table->dropColumn('platform');
            });
            
            Schema::table('advertisements', function (Blueprint $table) {
                $table->enum('platform', ['day_news', 'event_city', 'downtown_guide', 'alphasite', 'local_voices'])->after('id');
            });
        }
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // For PostgreSQL
        if (DB::getDriverName() === 'pgsql') {
            // PostgreSQL doesn't support removing enum values easily
            // We'll need to recreate the column
            Schema::table('advertisements', function (Blueprint $table) {
                $table->dropColumn('platform');
            });
            
            DB::statement("CREATE TYPE advertisements_platform_enum_old AS ENUM ('day_news', 'event_city', 'downtown_guide')");
            
            Schema::table('advertisements', function (Blueprint $table) {
                $table->addColumn('platform', 'advertisements_platform_enum_old')->after('id');
            });
            
            DB::statement("DROP TYPE IF EXISTS advertisements_platform_enum");
            DB::statement("ALTER TYPE advertisements_platform_enum_old RENAME TO advertisements_platform_enum");
        } else {
            // For MySQL/SQLite
            Schema::table('advertisements', function (Blueprint $table) {
                $table->dropColumn('platform');
            });
            
            Schema::table('advertisements', function (Blueprint $table) {
                $table->enum('platform', ['day_news', 'event_city', 'downtown_guide'])->after('id');
            });
        }
    }
};
```

### 2025_12_23_200943_create_ad_campaigns_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('ad_campaigns', function (Blueprint $table) {
            $table->id();
            $table->uuid('uuid')->unique();
            $table->foreignId('advertiser_id')->constrained('businesses')->cascadeOnDelete();
            $table->string('name');
            $table->text('description')->nullable();
            $table->enum('status', ['draft', 'pending', 'active', 'paused', 'completed', 'cancelled'])->default('draft');
            $table->enum('type', ['cpm', 'cpc', 'flat_rate', 'sponsored']);
            $table->decimal('budget', 12, 2);
            $table->decimal('spent', 12, 2)->default(0);
            $table->decimal('daily_budget', 10, 2)->nullable();
            $table->date('start_date');
            $table->date('end_date');
            $table->json('targeting')->nullable(); // communities, demographics, etc.
            $table->json('platforms')->nullable(); // day_news, goeventcity, etc.
            $table->timestamps();
            $table->softDeletes();
            $table->index(['status', 'start_date', 'end_date']);
            $table->index('advertiser_id');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('ad_campaigns');
    }
};
```

### 2025_12_23_200945_create_ad_creatives_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('ad_creatives', function (Blueprint $table) {
            $table->id();
            $table->uuid('uuid')->unique();
            $table->foreignId('campaign_id')->constrained('ad_campaigns')->cascadeOnDelete();
            $table->string('name');
            $table->enum('format', ['leaderboard', 'medium_rectangle', 'sidebar', 'native', 'sponsored_article', 'audio', 'video']);
            $table->string('headline')->nullable();
            $table->text('body')->nullable();
            $table->string('image_url')->nullable();
            $table->string('video_url')->nullable();
            $table->string('audio_url')->nullable();
            $table->string('click_url');
            $table->string('cta_text')->default('Learn More');
            $table->enum('status', ['draft', 'pending_review', 'approved', 'rejected', 'active', 'paused'])->default('draft');
            $table->integer('width')->nullable();
            $table->integer('height')->nullable();
            $table->timestamps();
            $table->softDeletes();
            $table->index(['campaign_id', 'status']);
            $table->index('format');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('ad_creatives');
    }
};
```

### 2025_12_23_200947_create_ad_placements_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('ad_placements', function (Blueprint $table) {
            $table->id();
            $table->string('platform'); // day_news, goeventcity, downtown_guide, alphasite_community, golocalvoices
            $table->string('slot'); // header_leaderboard, sidebar_top, in_article, footer, etc.
            $table->string('name');
            $table->text('description')->nullable();
            $table->string('format'); // leaderboard, medium_rectangle, etc.
            $table->integer('width');
            $table->integer('height');
            $table->decimal('base_cpm', 8, 2);
            $table->decimal('base_cpc', 8, 2)->nullable();
            $table->boolean('is_active')->default(true);
            $table->integer('priority')->default(0);
            $table->timestamps();
            $table->unique(['platform', 'slot']);
            $table->index('platform');
            $table->index('is_active');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('ad_placements');
    }
};
```

### 2025_12_23_200950_create_ad_inventory_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('ad_inventory', function (Blueprint $table) {
            $table->id();
            $table->foreignId('placement_id')->constrained('ad_placements')->cascadeOnDelete();
            $table->foreignId('community_id')->constrained('communities')->cascadeOnDelete();
            $table->date('date');
            $table->integer('total_impressions')->default(0);
            $table->integer('sold_impressions')->default(0);
            $table->integer('delivered_impressions')->default(0);
            $table->decimal('revenue', 10, 2)->default(0);
            $table->timestamps();
            $table->unique(['placement_id', 'community_id', 'date']);
            $table->index(['date', 'placement_id']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('ad_inventory');
    }
};
```

### 2025_12_23_200952_create_ad_impressions_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('ad_impressions', function (Blueprint $table) {
            $table->id();
            $table->foreignId('creative_id')->constrained('ad_creatives')->cascadeOnDelete();
            $table->foreignId('placement_id')->constrained('ad_placements')->cascadeOnDelete();
            $table->foreignId('community_id')->nullable()->constrained('communities')->nullOnDelete();
            $table->string('session_id', 64)->nullable();
            $table->string('ip_hash', 64)->nullable();
            $table->string('user_agent')->nullable();
            $table->string('referrer')->nullable();
            $table->decimal('cost', 8, 4)->default(0);
            $table->timestamp('impressed_at');
            $table->timestamps();
            $table->index(['creative_id', 'impressed_at']);
            $table->index(['placement_id', 'impressed_at']);
            $table->index(['community_id', 'impressed_at']);
            $table->index('impressed_at');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('ad_impressions');
    }
};
```

### 2025_12_23_200954_create_ad_clicks_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('ad_clicks', function (Blueprint $table) {
            $table->id();
            $table->foreignId('impression_id')->constrained('ad_impressions')->cascadeOnDelete();
            $table->foreignId('creative_id')->constrained('ad_creatives')->cascadeOnDelete();
            $table->string('ip_hash', 64)->nullable();
            $table->decimal('cost', 8, 4)->default(0);
            $table->timestamp('clicked_at');
            $table->timestamps();
            $table->index(['creative_id', 'clicked_at']);
            $table->index('clicked_at');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('ad_clicks');
    }
};
```

### 2025_12_23_201529_create_email_subscribers_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('email_subscribers', function (Blueprint $table) {
            $table->id();
            $table->uuid('uuid')->unique();
            $table->string('email')->index();
            $table->string('first_name')->nullable();
            $table->string('last_name')->nullable();
            $table->foreignId('community_id')->constrained('communities')->cascadeOnDelete();
            $table->foreignId('business_id')->nullable()->constrained('businesses')->nullOnDelete();
            $table->enum('type', ['reader', 'smb'])->default('reader');
            $table->enum('status', ['pending', 'active', 'unsubscribed', 'bounced', 'complained'])->default('pending');
            $table->timestamp('confirmed_at')->nullable();
            $table->timestamp('unsubscribed_at')->nullable();
            $table->string('unsubscribe_reason')->nullable();
            $table->json('preferences')->nullable(); // daily_digest, breaking_news, weekly_newsletter
            $table->string('source')->nullable(); // signup_form, import, api, claim
            $table->timestamps();
            $table->softDeletes();
            $table->unique(['email', 'community_id']);
            $table->index(['community_id', 'status', 'type']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('email_subscribers');
    }
};
```

### 2025_12_23_201530_create_email_campaigns_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('email_campaigns', function (Blueprint $table) {
            $table->id();
            $table->uuid('uuid')->unique();
            $table->foreignId('community_id')->constrained('communities')->cascadeOnDelete();
            $table->foreignId('template_id')->nullable()->constrained('email_templates')->nullOnDelete();
            $table->string('name');
            $table->enum('type', ['daily_digest', 'breaking_news', 'weekly_newsletter', 'smb_report', 'emergency', 'custom']);
            $table->enum('status', ['draft', 'scheduled', 'sending', 'sent', 'cancelled'])->default('draft');
            $table->string('subject');
            $table->string('preview_text')->nullable();
            $table->longText('html_content')->nullable();
            $table->longText('text_content')->nullable();
            $table->json('segment')->nullable(); // targeting criteria
            $table->timestamp('scheduled_at')->nullable();
            $table->timestamp('started_at')->nullable();
            $table->timestamp('completed_at')->nullable();
            $table->integer('total_recipients')->default(0);
            $table->integer('sent_count')->default(0);
            $table->integer('delivered_count')->default(0);
            $table->integer('opened_count')->default(0);
            $table->integer('clicked_count')->default(0);
            $table->integer('bounced_count')->default(0);
            $table->integer('complained_count')->default(0);
            $table->integer('unsubscribed_count')->default(0);
            $table->timestamps();
            $table->index(['community_id', 'status']);
            $table->index(['type', 'status']);
            $table->index('scheduled_at');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('email_campaigns');
    }
};
```

### 2025_12_23_201530_create_email_sends_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('email_sends', function (Blueprint $table) {
            $table->id();
            $table->foreignId('campaign_id')->constrained('email_campaigns')->cascadeOnDelete();
            $table->foreignId('subscriber_id')->constrained('email_subscribers')->cascadeOnDelete();
            $table->string('message_id')->nullable()->index();
            $table->enum('status', ['queued', 'sent', 'delivered', 'bounced', 'complained', 'failed'])->default('queued');
            $table->timestamp('sent_at')->nullable();
            $table->timestamp('delivered_at')->nullable();
            $table->timestamp('opened_at')->nullable();
            $table->integer('open_count')->default(0);
            $table->timestamp('clicked_at')->nullable();
            $table->integer('click_count')->default(0);
            $table->string('bounce_type')->nullable();
            $table->text('error_message')->nullable();
            $table->timestamps();
            $table->unique(['campaign_id', 'subscriber_id']);
            $table->index(['campaign_id', 'status']);
            $table->index('sent_at');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('email_sends');
    }
};
```

### 2025_12_23_201530_create_email_templates_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('email_templates', function (Blueprint $table) {
            $table->id();
            $table->uuid('uuid')->unique();
            $table->string('name');
            $table->string('slug')->unique();
            $table->enum('type', ['daily_digest', 'breaking_news', 'weekly_newsletter', 'smb_report', 'emergency', 'transactional']);
            $table->string('subject_template');
            $table->string('preview_text')->nullable();
            $table->longText('html_template');
            $table->longText('text_template')->nullable();
            $table->json('variables')->nullable(); // List of available merge variables
            $table->boolean('is_active')->default(true);
            $table->integer('version')->default(1);
            $table->timestamps();
            $table->index(['type', 'is_active']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('email_templates');
    }
};
```

### 2025_12_23_201530_create_newsletter_subscriptions_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('newsletter_subscriptions', function (Blueprint $table) {
            $table->id();
            $table->foreignId('subscriber_id')->constrained('email_subscribers')->cascadeOnDelete();
            $table->enum('tier', ['free', 'paid'])->default('free');
            $table->decimal('price', 6, 2)->default(1.00);
            $table->string('stripe_subscription_id')->nullable();
            $table->enum('status', ['active', 'cancelled', 'past_due', 'paused'])->default('active');
            $table->timestamp('started_at');
            $table->timestamp('cancelled_at')->nullable();
            $table->timestamp('current_period_end')->nullable();
            $table->timestamps();
            $table->index(['subscriber_id', 'status']);
            $table->index('stripe_subscription_id');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('newsletter_subscriptions');
    }
};
```

### 2025_12_23_201533_create_emergency_alerts_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('emergency_alerts', function (Blueprint $table) {
            $table->id();
            $table->uuid('uuid')->unique();
            $table->foreignId('community_id')->constrained('communities')->cascadeOnDelete();
            $table->foreignId('created_by')->nullable()->constrained('users')->nullOnDelete();
            $table->foreignId('municipal_partner_id')->nullable();
            $table->enum('priority', ['critical', 'urgent', 'advisory', 'info'])->default('advisory');
            $table->string('category'); // weather, crime, health, utility, traffic, government, school, amber
            $table->string('title');
            $table->text('message');
            $table->text('instructions')->nullable();
            $table->string('source')->nullable();
            $table->string('source_url')->nullable();
            $table->enum('status', ['draft', 'active', 'expired', 'cancelled'])->default('draft');
            $table->timestamp('published_at')->nullable();
            $table->timestamp('expires_at')->nullable();
            $table->json('delivery_channels')->nullable(); // email, sms, push
            $table->integer('email_sent')->default(0);
            $table->integer('sms_sent')->default(0);
            $table->timestamps();
            $table->softDeletes();
            $table->index(['community_id', 'status', 'priority']);
            $table->index(['status', 'published_at']);
            $table->index('expires_at');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('emergency_alerts');
    }
};
```

### 2025_12_23_201533_create_emergency_subscriptions_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('emergency_subscriptions', function (Blueprint $table) {
            $table->id();
            $table->foreignId('subscriber_id')->constrained('email_subscribers')->cascadeOnDelete();
            $table->boolean('email_enabled')->default(true);
            $table->boolean('sms_enabled')->default(false);
            $table->string('phone_number')->nullable();
            $table->boolean('phone_verified')->default(false);
            $table->string('phone_verification_code')->nullable();
            $table->timestamp('phone_verified_at')->nullable();
            $table->json('priority_levels')->nullable(); // which priorities to receive
            $table->json('categories')->nullable(); // which categories to receive
            $table->string('stripe_subscription_id')->nullable(); // for SMS tier
            $table->enum('sms_tier', ['none', 'basic'])->default('none');
            $table->timestamps();
            $table->unique('subscriber_id');
            $table->index(['sms_enabled', 'phone_verified']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('emergency_subscriptions');
    }
};
```

### 2025_12_23_201534_create_emergency_audit_log_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('emergency_audit_log', function (Blueprint $table) {
            $table->id();
            $table->foreignId('alert_id')->nullable()->constrained('emergency_alerts')->nullOnDelete();
            $table->foreignId('user_id')->nullable()->constrained('users')->nullOnDelete();
            $table->foreignId('municipal_partner_id')->nullable()->constrained('municipal_partners')->nullOnDelete();
            $table->string('action'); // created, published, updated, cancelled, expired
            $table->json('changes')->nullable();
            $table->string('ip_address')->nullable();
            $table->string('user_agent')->nullable();
            $table->timestamps();
            $table->index(['alert_id', 'created_at']);
            $table->index(['user_id', 'created_at']);
            $table->index('created_at');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('emergency_audit_log');
    }
};
```

### 2025_12_23_201534_create_emergency_deliveries_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('emergency_deliveries', function (Blueprint $table) {
            $table->id();
            $table->foreignId('alert_id')->constrained('emergency_alerts')->cascadeOnDelete();
            $table->foreignId('subscription_id')->constrained('emergency_subscriptions')->cascadeOnDelete();
            $table->enum('channel', ['email', 'sms']);
            $table->enum('status', ['queued', 'sent', 'delivered', 'failed'])->default('queued');
            $table->string('external_id')->nullable(); // SES message ID or SNS message ID
            $table->timestamp('sent_at')->nullable();
            $table->timestamp('delivered_at')->nullable();
            $table->text('error_message')->nullable();
            $table->timestamps();
            $table->unique(['alert_id', 'subscription_id', 'channel']);
            $table->index(['alert_id', 'status']);
            $table->index('sent_at');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('emergency_deliveries');
    }
};
```

### 2025_12_23_201534_create_municipal_partners_table.php
```php
<?php

declare(strict_types=1);

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('municipal_partners', function (Blueprint $table) {
            $table->id();
            $table->uuid('uuid')->unique();
            $table->string('name');
            $table->enum('type', ['municipality', 'law_enforcement', 'school_district', 'utility', 'other']);
            $table->json('community_ids'); // communities they can broadcast to
            $table->foreignId('primary_contact_id')->nullable()->constrained('users')->nullOnDelete();
            $table->string('api_key_hash')->nullable();
            $table->boolean('is_verified')->default(false);
            $table->boolean('is_active')->default(true);
            $table->json('allowed_categories')->nullable();
            $table->json('allowed_priorities')->nullable();
            $table->boolean('requires_approval')->default(true);
            $table->timestamps();
            $table->softDeletes();
            $table->index(['is_active', 'is_verified']);
        });

        // Add foreign key to emergency_alerts
        Schema::table('emergency_alerts', function (Blueprint $table) {
            $table->foreign('municipal_partner_id')
                ->references('id')
                ->on('municipal_partners')
                ->nullOnDelete();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('emergency_alerts', function (Blueprint $table) {
            $table->dropForeign(['municipal_partner_id']);
        });

        Schema::dropIfExists('municipal_partners');
    }
};
```

### 2025_12_24_022805_create_notification_subscriptions_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('notification_subscriptions', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->foreignUuid('user_id')->constrained('users')->onDelete('cascade');
            
            // Platform identification
            $table->enum('platform', ['daynews', 'goeventcity', 'downtownguide', 'alphasite'])->index();
            $table->string('community_id', 100)->nullable()->index();
            $table->uuid('business_id')->nullable(); // for Alphasite SMB notifications
            
            // Subscription endpoints
            $table->string('phone_number', 20)->nullable()->index();
            $table->boolean('phone_verified')->default(false);
            $table->timestamp('phone_verified_at')->nullable();
            
            // Web Push subscription (browser)
            $table->text('web_push_endpoint')->nullable();
            $table->string('web_push_p256dh', 255)->nullable();
            $table->string('web_push_auth', 255)->nullable();
            
            // SNS ARNs (populated after subscription)
            $table->string('sns_sms_subscription_arn', 255)->nullable();
            $table->string('sns_endpoint_arn', 255)->nullable(); // for mobile app push
            
            // Preferences
            $table->json('notification_types')->default('["breaking_news", "events", "deals"]');
            $table->enum('frequency', ['instant', 'daily_digest', 'weekly_digest'])->default('instant');
            $table->time('quiet_hours_start')->default('22:00');
            $table->time('quiet_hours_end')->default('08:00');
            
            // Status
            $table->enum('status', ['active', 'paused', 'unsubscribed'])->default('active')->index();
            
            // Tracking
            $table->timestamps();
            $table->timestamp('last_notification_at')->nullable();
            
            // Unique constraint: one subscription per user/platform/community
            $table->unique(['user_id', 'platform', 'community_id'], 'unique_user_platform_community');
            
            // Composite index for querying active subscriptions
            $table->index(['platform', 'community_id', 'status'], 'idx_platform_community_status');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('notification_subscriptions');
    }
};
```

### 2025_12_24_022809_create_phone_verifications_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('phone_verifications', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('phone_number', 20)->index();
            $table->string('code', 6);
            $table->timestamp('expires_at');
            $table->integer('attempts')->default(0);
            $table->boolean('verified')->default(false);
            $table->timestamps();
            
            // Index for quick lookup during verification
            $table->index(['phone_number', 'code', 'expires_at'], 'idx_phone_code_expires');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('phone_verifications');
    }
};
```

### 2025_12_24_022813_create_notification_log_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('notification_log', function (Blueprint $table) {
            $table->uuid('id')->primary();
            
            // What was sent
            $table->string('platform', 50)->index();
            $table->string('community_id', 100)->nullable()->index();
            $table->string('notification_type', 50)->index();
            $table->enum('channel', ['sms', 'web_push', 'app_push', 'email'])->index();
            
            // Content
            $table->string('title', 255)->nullable();
            $table->text('message');
            $table->json('payload')->nullable();
            
            // Delivery info
            $table->integer('recipient_count')->default(0);
            $table->string('sns_message_id', 255)->nullable();
            
            // Status
            $table->enum('status', ['queued', 'sent', 'failed', 'partial'])->default('queued')->index();
            $table->text('error_message')->nullable();
            
            // Timing
            $table->timestamps();
            $table->timestamp('sent_at')->nullable();
            
            // Composite indexes for reporting
            $table->index(['platform', 'created_at'], 'idx_platform_date');
            $table->index(['community_id', 'created_at'], 'idx_community_date');
            $table->index(['status', 'created_at'], 'idx_status_date');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('notification_log');
    }
};
```

### 2025_12_27_183628_create_tenants_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('tenants', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('name');
            $table->string('subdomain')->unique();
            $table->string('domain')->nullable()->unique();
            $table->string('email')->unique();
            $table->string('phone')->nullable();
            $table->string('address')->nullable();
            $table->string('city')->nullable();
            $table->string('state', 2)->nullable();
            $table->string('postal_code')->nullable();
            $table->string('country', 2)->default('US');
            $table->string('timezone')->default('America/New_York');
            $table->string('locale', 10)->default('en_US');
            $table->string('currency', 3)->default('USD');
            $table->boolean('is_active')->default(true);
            $table->timestamp('trial_ends_at')->nullable();
            $table->json('settings')->nullable();
            $table->json('metadata')->nullable();
            $table->timestamps();
            $table->softDeletes();
            
            $table->index('subdomain');
            $table->index('is_active');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('tenants');
    }
};
```

### 2025_12_27_183629_create_account_managers_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('account_managers', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('tenant_id');
            $table->uuid('user_id');
            
            $table->string('first_name');
            $table->string('last_name');
            $table->string('email')->unique();
            $table->string('phone')->nullable();
            $table->boolean('is_active')->default(true);
            $table->integer('max_accounts')->default(50);
            $table->integer('current_account_count')->default(0);
            $table->json('metadata')->nullable();
            
            $table->timestamps();
            $table->softDeletes();
            
            $table->foreign('tenant_id')->references('id')->on('tenants')->cascadeOnDelete();
            $table->foreign('user_id')->references('id')->on('users')->cascadeOnDelete();
            $table->index('tenant_id');
            $table->index('user_id');
            $table->index('is_active');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('account_managers');
    }
};
```

### 2025_12_27_183629_create_business_hours_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('business_hours', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('smb_business_id');
            
            $table->integer('day_of_week'); // 0 = Sunday, 6 = Saturday
            $table->time('open_time')->nullable();
            $table->time('close_time')->nullable();
            $table->boolean('is_closed')->default(false);
            $table->boolean('is_24_hours')->default(false);
            
            $table->timestamps();
            
            $table->foreign('smb_business_id')->references('id')->on('smb_businesses')->cascadeOnDelete();
            $table->unique(['smb_business_id', 'day_of_week']);
            $table->index('smb_business_id');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('business_hours');
    }
};
```

### 2025_12_27_183629_create_customers_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('customers', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('tenant_id');
            $table->uuid('smb_business_id')->nullable();
            
            // Customer Information
            $table->string('first_name');
            $table->string('last_name');
            $table->string('email')->nullable();
            $table->string('phone')->nullable();
            
            // CRM Fields
            $table->enum('lifecycle_stage', ['lead', 'mql', 'sql', 'customer'])->default('lead');
            $table->integer('lead_score')->default(0);
            $table->enum('lead_source', ['organic', 'paid', 'referral', 'direct'])->nullable();
            $table->boolean('email_opted_in')->default(false);
            $table->boolean('sms_opted_in')->default(false);
            $table->decimal('lifetime_value', 10, 2)->default(0);
            $table->json('tags')->nullable();
            $table->json('custom_fields')->nullable();
            
            $table->timestamps();
            $table->softDeletes();
            
            $table->foreign('tenant_id')->references('id')->on('tenants')->cascadeOnDelete();
            $table->foreign('smb_business_id')->references('id')->on('smb_businesses')->nullOnDelete();
            $table->index('tenant_id');
            $table->index('smb_business_id');
            $table->index('lifecycle_stage');
            $table->index('email');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('customers');
    }
};
```

### 2025_12_27_183629_create_smb_businesses_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('smb_businesses', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('tenant_id');
            
            // REQUIRED - NOT NULL
            $table->string('google_place_id')->unique();
            $table->string('display_name');
            
            // Location - REQUIRED
            $table->decimal('latitude', 10, 8);
            $table->decimal('longitude', 11, 8);
            $table->text('formatted_address');
            $table->json('address_components')->nullable();
            $table->string('plus_code')->nullable();
            $table->json('viewport')->nullable();
            $table->json('location')->nullable();
            
            // Contact - REQUIRED
            $table->string('phone_national');
            $table->string('phone_international')->nullable();
            $table->string('website_url')->nullable();
            
            // Status
            $table->string('business_status')->default('OPERATIONAL');
            $table->enum('fibonacco_status', ['prospect', 'active', 'churned'])->default('prospect');
            
            // Ratings
            $table->decimal('google_rating', 3, 1)->nullable();
            $table->integer('google_rating_count')->default(0);
            $table->integer('user_rating_total')->default(0);
            
            // Service flags - ALL booleans
            $table->boolean('delivery')->default(false);
            $table->boolean('dine_in')->default(false);
            $table->boolean('takeout')->default(false);
            $table->boolean('reservable')->default(false);
            $table->boolean('outdoor_seating')->default(false);
            $table->boolean('serves_breakfast')->default(false);
            $table->boolean('serves_lunch')->default(false);
            $table->boolean('serves_dinner')->default(false);
            $table->boolean('serves_beer')->default(false);
            $table->boolean('serves_wine')->default(false);
            $table->boolean('serves_brunch')->default(false);
            $table->boolean('serves_vegetarian_food')->default(false);
            $table->boolean('wheelchair_accessible_entrance')->default(false);
            
            // JSON fields
            $table->json('place_types')->nullable();
            $table->json('accessibility_options')->nullable();
            $table->json('payment_options')->nullable();
            $table->json('parking_options')->nullable();
            $table->json('data_sources')->nullable();
            $table->json('opening_hours')->nullable();
            $table->json('current_opening_hours')->nullable();
            $table->json('secondary_opening_hours')->nullable();
            $table->json('editorial_summary')->nullable();
            $table->json('photos')->nullable();
            $table->json('reviews')->nullable();
            $table->integer('utc_offset')->nullable();
            $table->text('adr_address')->nullable();
            $table->string('formatted_phone_number')->nullable();
            $table->string('international_phone_number')->nullable();
            $table->integer('price_level')->nullable();
            $table->string('icon')->nullable();
            $table->string('icon_background_color')->nullable();
            $table->string('icon_mask_base_uri')->nullable();
            $table->string('name')->nullable();
            $table->string('place_id')->nullable();
            $table->string('reference')->nullable();
            $table->string('scope')->nullable();
            $table->json('types')->nullable();
            $table->string('url')->nullable();
            $table->string('vicinity')->nullable();
            $table->json('geometry')->nullable();
            $table->boolean('permanently_closed')->default(false);
            $table->timestamp('permanently_closed_time')->nullable();
            
            // Timestamps
            $table->timestamp('last_google_sync_at')->nullable();
            $table->timestamps();
            $table->softDeletes();
            
            $table->foreign('tenant_id')->references('id')->on('tenants')->cascadeOnDelete();
            $table->index('google_place_id');
            $table->index('tenant_id');
            $table->index('fibonacco_status');
            $table->index(['latitude', 'longitude']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('smb_businesses');
    }
};
```

### 2025_12_27_183630_create_business_attributes_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('business_attributes', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('smb_business_id');
            
            $table->string('attribute_key');
            $table->text('attribute_value')->nullable();
            $table->enum('attribute_type', ['boolean', 'string', 'array'])->default('string');
            
            $table->timestamps();
            
            $table->foreign('smb_business_id')->references('id')->on('smb_businesses')->cascadeOnDelete();
            $table->unique(['smb_business_id', 'attribute_key']);
            $table->index('smb_business_id');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('business_attributes');
    }
};
```

### 2025_12_27_183630_create_business_photos_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('business_photos', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('smb_business_id');
            
            $table->string('photo_reference'); // Google Places photo reference
            $table->integer('width');
            $table->integer('height');
            $table->json('html_attributions')->nullable();
            $table->boolean('is_primary')->default(false);
            $table->integer('display_order')->default(0);
            
            $table->timestamps();
            
            $table->foreign('smb_business_id')->references('id')->on('smb_businesses')->cascadeOnDelete();
            $table->index('smb_business_id');
            $table->index(['smb_business_id', 'is_primary']);
            $table->index(['smb_business_id', 'display_order']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('business_photos');
    }
};
```

### 2025_12_27_183630_create_business_reviews_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('business_reviews', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('smb_business_id');
            
            $table->string('author_name');
            $table->string('author_url')->nullable();
            $table->string('language', 10)->default('en');
            $table->string('profile_photo_url')->nullable();
            $table->integer('rating'); // 1-5
            $table->string('relative_time_description')->nullable();
            $table->text('text');
            $table->bigInteger('time'); // Unix timestamp
            
            $table->timestamps();
            
            $table->foreign('smb_business_id')->references('id')->on('smb_businesses')->cascadeOnDelete();
            $table->index('smb_business_id');
            $table->index('rating');
            $table->index('time');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('business_reviews');
    }
};
```

### 2025_12_27_183630_create_deals_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('deals', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('tenant_id');
            $table->uuid('customer_id');
            
            $table->string('name');
            $table->decimal('amount', 10, 2);
            $table->string('currency', 3)->default('USD');
            $table->enum('stage', ['prospecting', 'qualification', 'proposal', 'negotiation', 'closed_won', 'closed_lost'])->default('prospecting');
            $table->integer('probability')->default(0); // 0-100
            $table->date('expected_close_date')->nullable();
            $table->date('actual_close_date')->nullable();
            $table->text('description')->nullable();
            $table->json('tags')->nullable();
            $table->json('custom_fields')->nullable();
            
            $table->timestamps();
            $table->softDeletes();
            
            $table->foreign('tenant_id')->references('id')->on('tenants')->cascadeOnDelete();
            $table->foreign('customer_id')->references('id')->on('customers')->cascadeOnDelete();
            $table->index('tenant_id');
            $table->index('customer_id');
            $table->index('stage');
            $table->index('expected_close_date');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('deals');
    }
};
```

### 2025_12_27_183630_create_interactions_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('interactions', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('tenant_id');
            $table->uuid('customer_id');
            
            $table->enum('type', ['email', 'phone', 'meeting', 'note', 'task', 'social'])->default('note');
            $table->string('subject');
            $table->text('description')->nullable();
            $table->enum('direction', ['inbound', 'outbound'])->default('inbound');
            $table->integer('duration_minutes')->nullable();
            $table->enum('outcome', ['positive', 'neutral', 'negative', 'no_response'])->nullable();
            $table->string('next_action')->nullable();
            $table->date('next_action_date')->nullable();
            $table->json('metadata')->nullable();
            
            $table->timestamps();
            
            $table->foreign('tenant_id')->references('id')->on('tenants')->cascadeOnDelete();
            $table->foreign('customer_id')->references('id')->on('customers')->cascadeOnDelete();
            $table->index('tenant_id');
            $table->index('customer_id');
            $table->index('type');
            $table->index('created_at');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('interactions');
    }
};
```

### 2025_12_27_183630_create_tasks_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('tasks', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('tenant_id');
            $table->uuid('customer_id');
            $table->uuid('assigned_to_id');
            
            $table->string('title');
            $table->text('description')->nullable();
            $table->enum('type', ['call', 'email', 'meeting', 'follow_up', 'other'])->default('other');
            $table->enum('priority', ['low', 'medium', 'high', 'urgent'])->default('medium');
            $table->enum('status', ['pending', 'in_progress', 'completed', 'cancelled'])->default('pending');
            $table->date('due_date')->nullable();
            $table->timestamp('completed_at')->nullable();
            $table->json('metadata')->nullable();
            
            $table->timestamps();
            
            $table->foreign('tenant_id')->references('id')->on('tenants')->cascadeOnDelete();
            $table->foreign('customer_id')->references('id')->on('customers')->cascadeOnDelete();
            $table->foreign('assigned_to_id')->references('id')->on('users')->cascadeOnDelete();
            $table->index('tenant_id');
            $table->index('customer_id');
            $table->index('assigned_to_id');
            $table->index('status');
            $table->index('due_date');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('tasks');
    }
};
```

### 2025_12_27_183631_create_campaign_recipients_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('campaign_recipients', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('campaign_id');
            $table->uuid('customer_id');
            
            $table->enum('status', ['pending', 'sent', 'delivered', 'opened', 'clicked', 'bounced', 'unsubscribed'])->default('pending');
            $table->timestamp('sent_at')->nullable();
            $table->timestamp('delivered_at')->nullable();
            $table->timestamp('opened_at')->nullable();
            $table->timestamp('clicked_at')->nullable();
            $table->timestamp('bounced_at')->nullable();
            $table->timestamp('unsubscribed_at')->nullable();
            $table->json('metadata')->nullable();
            
            $table->timestamps();
            
            $table->foreign('campaign_id')->references('id')->on('campaigns')->cascadeOnDelete();
            $table->foreign('customer_id')->references('id')->on('customers')->cascadeOnDelete();
            $table->unique(['campaign_id', 'customer_id']);
            $table->index('campaign_id');
            $table->index('customer_id');
            $table->index('status');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('campaign_recipients');
    }
};
```

### 2025_12_27_183631_create_campaigns_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('campaigns', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('tenant_id');
            
            $table->string('name');
            $table->enum('type', ['email', 'sms', 'social', 'direct_mail', 'event'])->default('email');
            $table->enum('status', ['draft', 'scheduled', 'active', 'paused', 'completed', 'cancelled'])->default('draft');
            $table->timestamp('start_date')->nullable();
            $table->timestamp('end_date')->nullable();
            $table->decimal('budget', 10, 2)->nullable();
            $table->decimal('spent', 10, 2)->default(0);
            $table->json('target_audience')->nullable();
            $table->text('content')->nullable();
            $table->json('metadata')->nullable();
            
            $table->timestamps();
            $table->softDeletes();
            
            $table->foreign('tenant_id')->references('id')->on('tenants')->cascadeOnDelete();
            $table->index('tenant_id');
            $table->index('status');
            $table->index('start_date');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('campaigns');
    }
};
```

### 2025_12_27_185918_add_tenant_id_to_users_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::table('users', function (Blueprint $table) {
            $table->uuid('tenant_id')->nullable()->after('id');
            $table->foreign('tenant_id')->references('id')->on('tenants')->nullOnDelete();
            $table->index('tenant_id');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('users', function (Blueprint $table) {
            $table->dropForeign(['tenant_id']);
            $table->dropIndex(['tenant_id']);
            $table->dropColumn('tenant_id');
        });
    }
};
```

### 2025_12_28_011832_add_slug_to_events_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::table('events', function (Blueprint $table) {
            if (!Schema::hasColumn('events', 'slug')) {
                $table->string('slug')->nullable()->unique()->after('title');
            }
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('events', function (Blueprint $table) {
            $table->dropColumn('slug');
        });
    }
};
```

### 2025_12_28_011850_add_image_fields_to_events_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::table('events', function (Blueprint $table) {
            if (!Schema::hasColumn('events', 'image_path')) {
                $table->string('image_path')->nullable()->after('image');
            }
            if (!Schema::hasColumn('events', 'image_disk')) {
                $table->string('image_disk')->nullable()->after('image_path');
            }
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('events', function (Blueprint $table) {
            $table->dropColumn(['image_path', 'image_disk']);
        });
    }
};
```

### 2025_12_28_011852_add_source_fields_to_events_table.php
```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::table('events', function (Blueprint $table) {
            if (!Schema::hasColumn('events', 'source_news_article_id')) {
                $table->uuid('source_news_article_id')->nullable()->after('created_by');
            }
            if (!Schema::hasColumn('events', 'source_type')) {
                $table->string('source_type')->nullable()->after('source_news_article_id');
            }
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('events', function (Blueprint $table) {
            $table->dropColumn(['source_news_article_id', 'source_type']);
        });
    }
};
```

---
## Controllers

### app/Http/Controllers/Ads/AdController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Ads;

use App\Http\Controllers\Controller;
use App\Services\AdServerService;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;

final class AdController extends Controller
{
    public function __construct(
        private readonly AdServerService $adService
    ) {}

    /**
     * Serve an ad for a given platform and slot
     */
    public function serve(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'platform' => 'required|string',
            'slot' => 'required|string',
            'community_id' => 'nullable|integer|exists:communities,id',
        ]);

        $ad = $this->adService->getAd(
            $validated['platform'],
            $validated['slot'],
            $validated['community_id'] ?? null,
            $request->session()->getId()
        );

        if (!$ad) {
            return response()->json(['ad' => null]);
        }

        return response()->json(['ad' => $ad]);
    }

    /**
     * Track a click and redirect
     */
    public function click(Request $request, int $impression): RedirectResponse
    {
        $url = $this->adService->recordClick($impression);

        if (!$url) {
            return redirect('/')->with('error', 'Invalid ad impression.');
        }

        return redirect($url);
    }
}
```

### app/Http/Controllers/Settings/BillingController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Settings;

use App\Http\Controllers\Controller;
use App\Services\StripeConnectService;
use Exception;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Inertia\Inertia;
use Inertia\Response;

final class BillingController extends Controller
{
    public function __construct(
        private StripeConnectService $stripeService
    ) {}

    /**
     * Show the billing/payouts page
     */
    public function show(Request $request): Response
    {
        $workspace = $request->user()->currentWorkspace;

        return Inertia::render('event-city/settings/workspace/billing', [
            'workspace' => [
                'id' => $workspace->id,
                'name' => $workspace->name,
                'stripe_connect_id' => $workspace->stripe_connect_id,
                'stripe_charges_enabled' => $workspace->stripe_charges_enabled,
                'stripe_payouts_enabled' => $workspace->stripe_payouts_enabled,
                'stripe_admin_approved' => $workspace->stripe_admin_approved,
                'can_accept_payments' => $workspace->canAcceptPayments(),
            ],
            'canManage' => $workspace->owner->id === $request->user()->id,
        ]);
    }

    /**
     * Start Stripe Connect onboarding
     */
    public function connectStripe(Request $request): JsonResponse
    {
        $workspace = $request->user()->currentWorkspace;

        Log::info('Stripe Connect: Starting onboarding', [
            'workspace_id' => $workspace->id,
            'has_stripe_id' => ! empty($workspace->stripe_connect_id),
            'stripe_id' => $workspace->stripe_connect_id,
        ]);

        try {
            // Create onboarding session - Stripe will handle account creation
            Log::info('Stripe Connect: Creating onboarding session', [
                'workspace_id' => $workspace->id,
                'workspace_name' => $workspace->name,
            ]);

            $onboardingUrl = $this->stripeService->createOnboardingSession(
                $workspace,
                route('settings.workspace.billing.stripe-refresh'),
                route('settings.workspace.billing.stripe-return')
            );

            Log::info('Stripe Connect: Onboarding session created', [
                'workspace_id' => $workspace->id,
            ]);

            return response()->json([
                'url' => $onboardingUrl,
            ]);
        } catch (Exception $e) {
            Log::error('Stripe Connect: Failed to start onboarding', [
                'workspace_id' => $workspace->id,
                'error' => $e->getMessage(),
                'exception' => get_class($e),
                'file' => $e->getFile(),
                'line' => $e->getLine(),
            ]);

            $errorMessage = $e->getMessage();

            // Provide helpful error messages for common Stripe issues
            if (str_contains($errorMessage, 'Please review the responsibilities')) {
                $errorMessage = 'Please configure your Stripe Connect platform settings at https://dashboard.stripe.com/settings/connect/platform-profile before setting up payments.';
            } elseif (str_contains($errorMessage, 'Not a valid URL')) {
                $errorMessage = 'Invalid URL. Please ensure your APP_URL is set to a valid public URL (not localhost) in production.';
            }

            return response()->json([
                'error' => 'Failed to start Stripe Connect onboarding: '.$errorMessage,
            ], 500);
        }
    }

    /**
     * Handle Stripe Connect onboarding return
     */
    public function stripeReturn(Request $request): RedirectResponse
    {
        $workspace = $request->user()->currentWorkspace;

        Log::info('Stripe Connect: Return callback received', [
            'workspace_id' => $workspace->id,
            'is_authenticated' => $request->user() !== null,
            'stripe_connect_id' => $workspace->stripe_connect_id,
        ]);

        // Retrieve and store account ID from Stripe session if not already stored
        try {
            $this->stripeService->handleOnboardingReturn($workspace);

            Log::info('Stripe Connect: Onboarding return handled', [
                'workspace_id' => $workspace->id,
                'stripe_connect_id' => $workspace->fresh()->stripe_connect_id,
                'can_accept_payments' => $workspace->fresh()->canAcceptPayments(),
            ]);
        } catch (Exception $e) {
            Log::error('Stripe Connect: Failed to handle onboarding return', [
                'workspace_id' => $workspace->id,
                'error' => $e->getMessage(),
            ]);

            return redirect()->route('settings.workspace.billing')
                ->with('error', 'Failed to complete Stripe setup. Please try again.');
        }

        $workspace = $workspace->fresh();

        if ($workspace->canAcceptPayments()) {
            return redirect()->route('settings.workspace.billing')
                ->with('success', 'Stripe Connect setup completed! You can now accept payments.');
        }

        return redirect()->route('settings.workspace.billing')
            ->with('info', 'Please complete additional requirements to start accepting payments.');
    }

    /**
     * Handle Stripe Connect onboarding refresh
     */
    public function stripeRefresh(Request $request): RedirectResponse
    {
        $workspace = $request->user()->currentWorkspace;

        try {
            $onboardingUrl = $this->stripeService->createOnboardingSession(
                $workspace,
                route('settings.workspace.billing.stripe-refresh'),
                route('settings.workspace.billing.stripe-return')
            );

            return redirect($onboardingUrl);
        } catch (Exception $e) {
            return redirect()->route('settings.workspace.billing')
                ->with('error', 'Failed to refresh onboarding: '.$e->getMessage());
        }
    }

    /**
     * Get Stripe dashboard link
     */
    public function stripeDashboard(Request $request): JsonResponse
    {
        $workspace = $request->user()->currentWorkspace;

        try {
            $url = $this->stripeService->createDashboardLink($workspace);

            return response()->json([
                'url' => $url,
            ]);
        } catch (Exception $e) {
            return response()->json([
                'error' => 'Failed to open Stripe dashboard: '.$e->getMessage(),
            ], 500);
        }
    }
}
```

### app/Http/Controllers/Settings/WorkspaceSettingsController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Settings;

use App\Http\Controllers\Controller;
use App\Models\WorkspaceInvitation;
use App\Models\WorkspaceMembership;
use App\Notifications\WorkspaceInvitationNotification;
use Exception;
use Illuminate\Foundation\Auth\Access\AuthorizesRequests;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Notification;
use Illuminate\Validation\Rule;
use Inertia\Inertia;
use Inertia\Response;

final class WorkspaceSettingsController extends Controller
{
    use AuthorizesRequests;

    /**
     * Show the workspace overview page
     */
    public function showOverview(Request $request): Response
    {
        if (! config('makerkit.workspaces.enabled')) {
            abort(404, 'Workspaces are not enabled');
        }

        $user = $request->user();
        $workspace = $user->currentWorkspace;

        if (! $workspace) {
            abort(404, 'No current workspace found');
        }

        // Check if user can manage workspace
        $canManage = $user->hasAllPermissions(['workspace.settings.manage'], $workspace->id);

        return Inertia::render('event-city/settings/workspace/overview', [
            'workspace' => [
                'id' => $workspace->id,
                'name' => $workspace->name,
                'slug' => $workspace->slug,
                'logo' => $workspace->logo,
                'owner_id' => $workspace->owner_id,
            ],
            'canManage' => $canManage,
        ]);
    }

    /**
     * Show the workspace members page
     */
    public function showMembers(Request $request): Response
    {
        if (! config('makerkit.workspaces.enabled')) {
            abort(404, 'Workspaces are not enabled');
        }

        $user = $request->user();
        $workspace = $user->currentWorkspace;

        if (! $workspace) {
            abort(404, 'No current workspace found');
        }

        // Check if user can manage workspace
        $canManage = $user->hasAllPermissions(['workspace.users.manage'], $workspace->id);

        // Get workspace members with their details
        $members = $workspace->members()
            ->with('user')
            ->get()
            ->map(function ($membership) {
                return [
                    'id' => $membership->id,
                    'user_id' => $membership->user_id,
                    'name' => $membership->user->name,
                    'email' => $membership->user->email,
                    'avatar' => $membership->user->avatar,
                    'role' => $membership->role,
                    'created_at' => $membership->created_at,
                    'is_owner' => $membership->role === 'owner',
                ];
            });

        // Get pending invitations
        $pendingInvitations = $workspace->invitations()
            ->with('inviter')
            ->pending()
            ->get()
            ->map(function ($invitation) {
                return [
                    'id' => $invitation->id,
                    'email' => $invitation->email,
                    'role' => $invitation->role,
                    'invited_by' => $invitation->inviter->name,
                    'expires_at' => $invitation->expires_at,
                    'created_at' => $invitation->created_at,
                ];
            });

        return Inertia::render('event-city/settings/workspace/members', [
            'members' => $members,
            'pendingInvitations' => $pendingInvitations,
            'canManage' => $canManage,
            'availableRoles' => ['member', 'admin'],
        ]);
    }

    /**
     * Update workspace settings
     */
    public function update(Request $request): RedirectResponse
    {
        if (! config('makerkit.workspaces.enabled')) {
            abort(404, 'Workspaces are not enabled');
        }

        $user = $request->user();
        $workspace = $user->currentWorkspace;

        if (! $workspace) {
            abort(404, 'No current workspace found');
        }

        // Check permissions
        $canManage = $user->hasAllPermissions(['workspace.settings.manage'], $workspace->id);
        if (! $canManage) {
            abort(403, 'Insufficient permissions');
        }

        $validated = $request->validate([
            'name' => 'required|string|max:255',
        ]);

        $workspace->update($validated);

        return back()->with('success', 'Workspace updated successfully');
    }

    /**
     * Invite a user to the workspace
     */
    public function inviteUser(Request $request): RedirectResponse
    {
        if (! config('makerkit.workspaces.enabled')) {
            abort(404, 'Workspaces are not enabled');
        }

        $user = $request->user();
        $workspace = $user->currentWorkspace;

        if (! $workspace) {
            abort(404, 'No current workspace found');
        }

        // Check permissions
        $canManage = $user->hasAllPermissions(['workspace.users.manage'], $workspace->id);
        if (! $canManage) {
            abort(403, 'Insufficient permissions to invite users');
        }

        $validated = $request->validate([
            'email' => [
                'required',
                'email',
                'max:255',
                Rule::unique('workspace_invitations')->where(function ($query) use ($workspace) {
                    return $query->where('workspace_id', $workspace->id)
                        ->whereNull('accepted_at')
                        ->where('expires_at', '>', now());
                }),
            ],
            'role' => 'required|in:member,admin',
        ]);

        // Check if user is already a member
        $existingMember = WorkspaceMembership::where('workspace_id', $workspace->id)
            ->whereHas('user', function ($query) use ($validated) {
                $query->where('email', $validated['email']);
            })
            ->exists();

        if ($existingMember) {
            return back()->withErrors(['email' => 'This user is already a member of the workspace']);
        }

        // Create invitation
        $invitation = WorkspaceInvitation::create([
            'workspace_id' => $workspace->id,
            'invited_by' => $user->id,
            'email' => $validated['email'],
            'role' => $validated['role'],
            'token' => WorkspaceInvitation::generateToken(),
            'expires_at' => now()->addDays(7),
        ]);

        // Send invitation email
        try {
            Notification::route('mail', $invitation->email)
                ->notify(new WorkspaceInvitationNotification($invitation));
        } catch (Exception $e) {
            // Log error but don't fail the invitation
            logger()->error('Failed to send invitation email', [
                'invitation_id' => $invitation->id,
                'error' => $e->getMessage(),
            ]);
        }

        return back()->with('success', 'Invitation sent successfully');
    }

    /**
     * Update a member's role
     */
    public function updateMemberRole(Request $request, WorkspaceMembership $membership): RedirectResponse
    {
        if (! config('makerkit.workspaces.enabled')) {
            abort(404, 'Workspaces are not enabled');
        }

        $user = $request->user();
        $workspace = $user->currentWorkspace;

        if (! $workspace || $membership->workspace_id !== $workspace->id) {
            abort(404, 'Member not found');
        }

        // Check permissions
        $canManage = $user->hasAllPermissions(['workspace.users.manage'], $workspace->id);
        if (! $canManage) {
            abort(403, 'Insufficient permissions');
        }

        $validated = $request->validate([
            'role' => 'required|in:member,admin',
        ]);

        // Prevent users from changing their own role
        if ($membership->user_id === $user->id) {
            return back()->withErrors(['role' => 'You cannot change your own role']);
        }

        // Prevent changing workspace owner
        if ($membership->role === 'owner') {
            return back()->withErrors(['role' => 'Cannot change the workspace owner role']);
        }

        $membership->update(['role' => $validated['role']]);

        return back()->with('success', 'Member role updated successfully');
    }

    /**
     * Remove a member from the workspace
     */
    public function removeMember(Request $request, WorkspaceMembership $membership): RedirectResponse
    {
        if (! config('makerkit.workspaces.enabled')) {
            abort(404, 'Workspaces are not enabled');
        }

        $user = $request->user();
        $workspace = $user->currentWorkspace;

        if (! $workspace || $membership->workspace_id !== $workspace->id) {
            abort(404, 'Member not found');
        }

        // Check permissions
        $canManage = $user->hasAllPermissions(['workspace.users.manage'], $workspace->id);
        if (! $canManage) {
            abort(403, 'Insufficient permissions');
        }

        // Prevent removing workspace owner
        if ($membership->role === 'owner') {
            return back()->withErrors(['error' => 'Cannot remove the workspace owner']);
        }

        // Prevent users from removing themselves
        if ($membership->user_id === $user->id) {
            return back()->withErrors(['error' => 'You cannot remove yourself from the workspace']);
        }

        return DB::transaction(function () use ($membership, $workspace) {
            // Remove the member
            $memberUser = $membership->user;
            $membership->delete();

            // If the removed user had this as their current workspace, clear it
            if ($memberUser->current_workspace_id === $workspace->id) {
                // Try to set another workspace as current
                $anotherMembership = $memberUser->workspaceMemberships()->first();
                $memberUser->update([
                    'current_workspace_id' => $anotherMembership ? $anotherMembership->workspace_id : null,
                ]);
            }

            return back()->with('success', 'Member removed successfully');
        });
    }

    /**
     * Cancel a pending invitation
     */
    public function cancelInvitation(Request $request, WorkspaceInvitation $invitation): RedirectResponse
    {
        if (! config('makerkit.workspaces.enabled')) {
            abort(404, 'Workspaces are not enabled');
        }

        $user = $request->user();
        $workspace = $user->currentWorkspace;

        if (! $workspace || $invitation->workspace_id !== $workspace->id) {
            abort(404, 'Invitation not found');
        }

        // Check permissions
        $canManage = $user->hasAllPermissions(['workspace.users.manage'], $workspace->id);
        if (! $canManage) {
            abort(403, 'Insufficient permissions');
        }

        $invitation->delete();

        return back()->with('success', 'Invitation cancelled successfully');
    }
}
```

### app/Http/Controllers/Settings/ProfileController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Settings;

use App\Http\Controllers\Controller;
use App\Http\Requests\Settings\ProfileUpdateRequest;
use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Inertia\Inertia;
use Inertia\Response;

final class ProfileController extends Controller
{
    /**
     * Show the user's profile settings page.
     */
    public function edit(Request $request): Response
    {
        return Inertia::render('event-city/settings/profile', [
            'mustVerifyEmail' => $request->user() instanceof MustVerifyEmail,
            'status' => $request->session()->get('status'),
        ]);
    }

    /**
     * Update the user's profile settings.
     */
    public function update(ProfileUpdateRequest $request): RedirectResponse
    {
        $request->user()->fill($request->validated());

        if ($request->user()->isDirty('email')) {
            $request->user()->email_verified_at = null;
        }

        $request->user()->save();

        return to_route('profile.edit');
    }

    /**
     * Delete the user's account.
     */
    public function destroy(Request $request): RedirectResponse
    {
        $request->validate([
            'password' => ['required', 'current_password'],
        ]);

        $user = $request->user();

        Auth::logout();

        $user->delete();

        $request->session()->invalidate();
        $request->session()->regenerateToken();

        return redirect('/');
    }
}
```

### app/Http/Controllers/Settings/PasswordController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Settings;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rules\Password;
use Inertia\Inertia;
use Inertia\Response;

final class PasswordController extends Controller
{
    /**
     * Show the user's password settings page.
     */
    public function edit(): Response
    {
        return Inertia::render('event-city/settings/password');
    }

    /**
     * Update the user's password.
     */
    public function update(Request $request): RedirectResponse
    {
        $validated = $request->validate([
            'current_password' => ['required', 'current_password'],
            'password' => ['required', Password::defaults(), 'confirmed'],
        ]);

        $request->user()->update([
            'password' => Hash::make($validated['password']),
        ]);

        return back();
    }
}
```

### app/Http/Controllers/PromoCodeController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\PromoCode;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Inertia\Inertia;
use Inertia\Response;

final class PromoCodeController extends Controller
{
    public function index(Request $request): Response
    {
        $query = PromoCode::query();

        if ($request->filled('search')) {
            $query->where('code', 'ILIKE', "%{$request->input('search')}%");
        }

        if ($request->boolean('active_only')) {
            $query->active();
        }

        $promoCodes = $query->latest()->paginate(20);

        return Inertia::render('event-city/promo-codes/index', [
            'promoCodes' => $promoCodes,
            'filters' => [
                'search' => $request->input('search'),
                'active_only' => $request->boolean('active_only'),
            ],
        ]);
    }

    public function create(): Response
    {
        return Inertia::render('event-city/promo-codes/create');
    }

    public function store(Request $request): RedirectResponse
    {
        $validated = $request->validate([
            'code' => 'nullable|string|max:50|unique:promo_codes,code',
            'description' => 'nullable|string',
            'type' => 'required|in:percentage,fixed',
            'value' => 'required|numeric|min:0',
            'min_purchase' => 'nullable|numeric|min:0',
            'max_discount' => 'nullable|numeric|min:0',
            'usage_limit' => 'nullable|integer|min:1',
            'is_active' => 'boolean',
            'starts_at' => 'nullable|date',
            'expires_at' => 'nullable|date|after:starts_at',
            'applicable_to' => 'nullable|array',
        ]);

        if (empty($validated['code'])) {
            $validated['code'] = PromoCode::generateUniqueCode();
        }

        $promoCode = PromoCode::create($validated);

        return redirect()->route('promo-codes.show', $promoCode)
            ->with('success', 'Promo code created successfully.');
    }

    public function show(PromoCode $promoCode): Response
    {
        $promoCode->loadCount('usages');

        return Inertia::render('event-city/promo-codes/show', [
            'promoCode' => $promoCode,
        ]);
    }

    public function edit(PromoCode $promoCode): Response
    {
        return Inertia::render('event-city/promo-codes/edit', [
            'promoCode' => $promoCode,
        ]);
    }

    public function update(Request $request, PromoCode $promoCode): RedirectResponse
    {
        $validated = $request->validate([
            'code' => 'sometimes|string|max:50|unique:promo_codes,code,'.$promoCode->id,
            'description' => 'nullable|string',
            'type' => 'sometimes|in:percentage,fixed',
            'value' => 'sometimes|numeric|min:0',
            'min_purchase' => 'nullable|numeric|min:0',
            'max_discount' => 'nullable|numeric|min:0',
            'usage_limit' => 'nullable|integer|min:1',
            'is_active' => 'boolean',
            'starts_at' => 'nullable|date',
            'expires_at' => 'nullable|date|after:starts_at',
            'applicable_to' => 'nullable|array',
        ]);

        $promoCode->update($validated);

        return redirect()->route('promo-codes.show', $promoCode)
            ->with('success', 'Promo code updated successfully.');
    }

    public function destroy(PromoCode $promoCode): RedirectResponse
    {
        $promoCode->delete();

        return redirect()->route('promo-codes.index')
            ->with('success', 'Promo code deleted successfully.');
    }

    public function validate(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'code' => 'required|string',
            'amount' => 'required|numeric|min:0',
            'event_id' => 'nullable|uuid|exists:events,id',
        ]);

        $promoCode = PromoCode::where('code', strtoupper($validated['code']))->first();

        if (!$promoCode) {
            return response()->json([
                'valid' => false,
                'message' => 'Invalid promo code.',
            ], 404);
        }

        if (!$promoCode->isValid()) {
            return response()->json([
                'valid' => false,
                'message' => 'This promo code is no longer valid.',
            ], 400);
        }

        // Check if applicable to event
        if ($validated['event_id'] && $promoCode->applicable_to) {
            if (!in_array($validated['event_id'], $promoCode->applicable_to)) {
                return response()->json([
                    'valid' => false,
                    'message' => 'This promo code is not applicable to this event.',
                ], 400);
            }
        }

        $discount = $promoCode->calculateDiscount((float) $validated['amount']);

        return response()->json([
            'valid' => true,
            'promo_code' => [
                'id' => $promoCode->id,
                'code' => $promoCode->code,
                'type' => $promoCode->type,
                'value' => $promoCode->value,
            ],
            'discount' => $discount,
            'final_amount' => (float) $validated['amount'] - $discount,
        ]);
    }
}
```

### app/Http/Controllers/NotificationController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\Notification;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class NotificationController extends Controller
{
    public function index(Request $request): Response
    {
        $notifications = Notification::forUser($request->user()->id)
            ->latest()
            ->paginate(20);

        return Inertia::render('event-city/notifications/index', [
            'notifications' => $notifications,
        ]);
    }

    public function getUnread(Request $request): JsonResponse
    {
        $notifications = Notification::forUser($request->user()->id)
            ->unread()
            ->latest()
            ->limit(10)
            ->get();

        return response()->json([
            'notifications' => $notifications,
            'unread_count' => Notification::forUser($request->user()->id)->unread()->count(),
        ]);
    }

    public function markAsRead(Request $request, Notification $notification): JsonResponse
    {
        if ($notification->user_id !== $request->user()->id) {
            return response()->json(['message' => 'Unauthorized'], 403);
        }

        $notification->markAsRead();

        return response()->json(['message' => 'Notification marked as read']);
    }

    public function markAllAsRead(Request $request): JsonResponse
    {
        Notification::forUser($request->user()->id)
            ->unread()
            ->update(['read' => true]);

        return response()->json(['message' => 'All notifications marked as read']);
    }
}
```

### app/Http/Controllers/SocialGroupPostController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\SocialGroup;
use App\Models\SocialGroupPost;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Inertia\Inertia;
use Inertia\Response;

final class SocialGroupPostController extends Controller
{
    public function index(SocialGroup $group): Response
    {
        $user = Auth::user();

        if ($group->isSecret() && ! $user->isMemberOfGroup($group)) {
            abort(404);
        }

        $posts = $group->posts()
            ->with(['user', 'group'])
            ->where('is_active', true)
            ->orderByDesc('is_pinned')
            ->orderByDesc('created_at')
            ->paginate(20);

        return Inertia::render('event-city/social/groups/posts', [
            'group' => [
                ...$group->toArray(),
                'user_membership' => $group->members()->where('user_id', $user->id)->first(),
            ],
            'posts' => $posts,
        ]);
    }

    public function store(SocialGroup $group, Request $request): JsonResponse
    {
        $user = Auth::user();

        if (! $user->isMemberOfGroup($group)) {
            return response()->json(['error' => 'You must be a group member to post'], 403);
        }

        $request->validate([
            'content' => ['required', 'string', 'max:2000'],
            'media' => ['nullable', 'array'],
            'media.*' => ['string', 'url'],
        ]);

        $post = SocialGroupPost::create([
            'group_id' => $group->id,
            'user_id' => $user->id,
            'content' => $request->content,
            'media' => $request->media,
            'is_active' => true,
        ]);

        $post->load(['user', 'group']);

        return response()->json([
            'message' => 'Post created successfully',
            'post' => $post,
        ]);
    }

    public function show(SocialGroup $group, SocialGroupPost $post): Response
    {
        $user = Auth::user();

        if ($group->isSecret() && ! $user->isMemberOfGroup($group)) {
            abort(404);
        }

        if ($post->group_id !== $group->id) {
            abort(404);
        }

        $post->load(['user', 'group']);

        return Inertia::render('event-city/social/groups/post-show', [
            'group' => [
                ...$group->toArray(),
                'user_membership' => $group->members()->where('user_id', $user->id)->first(),
            ],
            'post' => $post,
        ]);
    }

    public function update(SocialGroup $group, SocialGroupPost $post, Request $request): JsonResponse
    {
        $user = Auth::user();

        if ($post->user_id !== $user->id) {
            return response()->json(['error' => 'Not authorized'], 403);
        }

        if ($post->group_id !== $group->id) {
            return response()->json(['error' => 'Invalid group'], 400);
        }

        $request->validate([
            'content' => ['required', 'string', 'max:2000'],
            'media' => ['nullable', 'array'],
            'media.*' => ['string', 'url'],
        ]);

        $post->update([
            'content' => $request->content,
            'media' => $request->media,
        ]);

        $post->load(['user', 'group']);

        return response()->json([
            'message' => 'Post updated successfully',
            'post' => $post,
        ]);
    }

    public function destroy(SocialGroup $group, SocialGroupPost $post): JsonResponse
    {
        $user = Auth::user();

        $membership = $group->members()->where('user_id', $user->id)->first();

        if ($post->user_id !== $user->id && (! $membership || ! in_array($membership->role, ['admin', 'moderator']))) {
            return response()->json(['error' => 'Not authorized'], 403);
        }

        if ($post->group_id !== $group->id) {
            return response()->json(['error' => 'Invalid group'], 400);
        }

        $post->update(['is_active' => false]);

        return response()->json(['message' => 'Post deleted successfully']);
    }

    public function pin(SocialGroup $group, SocialGroupPost $post): JsonResponse
    {
        $user = Auth::user();

        $membership = $group->members()->where('user_id', $user->id)->first();
        if (! $membership || ! in_array($membership->role, ['admin', 'moderator'])) {
            return response()->json(['error' => 'No permission to pin posts'], 403);
        }

        if ($post->group_id !== $group->id) {
            return response()->json(['error' => 'Invalid group'], 400);
        }

        $post->update(['is_pinned' => ! $post->is_pinned]);

        $action = $post->is_pinned ? 'pinned' : 'unpinned';

        return response()->json(['message' => "Post {$action} successfully"]);
    }
}
```

### app/Http/Controllers/Controller.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use Illuminate\Foundation\Auth\Access\AuthorizesRequests;

abstract class Controller
{
    use AuthorizesRequests;
}
```

### app/Http/Controllers/TicketOrderController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\TicketOrder;
use App\Models\TicketPlan;
use App\Notifications\TicketOrderConfirmationNotification;
use App\Services\PromoCodeService;
use App\Services\QRCodeService;
use App\Services\TicketPaymentService;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;

final class TicketOrderController extends Controller
{
    public function __construct(
        private readonly TicketPaymentService $ticketPaymentService,
        private readonly QRCodeService $qrCodeService
    ) {}
    public function index(Request $request): JsonResponse
    {
        $query = TicketOrder::query()
            ->with(['event', 'items.ticketPlan']);

        if ($request->user()) {
            $query->forUser($request->user()->id);
        }

        if ($request->has('event_id')) {
            $query->forEvent($request->query('event_id'));
        }

        if ($request->has('status')) {
            $query->where('status', $request->query('status'));
        }

        $orders = $query->latest()->paginate(10);

        return response()->json($orders);
    }

    public function store(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'event_id' => 'required|uuid|exists:events,id',
            'items' => 'required|array|min:1',
            'items.*.ticket_plan_id' => 'required|uuid|exists:ticket_plans,id',
            'items.*.quantity' => 'required|integer|min:1',
            'promo_code' => 'nullable|array',
            'billing_info' => 'nullable|array',
        ]);

        return DB::transaction(function () use ($validated, $request) {
            $subtotal = 0;
            $orderItems = [];

            foreach ($validated['items'] as $item) {
                $ticketPlan = TicketPlan::find($item['ticket_plan_id']);

                if ($ticketPlan->available_quantity < $item['quantity']) {
                    return response()->json([
                        'error' => "Not enough tickets available for {$ticketPlan->name}",
                    ], 400);
                }

                $totalPrice = $ticketPlan->price * $item['quantity'];
                $subtotal += $totalPrice;

                $orderItems[] = [
                    'ticket_plan_id' => $ticketPlan->id,
                    'quantity' => $item['quantity'],
                    'unit_price' => $ticketPlan->price,
                    'total_price' => $totalPrice,
                ];

                $ticketPlan->decrement('available_quantity', $item['quantity']);
            }

            $fees = $subtotal > 0 ? $subtotal * 0.1 : 0;
            $discount = 0;
            $promoCode = null;

            // Use PromoCodeService for promo code validation
            if (isset($validated['promo_code']['code'])) {
                $promoCodeService = app(PromoCodeService::class);
                $validation = $promoCodeService->validateCode(
                    $validated['promo_code']['code'],
                    $subtotal,
                    $validated['event_id'] ?? null
                );

                if ($validation['valid']) {
                    $discount = $validation['discount'];
                    $promoCode = $validation['promo_code'];
                }
            }

            $total = round($subtotal + $fees - $discount, 2);
            $isFree = $total <= 0;

            $order = TicketOrder::create([
                'event_id' => $validated['event_id'],
                'user_id' => $request->user()->id,
                'status' => $isFree ? 'completed' : 'pending',
                'subtotal' => $subtotal,
                'fees' => $fees,
                'discount' => $discount,
                'total' => $total,
                'promo_code' => $promoCode ? ['code' => $promoCode->code, 'discount' => $discount] : null,
                'billing_info' => $validated['billing_info'] ?? null,
                'payment_status' => $isFree ? 'completed' : 'pending',
                'completed_at' => $isFree ? now() : null,
            ]);

            foreach ($orderItems as $item) {
                $order->items()->create([
                    ...$item,
                    'ticket_order_id' => $order->id,
                ]);
            }

            // Record promo code usage if applicable
            if ($promoCode && $discount > 0) {
                $promoCodeService = app(PromoCodeService::class);
                $promoCodeService->applyCode($promoCode, $order, $request->user());
            }

            // Generate QR codes for completed orders (free tickets)
            if ($isFree) {
                foreach ($order->items as $item) {
                    $this->qrCodeService->generateForTicketOrderItem($item);
                }
                // Send confirmation email for free tickets
                $order->user->notify(new TicketOrderConfirmationNotification($order));
                return response()->json($order->load(['items.ticketPlan', 'event']), 201);
            }

            // Create Stripe checkout session for paid orders
            $successUrl = route('tickets.checkout.success', ['order' => $order->id]);
            $cancelUrl = route('tickets.checkout.cancel', ['order' => $order->id]);

            try {
                $session = $this->ticketPaymentService->createCheckoutSession($order, $successUrl, $cancelUrl);

                return response()->json([
                    'order' => $order->load(['items.ticketPlan', 'event']),
                    'checkout_session' => [
                        'id' => $session->id,
                        'url' => $session->url,
                    ],
                ], 201);
            } catch (\Exception $e) {
                // If Stripe checkout fails, mark order as failed
                $order->update([
                    'status' => 'cancelled',
                    'payment_status' => 'failed',
                ]);

                // Restore ticket quantities
                foreach ($order->items as $item) {
                    $item->ticketPlan->increment('available_quantity', $item->quantity);
                }

                return response()->json([
                    'error' => 'Failed to create checkout session: '.$e->getMessage(),
                ], 500);
            }
        });
    }

    public function show(TicketOrder $ticketOrder): JsonResponse
    {
        $ticketOrder->load(['event', 'items.ticketPlan', 'user']);

        return response()->json($ticketOrder);
    }

    public function update(Request $request, TicketOrder $ticketOrder): JsonResponse
    {
        $validated = $request->validate([
            'status' => 'string|in:pending,completed,cancelled',
            'payment_status' => 'string|in:pending,completed,failed',
            'payment_intent_id' => 'nullable|string',
        ]);

        if (isset($validated['status']) && $validated['status'] === 'completed' && ! $ticketOrder->completed_at) {
            $validated['completed_at'] = now();
        }

        $ticketOrder->update($validated);

        return response()->json($ticketOrder);
    }

    public function destroy(TicketOrder $ticketOrder): JsonResponse
    {
        if ($ticketOrder->status === 'completed') {
            return response()->json(['error' => 'Cannot delete completed orders'], 400);
        }

        DB::transaction(function () use ($ticketOrder) {
            foreach ($ticketOrder->items as $item) {
                $item->ticketPlan->increment('available_quantity', $item->quantity);
            }

            $ticketOrder->delete();
        });

        return response()->json(['message' => 'Order deleted successfully']);
    }

    /**
     * Handle successful ticket checkout
     */
    public function checkoutSuccess(Request $request, TicketOrder $ticketOrder): RedirectResponse
    {
        // Verify the order belongs to the user
        if ($request->user() && $ticketOrder->user_id !== $request->user()->id) {
            abort(403);
        }

        // If order is already completed, redirect to my tickets
        if ($ticketOrder->status === 'completed') {
            return redirect()->route('tickets.my-tickets')->with('success', 'Your tickets have been confirmed!');
        }

        // Check payment status
        if ($ticketOrder->payment_status === 'completed') {
            $ticketOrder->update([
                'status' => 'completed',
                'completed_at' => now(),
            ]);

            // Generate QR codes for all ticket items
            foreach ($ticketOrder->items as $item) {
                if (!$item->qr_code) {
                    $this->qrCodeService->generateForTicketOrderItem($item);
                }
            }

            // Send confirmation email
            $ticketOrder->user->notify(new TicketOrderConfirmationNotification($ticketOrder));

            return redirect()->route('tickets.my-tickets')->with('success', 'Your tickets have been confirmed!');
        }

        // If payment is still pending, show pending message
        return redirect()->route('tickets.my-tickets')->with('info', 'Your payment is being processed. You will receive a confirmation email shortly.');
    }

    /**
     * Handle cancelled ticket checkout
     */
    public function checkoutCancel(Request $request, TicketOrder $ticketOrder): RedirectResponse
    {
        // Restore ticket quantities
        DB::transaction(function () use ($ticketOrder) {
            foreach ($ticketOrder->items as $item) {
                $item->ticketPlan->increment('available_quantity', $item->quantity);
            }

            // Mark order as cancelled
            $ticketOrder->update([
                'status' => 'cancelled',
                'payment_status' => 'cancelled',
            ]);
        });

        return redirect()->route('events.tickets.selection', ['event' => $ticketOrder->event_id])
            ->with('error', 'Your order was cancelled. Please try again if you wish to purchase tickets.');
    }
}
```

### app/Http/Controllers/OrganizationController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\Business;
use App\Services\OrganizationService;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Inertia\Inertia;
use Inertia\Response;

final class OrganizationController extends Controller
{
    public function __construct(
        private readonly OrganizationService $organizationService
    ) {}

    /**
     * Get all content related to an organization
     */
    public function getContent(Request $request, Business $organization): JsonResponse|Response
    {
        $contentTypes = $request->input('types', []);
        $relationshipTypes = $request->input('relationship_types', []);
        $includeHierarchy = $request->boolean('include_hierarchy', false);

        if ($includeHierarchy) {
            $content = $this->organizationService->getOrganizationContentWithHierarchy(
                $organization,
                $contentTypes
            );
        } else {
            $content = $this->organizationService->getOrganizationContent(
                $organization,
                $contentTypes,
                $relationshipTypes
            );
        }

        $hierarchy = $this->organizationService->getOrganizationHierarchy($organization);

        if ($request->wantsJson()) {
            return response()->json([
                'organization' => $organization,
                'content' => $content,
                'hierarchy' => $hierarchy,
            ]);
        }

        return Inertia::render('organizations/content', [
            'organization' => $organization,
            'content' => $content,
            'hierarchy' => $hierarchy,
        ]);
    }

    /**
     * Create relationship between organization and content
     */
    public function relate(Request $request, Business $organization): JsonResponse
    {
        $request->validate([
            'relatable_type' => 'required|string',
            'relatable_id' => 'required|uuid',
            'relationship_type' => 'required|string|in:related,sponsored,featured,partner,host,organizer,venue,sponsor,author,source,subject',
            'is_primary' => 'boolean',
            'metadata' => 'array',
        ]);

        $relatableClass = $request->input('relatable_type');
        $relatableId = $request->input('relatable_id');
        
        $relatable = $relatableClass::findOrFail($relatableId);

        $relationship = $this->organizationService->createRelationship(
            $relatable,
            $organization,
            $request->input('relationship_type'),
            $request->boolean('is_primary', false),
            $request->input('metadata', [])
        );

        return response()->json([
            'message' => 'Relationship created successfully',
            'relationship' => $relationship->load('relatable'),
        ], 201);
    }

    /**
     * Search organizations
     */
    public function search(Request $request): JsonResponse|Response
    {
        $request->validate([
            'q' => 'required|string|min:2',
            'type' => 'nullable|string',
            'level' => 'nullable|string',
            'category' => 'nullable|string',
        ]);

        $organizations = $this->organizationService->searchOrganizations(
            $request->input('q'),
            $request->only(['type', 'level', 'category'])
        );

        // Get content counts for each organization
        $organizationsWithCounts = $organizations->map(function ($org) {
            $content = $this->organizationService->getOrganizationContent($org);
            return [
                'id' => $org->id,
                'name' => $org->name,
                'organization_type' => $org->organization_type,
                'organization_level' => $org->organization_level,
                'organization_category' => $org->organization_category,
                'content_count' => [
                    'articles' => count($content['App\Models\DayNewsPost'] ?? []),
                    'events' => count($content['App\Models\Event'] ?? []),
                    'coupons' => count($content['App\Models\Coupon'] ?? []),
                    'announcements' => count($content['App\Models\Announcement'] ?? []),
                ],
            ];
        });

        if ($request->wantsJson()) {
            return response()->json([
                'data' => $organizationsWithCounts,
            ]);
        }

        return Inertia::render('organizations/search', [
            'organizations' => $organizationsWithCounts,
            'query' => $request->input('q'),
        ]);
    }

    /**
     * Get organization hierarchy
     */
    public function hierarchy(Business $organization): JsonResponse|Response
    {
        $hierarchy = $this->organizationService->getOrganizationHierarchy($organization);

        if (request()->wantsJson()) {
            return response()->json($hierarchy);
        }

        return Inertia::render('organizations/hierarchy', [
            'hierarchy' => $hierarchy,
        ]);
    }
}

```

### app/Http/Controllers/EventController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Http\Requests\StoreEventRequest;
use App\Models\Event;
use App\Models\Follow;
use App\Models\Performer;
use App\Models\Region;
use App\Models\Venue;
use App\Services\AdvertisementService;
use App\Services\CacheService;
use App\Services\EventService;
use App\Services\LocationService;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Cache;
use Inertia\Inertia;
use Inertia\Response;

final class EventController extends Controller
{
    public function __construct(
        private readonly CacheService $cacheService,
        private readonly EventService $eventService,
        private readonly AdvertisementService $advertisementService,
        private readonly LocationService $locationService
    ) {}
    /**
     * Public events page (no authentication required)
     */
    public function publicIndex(Request $request): Response
    {
        // Get current workspace
        $currentWorkspace = null;
        if ($request->user()) {
            $user = $request->user();
            $currentWorkspace = $user->currentWorkspace ?? $user->workspaces->first();
        }

        // Get featured events using EventService
        $featuredEvents = $this->eventService->getFeatured(6)->map(function ($event) {
            return [
                'id' => $event->id,
                'title' => $event->title,
                'date' => $event->event_date->format('Y-m-d\TH:i:s.000\Z'),
                'venue' => $event->venue?->name ?? 'TBA',
                'price' => $event->is_free ? 'Free' : '$'.number_format((float) ($event->price_min ?? 0)),
                'category' => $event->category,
                'image' => $event->image,
            ];
        })->toArray();

        // Get upcoming events (next 7 days) using EventService
        $upcomingFilters = [
            'date_from' => now(),
            'date_to' => now()->addDays(7),
            'sort_by' => 'event_date',
            'sort_order' => 'asc',
        ];
        $upcomingEvents = $this->eventService->getUpcoming($upcomingFilters, 50)->items();
        
        $upcomingEvents = collect($upcomingEvents)->map(function ($event) {
            $eventDateTime = $event->event_date->copy();
            if ($event->time) {
                $timeParts = explode(':', $event->time);
                $eventDateTime->setTime((int) $timeParts[0], (int) $timeParts[1]);
            }

            return [
                'id' => $event->id,
                'title' => $event->title,
                'date' => $eventDateTime->format('Y-m-d\TH:i:s.000\Z'),
                'venue' => $event->venue?->name ?? 'TBA',
                'price' => $event->is_free ? 'Free' : '$'.number_format((float) ($event->price_min ?? 0)),
                'category' => $event->category,
                'image' => $event->image ?? 'https://images.unsplash.com/photo-1514525253161-7a46d19cd819?w=400&h=300&fit=crop',
            ];
        })->toArray();

        // Get current region for ad targeting
        $region = $request->attributes->get('detected_region');

        // Get advertisements for different placements
        $bannerAds = $this->advertisementService->getActiveAds('event_city', $region, 'banner')->take(1);
        $sidebarAds = $this->advertisementService->getActiveAds('event_city', $region, 'sidebar')->take(3);

        return Inertia::render('event-city/events/index', [
            'featuredEvents' => $featuredEvents,
            'upcomingEvents' => $upcomingEvents,
            'advertisements' => [
                'banner' => $bannerAds->map(fn ($ad) => $this->formatAd($ad)),
                'sidebar' => $sidebarAds->map(fn ($ad) => $this->formatAd($ad)),
            ],
        ]);
    }

    public function index(Request $request): Response
    {
        $currentWorkspace = $request->user()->currentWorkspace;

        if (! $currentWorkspace) {
            abort(403, 'No workspace selected');
        }

        $query = Event::where('workspace_id', $currentWorkspace->id)
            ->with(['venue', 'performer', 'createdBy'])
            ->withCount('bookings');

        // Apply filters
        if ($request->filled('status')) {
            $query->where('status', $request->status);
        }

        if ($request->filled('category')) {
            $query->where('category', $request->category);
        }

        if ($request->filled('is_free')) {
            $query->where('is_free', $request->boolean('is_free'));
        }

        if ($request->filled('venue_id')) {
            $query->where('venue_id', $request->venue_id);
        }

        if ($request->filled('performer_id')) {
            $query->where('performer_id', $request->performer_id);
        }

        if ($request->filled('search')) {
            $search = $request->search;
            $query->where(function ($q) use ($search) {
                $q->where('title', 'like', "%{$search}%")
                    ->orWhere('description', 'like', "%{$search}%");
            });
        }

        if ($request->filled('date_from')) {
            $query->where('event_date', '>=', $request->date_from);
        }

        if ($request->filled('date_to')) {
            $query->where('event_date', '<=', $request->date_to);
        }

        // Sorting
        $sortBy = $request->get('sort', 'event_date');
        $sortDirection = $request->get('direction', 'asc');

        match ($sortBy) {
            'title' => $query->orderBy('title', $sortDirection),
            'rating' => $query->orderBy('community_rating', $sortDirection),
            'attendance' => $query->orderBy('member_attendance', $sortDirection),
            'created_at' => $query->orderBy('created_at', $sortDirection),
            default => $query->orderBy('event_date', $sortDirection),
        };

        $events = $query->paginate(12)->withQueryString();

        // Get current region for ad targeting
        $region = $request->attributes->get('detected_region');

        // Get advertisements
        $sidebarAds = $this->advertisementService->getActiveAds('event_city', $region, 'sidebar')->take(3);

        return Inertia::render('event-city/events/index', [
            'events' => $events,
            'filters' => $request->only(['status', 'category', 'is_free', 'venue_id', 'performer_id', 'search', 'date_from', 'date_to']),
            'sort' => ['sort' => $sortBy, 'direction' => $sortDirection],
            'advertisements' => [
                'sidebar' => $sidebarAds->map(fn ($ad) => $this->formatAd($ad)),
            ],
        ]);
    }

    public function show(Request $request, Event $event): Response
    {
        $event->load([
            'venue',
            'performer.upcomingShows',
            'workspace',
            'createdBy',
            'bookings.createdBy',
            'ticketPlans' => function ($query) {
                $query->where('is_active', true)->orderBy('sort_order');
            },
        ]);

        // Get similar events using EventService
        $similarEvents = $this->eventService->getRelated($event, 6)->map(function ($e) {
            return [
                'id' => $e->id,
                'title' => $e->title,
                'date' => $e->event_date->format('Y-m-d\TH:i:s.000\Z'),
                'venue' => $e->venue?->name ?? 'TBA',
                'price' => $e->is_free ? 'Free' : '$'.number_format((float) ($e->price_min ?? 0)),
                'category' => $e->category,
                'image' => $e->image,
            ];
        });

        $isFollowing = false;
        $canEdit = false;

        if ($request->user()) {
            $isFollowing = Follow::where('user_id', $request->user()->id)
                ->where('followable_type', Event::class)
                ->where('followable_id', $event->id)
                ->exists();

            $canEdit = $request->user()->can('update', $event);
        }

        // Get weather data (cached - weather service already has caching)
        $weather = null;
        if ($event->latitude && $event->longitude) {
            try {
                $weatherService = app(\App\Services\WeatherService::class);
                $weather = $weatherService->getWeatherForEvent($event);
            } catch (\Exception $e) {
                // Weather service failed, continue without weather
            }
        }

        // Get check-in status
        $isCheckedIn = false;
        if ($request->user()) {
            $isCheckedIn = \App\Models\CheckIn::where('event_id', $event->id)
                ->where('user_id', $request->user()->id)
                ->exists();
        }

        // Get recent check-ins
        $recentCheckIns = \App\Models\CheckIn::where('event_id', $event->id)
            ->with('user')
            ->public()
            ->recent(24)
            ->latest('checked_in_at')
            ->limit(10)
            ->get();

        // Get current region for ad targeting
        $region = $request->attributes->get('detected_region') ?? $event->regions->first();

        // Get advertisements for different placements
        $bannerAds = $this->advertisementService->getActiveAds('event_city', $region, 'banner')->take(1);
        $sidebarAds = $this->advertisementService->getActiveAds('event_city', $region, 'sidebar')->take(3);
        $inlineAds = $this->advertisementService->getActiveAds('event_city', $region, 'inline')->take(2);

        return Inertia::render('event-city/events/event-detail', [
            'event' => array_merge($event->toArray(), [
                'weather' => $weather,
            ]),
            'similarEvents' => $similarEvents,
            'isFollowing' => $isFollowing,
            'canEdit' => $canEdit,
            'isCheckedIn' => $isCheckedIn,
            'recentCheckIns' => $recentCheckIns,
            'advertisements' => [
                'banner' => $bannerAds->map(fn ($ad) => $this->formatAd($ad)),
                'sidebar' => $sidebarAds->map(fn ($ad) => $this->formatAd($ad)),
                'inline' => $inlineAds->map(fn ($ad) => $this->formatAd($ad)),
            ],
        ]);
    }

    public function featured(Request $request): array
    {
        $currentWorkspace = $request->user()->currentWorkspace;

        if (! $currentWorkspace) {
            return [];
        }

        $events = Event::where('workspace_id', $currentWorkspace->id)
            ->where('status', 'published')
            ->where('event_date', '>=', now())
            ->whereIn('badges', [['Featured']])
            ->orWhere('community_rating', '>=', 4.0)
            ->with(['venue', 'performer'])
            ->orderBy('community_rating', 'desc')
            ->orderBy('member_attendance', 'desc')
            ->limit(6)
            ->get()
            ->map(function ($event) {
                return [
                    'id' => $event->id,
                    'title' => $event->title,
                    'date' => $event->event_date->toISOString(),
                    'time' => $event->time,
                    'venue' => [
                        'name' => $event->venue?->name ?? 'TBD',
                        'city' => $event->venue?->neighborhood ?? 'Unknown',
                    ],
                    'price' => [
                        'isFree' => $event->is_free,
                        'min' => $event->price_min,
                        'max' => $event->price_max,
                    ],
                    'category' => $event->category,
                    'image' => $event->image ?: '/images/event-placeholder.jpg',
                ];
            });

        return $events->toArray();
    }

    public function upcoming(Request $request): array
    {
        $currentWorkspace = $request->user()->currentWorkspace;

        if (! $currentWorkspace) {
            return [];
        }

        $events = Event::where('workspace_id', $currentWorkspace->id)
            ->where('status', 'published')
            ->where('event_date', '>=', now())
            ->with(['venue', 'performer'])
            ->orderBy('event_date', 'asc')
            ->limit(10)
            ->get()
            ->map(function ($event) {
                return [
                    'id' => $event->id,
                    'title' => $event->title,
                    'date' => $event->event_date->toISOString(),
                    'time' => $event->time,
                    'venue' => [
                        'name' => $event->venue?->name ?? 'TBD',
                        'city' => $event->venue?->neighborhood ?? 'Unknown',
                    ],
                    'price' => [
                        'isFree' => $event->is_free,
                        'min' => $event->price_min,
                        'max' => $event->price_max,
                    ],
                    'category' => $event->category,
                    'image' => $event->image ?: '/images/event-placeholder.jpg',
                ];
            });

        return $events->toArray();
    }

    public function create(): Response
    {
        $currentWorkspace = auth()->user()->currentWorkspace;

        if (! $currentWorkspace) {
            abort(403, 'Please select a workspace first.');
        }

        $this->authorize('create', Event::class);

        $venues = Venue::where('workspace_id', $currentWorkspace->id)
            ->where('status', 'active')
            ->get(['id', 'name', 'address']);

        $performers = Performer::where('workspace_id', $currentWorkspace->id)
            ->where('status', 'active')
            ->where('available_for_booking', true)
            ->get(['id', 'name', 'genres']);

        return Inertia::render('event-city/events/create', [
            'venues' => $venues,
            'performers' => $performers,
            'workspace' => [
                'can_accept_payments' => $currentWorkspace->canAcceptPayments(),
            ],
        ]);
    }

    public function store(StoreEventRequest $request)
    {
        $this->authorize('create', Event::class);

        $currentWorkspace = $request->user()->currentWorkspace;

        if (! $currentWorkspace) {
            abort(403, 'No workspace selected');
        }

        $validated = $request->validated();

        // Handle image uploads
        $imagePaths = [];
        if ($request->hasFile('images')) {
            foreach ($request->file('images') as $index => $image) {
                $path = $image->store('events', 'public');
                $imagePaths[] = $path;

                // Set first image as main event image
                if ($index === 0 && ! isset($validated['image'])) {
                    $validated['image'] = $path;
                }
            }
        }

        // Handle new venue creation if provided
        if (! empty($validated['new_venue'])) {
            $venue = Venue::create([
                ...$validated['new_venue'],
                'price_per_hour' => '0.00',
                'price_per_event' => '0.00',
                'price_per_day' => '0.00',
                'workspace_id' => $currentWorkspace->id,
                'created_by' => $request->user()->id,
                'status' => 'active',
                'listed_date' => now(),
            ]);
            $validated['venue_id'] = $venue->id;
            unset($validated['new_venue']);
        }

        // Handle new performer creation if provided
        if (! empty($validated['new_performer'])) {
            $performer = Performer::create([
                ...$validated['new_performer'],
                'home_city' => $validated['new_performer']['home_city'] ?? 'Unknown',
                'base_price' => '0.00',
                'travel_fee_per_mile' => '0.00',
                'setup_fee' => '0.00',
                'currency' => 'USD',
                'minimum_booking_hours' => 2,
                'workspace_id' => $currentWorkspace->id,
                'created_by' => $request->user()->id,
                'status' => 'active',
                'follower_count' => 0,
                'trending_score' => 0,
                'added_date' => now(),
            ]);
            $validated['performer_id'] = $performer->id;
            unset($validated['new_performer']);
        }

        if ($validated['is_free'] ?? false) {
            $validated['price_min'] = 0;
            $validated['price_max'] = 0;
        }

        $event = Event::create([
            ...$validated,
            'workspace_id' => $currentWorkspace->id,
            'created_by' => $request->user()->id,
            'status' => 'draft',
            'community_rating' => 0,
            'member_attendance' => 0,
            'member_recommendations' => 0,
            'discussion_thread_id' => 'thread-'.fake()->randomNumber(6),
        ]);

        return response()->json([
            'id' => $event->id,
            'message' => 'Event created successfully!',
        ], 201);
    }

    public function edit(Event $event): Response
    {
        $this->authorize('update', $event);

        $event->load('workspace');

        $venues = Venue::where('workspace_id', $event->workspace_id)
            ->where('status', 'active')
            ->get(['id', 'name', 'address']);

        $performers = Performer::where('workspace_id', $event->workspace_id)
            ->where('status', 'active')
            ->where('available_for_booking', true)
            ->get(['id', 'name', 'genres']);

        return Inertia::render('event-city/events/edit', [
            'event' => $event,
            'venues' => $venues,
            'performers' => $performers,
            'workspace' => [
                'can_accept_payments' => $event->workspace->canAcceptPayments(),
            ],
        ]);
    }

    public function update(Request $request, Event $event)
    {
        $this->authorize('update', $event);

        $validated = $request->validate([
            'title' => 'required|string|max:255',
            'description' => 'required|string',
            'event_date' => 'required|date',
            'time' => 'required|string',
            'venue_id' => 'nullable|exists:venues,id',
            'performer_id' => 'nullable|exists:performers,id',
            'category' => 'required|string',
            'subcategories' => 'array',
            'badges' => 'array',
            'is_free' => 'boolean',
            'price_min' => 'required_unless:is_free,true|numeric|min:0',
            'price_max' => 'required_unless:is_free,true|numeric|min:0',
            'image' => 'nullable|url',
            'curator_notes' => 'nullable|string',
            'latitude' => 'nullable|numeric',
            'longitude' => 'nullable|numeric',
            'status' => 'in:draft,published,cancelled,completed',
        ]);

        if ($validated['is_free']) {
            $validated['price_min'] = 0;
            $validated['price_max'] = 0;
        }

        $event->update($validated);

        return redirect()->route('events.show', $event)
            ->with('success', 'Event updated successfully!');
    }

    public function destroy(Event $event)
    {
        $this->authorize('delete', $event);

        $event->delete();

        return redirect()->route('events.index')
            ->with('success', 'Event deleted successfully!');
    }

    /**
     * Format advertisement for frontend
     */
    private function formatAd($ad): array
    {
        return [
            'id' => $ad->id,
            'placement' => $ad->placement,
            'advertable' => [
                'id' => $ad->advertable->id,
                'title' => $ad->advertable->title ?? $ad->advertable->name ?? null,
                'excerpt' => $ad->advertable->excerpt ?? $ad->advertable->description ?? null,
                'featured_image' => $ad->advertable->featured_image ?? $ad->advertable->image ?? $ad->advertable->profile_image ?? null,
                'slug' => $ad->advertable->slug ?? null,
            ],
            'expires_at' => $ad->expires_at->toISOString(),
        ];
    }
}
```

### app/Http/Controllers/StripeWebhookController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\DayNewsPostPayment;
use App\Models\Order;
use App\Models\Product;
use App\Models\Store;
use App\Models\TicketOrder;
use App\Notifications\TicketOrderConfirmationNotification;
use App\Services\DayNewsPostService;
use App\Services\QRCodeService;
use Exception;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Stripe\Exception\SignatureVerificationException;
use Stripe\Webhook;

final class StripeWebhookController extends Controller
{
    /**
     * Handle Stripe webhook events
     */
    public function __invoke(Request $request): JsonResponse
    {
        $payload = $request->getContent();
        $sigHeader = $request->header('Stripe-Signature');
        $webhookSecret = config('services.stripe.webhook_secret');

        try {
            $event = Webhook::constructEvent($payload, $sigHeader, $webhookSecret);
        } catch (SignatureVerificationException $e) {
            Log::error('Stripe webhook signature verification failed: '.$e->getMessage());

            return response()->json(['error' => 'Invalid signature'], 400);
        } catch (Exception $e) {
            Log::error('Stripe webhook error: '.$e->getMessage());

            return response()->json(['error' => 'Webhook error'], 400);
        }

        // Handle the event
        try {
            match ($event->type) {
                'account.updated' => $this->handleAccountUpdated($event->data->object),
                'checkout.session.completed' => $this->handleCheckoutSessionCompleted($event->data->object),
                'payment_intent.succeeded' => $this->handlePaymentIntentSucceeded($event->data->object),
                'payment_intent.payment_failed' => $this->handlePaymentIntentFailed($event->data->object),
                'charge.refunded' => $this->handleChargeRefunded($event->data->object),
                default => Log::info('Unhandled Stripe webhook event: '.$event->type),
            };

            return response()->json(['status' => 'success']);
        } catch (Exception $e) {
            Log::error('Error handling Stripe webhook: '.$e->getMessage(), [
                'event_type' => $event->type,
                'event_id' => $event->id,
            ]);

            return response()->json(['error' => 'Processing error'], 500);
        }
    }

    /**
     * Handle account.updated event
     */
    private function handleAccountUpdated(object $account): void
    {
        $store = Store::where('stripe_connect_id', $account->id)->first();

        if ($store) {
            $store->update([
                'stripe_charges_enabled' => $account->charges_enabled ?? false,
                'stripe_payouts_enabled' => $account->payouts_enabled ?? false,
            ]);

            Log::info('Updated store Stripe capabilities', [
                'store_id' => $store->id,
                'charges_enabled' => $account->charges_enabled,
                'payouts_enabled' => $account->payouts_enabled,
            ]);
        }
    }

    /**
     * Handle checkout.session.completed event
     */
    private function handleCheckoutSessionCompleted(object $session): void
    {
        // Check if this is a Day News post payment
        if (isset($session->metadata->payment_id)) {
            $this->handleDayNewsPayment($session);

            return;
        }

        // Check if this is a ticket order
        if (isset($session->metadata->ticket_order_id)) {
            $this->handleTicketOrderPayment($session);

            return;
        }

        // Otherwise, handle as ecommerce order
        $order = Order::where('stripe_payment_intent_id', $session->payment_intent)->first();

        if (! $order) {
            Log::warning('Order not found for checkout session', [
                'payment_intent' => $session->payment_intent,
            ]);

            return;
        }

        $order->update([
            'payment_status' => 'paid',
            'status' => 'processing',
            'paid_at' => now(),
        ]);

        // Reduce product inventory
        foreach ($order->items as $item) {
            if ($item->product && $item->product->track_inventory) {
                $product = $item->product;
                $product->decrement('quantity', $item->quantity);

                if ($product->quantity <= 0) {
                    $product->update(['is_active' => false]);
                }
            }
        }

        Log::info('Order marked as paid', ['order_id' => $order->id]);
    }

    /**
     * Handle payment_intent.succeeded event
     */
    private function handlePaymentIntentSucceeded(object $paymentIntent): void
    {
        // Check for ticket order first
        $ticketOrder = TicketOrder::where('payment_intent_id', $paymentIntent->id)->first();

        if ($ticketOrder && $ticketOrder->payment_status !== 'completed') {
            DB::transaction(function () use ($ticketOrder, $paymentIntent) {
                $ticketOrder->update([
                    'status' => 'completed',
                    'payment_status' => 'completed',
                    'payment_intent_id' => $paymentIntent->id,
                    'completed_at' => now(),
                ]);

                // Generate QR codes for all ticket items
                $qrCodeService = app(QRCodeService::class);
                foreach ($ticketOrder->items as $item) {
                    if (!$item->qr_code) {
                        $qrCodeService->generateForTicketOrderItem($item);
                    }
                }

                // Send confirmation email
                $ticketOrder->user->notify(new TicketOrderConfirmationNotification($ticketOrder));

                Log::info('Ticket order payment succeeded', ['order_id' => $ticketOrder->id]);
            });

            return;
        }

        // Otherwise, handle as ecommerce order
        $order = Order::where('stripe_payment_intent_id', $paymentIntent->id)->first();

        if ($order && $order->payment_status !== 'paid') {
            $order->update([
                'payment_status' => 'paid',
                'status' => 'processing',
                'stripe_charge_id' => $paymentIntent->charges->data[0]->id ?? null,
                'paid_at' => now(),
            ]);

            // Reduce product inventory
            foreach ($order->items as $item) {
                if ($item->product && $item->product->track_inventory) {
                    $product = $item->product;
                    $product->decrement('quantity', $item->quantity);

                    if ($product->quantity <= 0) {
                        $product->update(['is_active' => false]);
                    }
                }
            }

            Log::info('Payment succeeded', ['order_id' => $order->id]);
        }
    }

    /**
     * Handle payment_intent.payment_failed event
     */
    private function handlePaymentIntentFailed(object $paymentIntent): void
    {
        // Check for ticket order first
        $ticketOrder = TicketOrder::where('payment_intent_id', $paymentIntent->id)->first();

        if ($ticketOrder) {
            DB::transaction(function () use ($ticketOrder, $paymentIntent) {
                // Restore ticket quantities
                foreach ($ticketOrder->items as $item) {
                    $item->ticketPlan->increment('available_quantity', $item->quantity);
                }

                $ticketOrder->update([
                    'status' => 'cancelled',
                    'payment_status' => 'failed',
                ]);

                Log::info('Ticket order payment failed', [
                    'order_id' => $ticketOrder->id,
                    'error' => $paymentIntent->last_payment_error->message ?? 'Unknown error',
                ]);
            });

            return;
        }

        // Otherwise, handle as ecommerce order
        $order = Order::where('stripe_payment_intent_id', $paymentIntent->id)->first();

        if ($order) {
            $order->update([
                'payment_status' => 'failed',
                'notes' => $paymentIntent->last_payment_error->message ?? 'Payment failed',
            ]);

            Log::info('Payment failed', [
                'order_id' => $order->id,
                'error' => $paymentIntent->last_payment_error->message ?? 'Unknown error',
            ]);
        }
    }

    /**
     * Handle charge.refunded event
     */
    private function handleChargeRefunded(object $charge): void
    {
        $order = Order::where('stripe_charge_id', $charge->id)->first();

        if ($order) {
            $order->update([
                'payment_status' => 'refunded',
                'status' => 'cancelled',
            ]);

            // Restore product inventory
            foreach ($order->items as $item) {
                if ($item->product && $item->product->track_inventory) {
                    $product = $item->product;
                    $product->increment('quantity', $item->quantity);
                    $product->update(['is_active' => true]);
                }
            }

            Log::info('Order refunded', ['order_id' => $order->id]);
        }
    }

    /**
     * Handle Day News post payment
     */
    private function handleDayNewsPayment(object $session): void
    {
        $paymentId = $session->metadata->payment_id ?? null;

        if (! $paymentId) {
            Log::warning('Day News payment ID not found in session metadata', [
                'session_id' => $session->id,
            ]);

            return;
        }

        $payment = DayNewsPostPayment::find($paymentId);

        if (! $payment) {
            Log::warning('Day News payment not found', [
                'payment_id' => $paymentId,
            ]);

            return;
        }

        // Mark payment as paid
        $payment->stripe_session_id = $session->id;
        $payment->stripe_payment_intent_id = $session->payment_intent;
        $payment->markAsPaid();

        // Publish the post
        $postService = app(DayNewsPostService::class);
        $postService->publishPost($payment->post);

        Log::info('Day News post payment completed', [
            'payment_id' => $payment->id,
            'post_id' => $payment->post_id,
        ]);
    }

    /**
     * Handle ticket order payment
     */
    private function handleTicketOrderPayment(object $session): void
    {
        $ticketOrderId = $session->metadata->ticket_order_id ?? null;

        if (! $ticketOrderId) {
            Log::warning('Ticket order ID not found in session metadata', [
                'session_id' => $session->id,
            ]);

            return;
        }

        $ticketOrder = TicketOrder::find($ticketOrderId);

        if (! $ticketOrder) {
            Log::warning('Ticket order not found', [
                'order_id' => $ticketOrderId,
            ]);

            return;
        }

        DB::transaction(function () use ($ticketOrder, $session) {
            $ticketOrder->update([
                'status' => 'completed',
                'payment_status' => 'completed',
                'payment_intent_id' => $session->payment_intent,
                'completed_at' => now(),
            ]);

            // Generate QR codes for all ticket items
            $qrCodeService = app(QRCodeService::class);
            foreach ($ticketOrder->items as $item) {
                if (!$item->qr_code) {
                    $qrCodeService->generateForTicketOrderItem($item);
                }
            }

            // Send confirmation email
            $ticketOrder->user->notify(new TicketOrderConfirmationNotification($ticketOrder));

            Log::info('Ticket order payment completed', [
                'order_id' => $ticketOrder->id,
                'event_id' => $ticketOrder->event_id,
            ]);
        });
    }
}
```

### app/Http/Controllers/SocialController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Http\Requests\Social\CreateCommentRequest;
use App\Http\Requests\Social\CreatePostRequest;
use App\Http\Requests\Social\UpdateProfileRequest;
use App\Models\SocialActivity;
use App\Models\SocialFriendship;
use App\Models\SocialPost;
use App\Models\SocialPostComment;
use App\Models\SocialPostLike;
use App\Models\SocialUserProfile;
use App\Models\User;
use Exception;
use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Auth;
use Inertia\Inertia;
use Inertia\Response;
use Log;

final class SocialController extends Controller
{
    public function index(): Response
    {
        $user = Auth::user();

        // Load posts with proper relationships and counts
        $posts = SocialPost::with(['user', 'likes.user', 'comments.user'])
            ->where('is_active', true)
            ->where(function ($query) use ($user) {
                $query->where('visibility', 'public')
                    ->orWhere('user_id', $user->id)
                    ->orWhere(function ($q) use ($user) {
                        $q->where('visibility', 'friends')
                            ->whereHas('user.friendships', function ($friendQuery) use ($user) {
                                $friendQuery->where(function ($subQuery) use ($user) {
                                    $subQuery->where('user_id', $user->id)
                                        ->orWhere('friend_id', $user->id);
                                })->where('status', 'accepted');
                            });
                    });
            })
            ->latest()
            ->limit(20)
            ->get()
            ->map(function ($post) use ($user) {
                return [
                    ...$post->toArray(),
                    'likes_count' => $post->likesCount(),
                    'comments_count' => $post->commentsCount(),
                    'shares_count' => $post->sharesCount(),
                    'is_liked_by_user' => $post->isLikedBy($user),
                    'recent_comments' => $post->comments()->with('user')->latest()->limit(3)->get(),
                ];
            });

        $userProfile = $user->socialProfile ?: new SocialUserProfile(['user_id' => $user->id]);

        // Get suggested friends (users not already friends with)
        $suggestedFriends = User::whereNotIn('id', function ($query) use ($user) {
            $query->select('friend_id')
                ->from('social_friendships')
                ->where('user_id', $user->id);
        })
            ->whereNotIn('id', function ($query) use ($user) {
                $query->select('user_id')
                    ->from('social_friendships')
                    ->where('friend_id', $user->id);
            })
            ->where('id', '!=', $user->id)
            ->limit(5)
            ->get();

        return Inertia::render('event-city/social/index', [
            'posts' => $posts,
            'user_profile' => $userProfile,
            'suggested_friends' => $suggestedFriends,
        ]);
    }

    public function createPost(CreatePostRequest $request): JsonResponse
    {
        $user = Auth::user();

        $post = SocialPost::create([
            'user_id' => $user->id,
            'content' => $request->content,
            'media' => $request->media,
            'visibility' => $request->visibility,
            'location' => $request->location,
        ]);

        $post->load(['user', 'likes.user', 'comments.user']);

        return response()->json([
            'post' => [
                ...$post->toArray(),
                'likes_count' => 0,
                'comments_count' => 0,
                'shares_count' => 0,
                'is_liked_by_user' => false,
            ],
        ]);
    }

    public function likePost(string $post): JsonResponse
    {
        $user = Auth::user();
        $socialPost = SocialPost::findOrFail($post);

        $like = SocialPostLike::firstOrCreate([
            'post_id' => $socialPost->id,
            'user_id' => $user->id,
        ]);

        // Create activity notification
        if ($socialPost->user_id !== $user->id) {
            SocialActivity::create([
                'user_id' => $socialPost->user_id,
                'actor_id' => $user->id,
                'type' => 'post_like',
                'subject_type' => SocialPost::class,
                'subject_id' => $socialPost->id,
            ]);
        }

        return response()->json([
            'liked' => true,
            'likes_count' => $socialPost->likesCount(),
        ]);
    }

    public function unlikePost(string $post): JsonResponse
    {
        $user = Auth::user();
        $socialPost = SocialPost::findOrFail($post);

        SocialPostLike::where('post_id', $socialPost->id)
            ->where('user_id', $user->id)
            ->delete();

        return response()->json([
            'liked' => false,
            'likes_count' => $socialPost->likesCount(),
        ]);
    }

    public function createComment(CreateCommentRequest $request, string $post): JsonResponse
    {
        $user = Auth::user();

        // Find the post manually since route model binding isn't working with UUIDs
        $socialPost = SocialPost::findOrFail($post);

        $comment = SocialPostComment::create([
            'post_id' => $socialPost->id,
            'user_id' => $user->id,
            'parent_id' => $request->parent_id,
            'content' => $request->content,
        ]);

        $comment->load('user');

        // Create activity notification
        if ($socialPost->user_id !== $user->id) {
            SocialActivity::create([
                'user_id' => $socialPost->user_id,
                'actor_id' => $user->id,
                'type' => 'post_comment',
                'subject_type' => SocialPost::class,
                'subject_id' => $socialPost->id,
            ]);
        }

        return response()->json([
            'comment' => [
                ...$comment->toArray(),
                'likes_count' => 0,
                'is_liked_by_user' => false,
                'replies_count' => 0,
            ],
        ]);
    }

    public function deleteComment(SocialPostComment $comment): JsonResponse
    {
        $user = Auth::user();

        if ($comment->user_id !== $user->id) {
            return response()->json(['error' => 'Unauthorized'], 403);
        }

        $comment->delete();

        return response()->json(['message' => 'Comment deleted successfully']);
    }

    public function sendFriendRequest(User $user): JsonResponse
    {
        $currentUser = Auth::user();

        if ($currentUser->id === $user->id) {
            return response()->json(['error' => 'Cannot send friend request to yourself'], 400);
        }

        $friendship = SocialFriendship::create([
            'user_id' => $currentUser->id,
            'friend_id' => $user->id,
            'status' => 'pending',
        ]);

        // Create activity notification
        SocialActivity::create([
            'user_id' => $user->id,
            'actor_id' => $currentUser->id,
            'type' => 'friend_request',
            'subject_type' => SocialFriendship::class,
            'subject_id' => $friendship->id,
        ]);

        return response()->json(['message' => 'Friend request sent']);
    }

    public function acceptFriendRequest(SocialFriendship $friendship): JsonResponse
    {
        $user = Auth::user();

        if ($friendship->friend_id !== $user->id) {
            return response()->json(['error' => 'Unauthorized'], 403);
        }

        $friendship->update([
            'status' => 'accepted',
            'responded_at' => now(),
        ]);

        // Create activity notification
        SocialActivity::create([
            'user_id' => $friendship->user_id,
            'actor_id' => $user->id,
            'type' => 'friend_accept',
            'subject_type' => SocialFriendship::class,
            'subject_id' => $friendship->id,
        ]);

        return response()->json(['message' => 'Friend request accepted']);
    }

    public function profile(User $user): Response
    {
        $currentUser = Auth::user();

        $profile = $user->socialProfile ?: new SocialUserProfile([
            'user_id' => $user->id,
            'profile_visibility' => 'public',
        ]);

        // Check if current user can view this profile
        $canViewProfile = $profile->isPublic() ||
            $user->id === $currentUser->id ||
            $currentUser->isFriendsWith($user);

        if (! $canViewProfile) {
            return Inertia::render('event-city/social/profile-private', [
                'profile_user' => $user,
            ]);
        }

        $posts = SocialPost::with(['user', 'likes.user', 'comments.user'])
            ->where('user_id', $user->id)
            ->where('is_active', true)
            ->latest()
            ->limit(20)
            ->get()
            ->map(function ($post) use ($currentUser) {
                return [
                    ...$post->toArray(),
                    'likes_count' => $post->likesCount(),
                    'comments_count' => $post->commentsCount(),
                    'shares_count' => $post->sharesCount(),
                    'is_liked_by_user' => $post->isLikedBy($currentUser),
                ];
            });

        // Get accepted friends with their profiles
        $friends = User::whereHas('friendships', function ($query) use ($user) {
            $query->where(function ($q) use ($user) {
                $q->where('user_id', $user->id)->orWhere('friend_id', $user->id);
            })->where('status', 'accepted');
        })
            ->with(['socialProfile'])
            ->limit(6) // Show first 6 friends for preview
            ->get()
            ->filter(fn ($friend) => $friend->id !== $user->id) // Remove self from friends list
            ->values();

        // Get total friends count
        $friendsCount = SocialFriendship::where(function ($query) use ($user) {
            $query->where('user_id', $user->id)->orWhere('friend_id', $user->id);
        })->where('status', 'accepted')->count();

        return Inertia::render('event-city/social/profile', [
            'profile_user' => [
                ...$user->toArray(),
                'social_profile' => $profile,
                'is_friend_with_user' => $currentUser->isFriendsWith($user),
                'has_pending_friend_request' => $currentUser->hasPendingFriendRequestWith($user),
            ],
            'posts' => $posts,
            'friends' => $friends->map(function ($friend) {
                return [
                    'id' => $friend->id,
                    'name' => $friend->name,
                    'avatar' => $friend->avatar,
                ];
            }),
            'friends_count' => $friendsCount,
            'current_user' => [
                'id' => $currentUser->id,
                'name' => $currentUser->name,
                'avatar' => $currentUser->avatar,
            ],
        ]);
    }

    public function updateProfile(UpdateProfileRequest $request): JsonResponse
    {
        $user = Auth::user();

        $profile = $user->socialProfile ?: new SocialUserProfile(['user_id' => $user->id]);

        $profile->fill($request->validated());
        $profile->save();

        return response()->json([
            'message' => 'Profile updated successfully',
            'profile' => $profile,
        ]);
    }

    public function activities(): JsonResponse
    {
        $user = Auth::user();

        $activities = SocialActivity::with(['actor', 'subject'])
            ->where('user_id', $user->id)
            ->latest()
            ->limit(50)
            ->get();

        return response()->json([
            'activities' => $activities,
            'unread_count' => $user->unreadActivitiesCount(),
        ]);
    }

    public function markActivitiesAsRead(): JsonResponse
    {
        $user = Auth::user();

        SocialActivity::where('user_id', $user->id)
            ->where('is_read', false)
            ->update(['is_read' => true]);

        return response()->json(['message' => 'Activities marked as read']);
    }

    public function friendsIndex(): Response
    {
        $user = Auth::user();

        // Get accepted friends only
        $friends = User::whereHas('friendships', function ($query) use ($user) {
            $query->where(function ($q) use ($user) {
                $q->where('user_id', $user->id)->orWhere('friend_id', $user->id);
            })->where('status', 'accepted');
        })
            ->with(['socialProfile'])
            ->get()
            ->map(function ($friend) {
                return [
                    'id' => $friend->id,
                    'name' => $friend->name,
                    'username' => $friend->username ?? str_replace('@', '', explode('@', $friend->email)[0]),
                    'avatar' => $friend->avatar,
                    'location' => $friend->socialProfile?->location,
                    'status' => 'friend',
                ];
            });

        // Get pending friend requests sent by current user
        $sentRequests = User::whereHas('friendshipRequests', function ($query) use ($user) {
            $query->where('user_id', $user->id)->where('status', 'pending');
        })
            ->with(['socialProfile'])
            ->get()
            ->map(function ($friend) {
                return [
                    'id' => $friend->id,
                    'name' => $friend->name,
                    'username' => $friend->username ?? str_replace('@', '', explode('@', $friend->email)[0]),
                    'avatar' => $friend->avatar,
                    'location' => $friend->socialProfile?->location,
                    'status' => 'pending_sent',
                ];
            });

        return Inertia::render('event-city/social/friends-index', [
            'friends' => $friends,
            'sentRequests' => $sentRequests,
        ]);
    }

    public function declineFriendRequest(User $user): JsonResponse
    {
        $currentUser = Auth::user();

        $friendship = SocialFriendship::where('user_id', $user->id)
            ->where('friend_id', $currentUser->id)
            ->where('status', 'pending')
            ->first();

        if (! $friendship) {
            return response()->json(['error' => 'Friend request not found'], 404);
        }

        $friendship->delete();

        return response()->json(['message' => 'Friend request declined']);
    }

    public function cancelFriendRequest(?User $friendUser = null): JsonResponse
    {
        $user = Auth::user();

        // Check if route model binding failed, try manual resolution
        if (! $friendUser) {
            $rawUserId = request()->route('user');

            Log::warning('Route model binding failed, attempting manual resolution', [
                'requester_id' => $user->id,
                'raw_user_parameter' => $rawUserId,
                'parameter_type' => gettype($rawUserId),
                'request_path' => request()->path(),
            ]);

            // Try to manually find the user
            if ($rawUserId) {
                try {
                    $friendUser = User::find($rawUserId);
                } catch (Exception $e) {
                    Log::error('Manual user resolution failed', [
                        'user_id' => $rawUserId,
                        'error' => $e->getMessage(),
                    ]);
                }
            }

            if (! $friendUser) {
                return response()->json(['error' => 'Invalid user ID provided'], 400);
            }
        }

        $friendship = SocialFriendship::where('user_id', $user->id)
            ->where('friend_id', $friendUser->id)
            ->where('status', 'pending')
            ->first();

        if (! $friendship) {
            Log::warning('Friend request not found', [
                'requester_id' => $user->id,
                'friend_id' => $friendUser->id,
                'friend_name' => $friendUser->name,
                'existing_friendships' => SocialFriendship::where('user_id', $user->id)->orWhere('friend_id', $user->id)->get()->toArray(),
            ]);

            return response()->json(['error' => 'Friend request not found'], 404);
        }

        $friendship->delete();

        return response()->json(['message' => 'Friend request cancelled']);
    }

    public function removeFriend(User $friendUser): JsonResponse
    {
        $user = Auth::user();

        SocialFriendship::where(function ($query) use ($user, $friendUser) {
            $query->where('user_id', $user->id)->where('friend_id', $friendUser->id);
        })->orWhere(function ($query) use ($user, $friendUser) {
            $query->where('user_id', $friendUser->id)->where('friend_id', $user->id);
        })->where('status', 'accepted')->delete();

        return response()->json(['message' => 'Friend removed']);
    }
}
```

### app/Http/Controllers/Auth/NewPasswordController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Auth\Events\PasswordReset;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Password;
use Illuminate\Support\Str;
use Illuminate\Validation\Rules;
use Illuminate\Validation\ValidationException;
use Inertia\Inertia;
use Inertia\Response;

final class NewPasswordController extends Controller
{
    /**
     * Show the password reset page.
     */
    public function create(Request $request): Response
    {
        return Inertia::render('event-city/auth/reset-password', [
            'email' => $request->email,
            'token' => $request->route('token'),
        ]);
    }

    /**
     * Handle an incoming new password request.
     *
     * @throws ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'token' => 'required',
            'email' => 'required|email',
            'password' => ['required', 'confirmed', Rules\Password::defaults()],
        ]);

        // Here we will attempt to reset the user's password. If it is successful we
        // will update the password on an actual user model and persist it to the
        // database. Otherwise we will parse the error and return the response.
        $status = Password::reset(
            $request->only('email', 'password', 'password_confirmation', 'token'),
            function ($user) use ($request) {
                $user->forceFill([
                    'password' => Hash::make($request->password),
                    'remember_token' => Str::random(60),
                ])->save();

                event(new PasswordReset($user));
            }
        );

        // If the password was successfully reset, we will redirect the user back to
        // the application's home authenticated view. If there is an error we can
        // redirect them back to where they came from with their error message.
        if ($status === Password::PasswordReset) {
            return to_route('login')->with('status', __($status));
        }

        throw ValidationException::withMessages([
            'email' => [__($status)],
        ]);
    }
}
```

### app/Http/Controllers/Auth/EmailVerificationPromptController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class EmailVerificationPromptController extends Controller
{
    /**
     * Show the email verification prompt page.
     */
    public function __invoke(Request $request): Response|RedirectResponse
    {
        return $request->user()->hasVerifiedEmail()
                    ? redirect()->intended(route('dashboard', absolute: false))
                    : Inertia::render('event-city/auth/verify-email', ['status' => $request->session()->get('status')]);
    }
}
```

### app/Http/Controllers/Auth/VerifyEmailController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Auth\Events\Verified;
use Illuminate\Foundation\Auth\EmailVerificationRequest;
use Illuminate\Http\RedirectResponse;

final class VerifyEmailController extends Controller
{
    /**
     * Mark the authenticated user's email address as verified.
     */
    public function __invoke(EmailVerificationRequest $request): RedirectResponse
    {
        if ($request->user()->hasVerifiedEmail()) {
            return redirect()->intended(route('dashboard', absolute: false).'?verified=1');
        }

        if ($request->user()->markEmailAsVerified()) {
            /** @var \Illuminate\Contracts\Auth\MustVerifyEmail $user */
            $user = $request->user();

            event(new Verified($user));
        }

        return redirect()->intended(route('dashboard', absolute: false).'?verified=1');
    }
}
```

### app/Http/Controllers/Auth/PasswordResetLinkController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Password;
use Inertia\Inertia;
use Inertia\Response;

final class PasswordResetLinkController extends Controller
{
    /**
     * Show the password reset link request page.
     */
    public function create(Request $request): Response
    {
        return Inertia::render('event-city/auth/forgot-password', [
            'status' => $request->session()->get('status'),
        ]);
    }

    /**
     * Handle an incoming password reset link request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'email' => 'required|email',
        ]);

        Password::sendResetLink(
            $request->only('email')
        );

        return back()->with('status', __('A reset link will be sent if the account exists.'));
    }
}
```

### app/Http/Controllers/Auth/EmailVerificationNotificationController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;

final class EmailVerificationNotificationController extends Controller
{
    /**
     * Send a new email verification notification.
     */
    public function store(Request $request): RedirectResponse
    {
        if ($request->user()->hasVerifiedEmail()) {
            return redirect()->intended(route('dashboard', absolute: false));
        }

        $request->user()->sendEmailVerificationNotification();

        return back()->with('status', 'verification-link-sent');
    }
}
```

### app/Http/Controllers/Auth/SocialiteController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Auth;

use App\Events\Registered;
use App\Http\Controllers\Controller;
use App\Models\SocialAccount;
use App\Models\User;
use App\Services\CrossDomainAuthService;
use App\Services\Workspace\WorkspaceInvitationService;
use Exception;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Password;
use Laravel\Socialite\Facades\Socialite;

final class SocialiteController extends Controller
{
    public function __construct(
        private readonly CrossDomainAuthService $crossDomainAuthService
    ) {}
    /**
     * Redirect the user to the provider authentication page.
     */
    public function redirect(string $provider, Request $request)
    {
        if (! $this->hasProvider($provider)) {
            abort(404);
        }

        // Store invitation token in session if present
        $invitationToken = $request->input('invitation');
        if ($invitationToken) {
            session(['socialite_invitation' => $invitationToken]);
        }

        return Socialite::driver($provider)->redirect();
    }

    /**
     * Handle the callback from the provider.
     */
    public function callback(string $provider)
    {
        try {
            $socialiteUser = Socialite::driver($provider)->user();

            // Retrieve invitation token from session
            $invitationToken = session('socialite_invitation');

            // Check if user already has a social account
            $socialAccount = SocialAccount::where('provider', $provider)
                ->where('provider_id', $socialiteUser->getId())
                ->first();

            // If we have a social account, get the user
            if ($socialAccount) {
                $user = $socialAccount->user;
                Auth::login($user);

                // Handle invitation for existing user
                return $this->handlePostAuthInvitation($invitationToken, $user);
            }

            // Check if user exists by email
            $user = User::where('email', $socialiteUser->getEmail())->first();

            // If no user with this email, create one
            if (! $user) {
                $user = User::create([
                    'name' => $socialiteUser->getName() ?? $socialiteUser->getNickname() ?? 'User',
                    'email' => $socialiteUser->getEmail(),
                    'password' => Hash::make(Password::random(32)),
                ]);

                event(new Registered($user, $invitationToken));
            }

            // Create social account if it doesn't exist
            if (! $user->socialAccounts()->where('provider', $provider)->exists()) {
                $user->socialAccounts()->create([
                    'provider' => $provider,
                    'provider_id' => $socialiteUser->getId(),
                    'name' => $socialiteUser->getName() ?? $socialiteUser->getNickname(),
                    'token' => $socialiteUser->token,
                    'refresh_token' => $socialiteUser->refreshToken ?? null,
                    'avatar' => $socialiteUser->getAvatar(),
                    'expires_at' => isset($socialiteUser->expiresIn) ? now()->addSeconds($socialiteUser->expiresIn) : null,
                ]);
            }

            Auth::login($user);

            // Handle invitation after login
            return $this->handlePostAuthInvitation($invitationToken, $user);
        } catch (Exception $e) {
            // Clear invitation from session on error
            session()->forget('socialite_invitation');

            return redirect()->route('login')->withErrors([
                'email' => 'Unable to login with '.ucfirst($provider).'. Please try again or use another method.',
            ]);
        }
    }

    protected function hasProvider(string $provider): bool
    {
        return in_array($provider, config('makerkit.auth.socialite.providers'));
    }

    /**
     * Sync authentication to other domains after login
     */
    private function syncAuthToOtherDomains(\App\Models\User $user, \Illuminate\Http\Request $request): void
    {
        try {
            $sourceDomain = $request->getHost();
            $result = $this->crossDomainAuthService->generateToken($user, $sourceDomain);
            
            $plainToken = $result['plain_token'];
            
            // Generate auth URLs for other domains
            $authUrls = $this->crossDomainAuthService->getAuthUrls(
                $plainToken,
                $sourceDomain,
                $request->get('return', '/')
            );

            // Store token and URLs in session for frontend to handle redirects
            $request->session()->put('cross_domain_auth_token', $plainToken);
            $request->session()->put('cross_domain_auth_urls', $authUrls);
        } catch (\Exception $e) {
            // Log error but don't fail login
            \Log::error('Failed to sync auth to other domains', [
                'error' => $e->getMessage(),
                'user_id' => $user->id,
            ]);
        }
    }

    /**
     * Handle invitation after authentication
     */
    private function handlePostAuthInvitation(?string $invitationToken, User $user)
    {
        // Clear invitation from session
        session()->forget('socialite_invitation');

        if ($invitationToken) {
            $invitationService = app(WorkspaceInvitationService::class);
            $result = $invitationService->acceptInvitationByToken($invitationToken, $user);

            $message = $result->wasSuccessful()
                ? 'Successfully joined the workspace!'
                : 'Could not join workspace. The invitation may be invalid or expired.';

            $messageType = $result->wasSuccessful() ? 'success' : 'warning';

            // Sync auth to other domains
        $this->syncAuthToOtherDomains($user, request());

        return redirect()->intended(route('dashboard'))
                ->with($messageType, $message);
        }

        // Set current workspace to the first workspace membership if available (normal login flow)
        $firstMembership = $user->workspaceMemberships()->first();
        if ($firstMembership) {
            $user->current_workspace_id = $firstMembership->workspace_id;
            $user->save();
        }

        // Sync auth to other domains
        $this->syncAuthToOtherDomains($user, request());

        return redirect()->intended(route('dashboard'));
    }
}
```

### app/Http/Controllers/Auth/AuthenticatedSessionController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Auth;

use App\Events\Registered;
use App\Http\Controllers\Controller;
use App\Http\Requests\Auth\LoginRequest;
use App\Models\User;
use App\Notifications\MagicLinkNotification;
use App\Services\CrossDomainAuthService;
use App\Services\Workspace\WorkspaceInvitationService;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Notification;
use Illuminate\Support\Facades\Route;
use Inertia\Inertia;
use Inertia\Response;
use MagicLink\Actions\LoginAction;
use MagicLink\MagicLink;

final class AuthenticatedSessionController extends Controller
{
    public function __construct(
        private readonly CrossDomainAuthService $crossDomainAuthService
    ) {}
    /**
     * Show the login page.
     */
    public function create(Request $request): Response
    {
        return Inertia::render('event-city/auth/login', [
            'providers' => config('makerkit.auth.socialite.providers'),
            'canResetPassword' => Route::has('password.request'),
            'status' => $request->session()->get('status'),
            'invitation' => $request->query('invitation'),
        ]);
    }

    public function createMagicLink(Request $request): Response
    {
        return Inertia::render('event-city/auth/magic-link', [
            'status' => $request->session()->get('status'),
            'error' => $request->session()->get('error'),
            'invitation' => $request->query('invitation'),
        ]);
    }

    /**
     * Handle an incoming authentication request.
     */
    public function store(LoginRequest $request): RedirectResponse
    {
        $request->authenticate();

        $request->session()->regenerate();

        $user = $request->user();

        // Handle workspace invitation if present
        $invitationToken = $request->input('invitation');

        $message = null;
        $messageType = null;

        if ($invitationToken) {
            $invitationService = app(WorkspaceInvitationService::class);
            $result = $invitationService->acceptInvitationByToken($invitationToken, $user);

            $message = $result->wasSuccessful()
                ? 'Successfully joined the workspace!'
                : 'Could not join workspace. The invitation may be invalid or expired.';

            $messageType = $result->wasSuccessful() ? 'success' : 'warning';
        }

        // Set current workspace to the first workspace membership if available (normal login flow)
        $firstMembership = $user->workspaceMemberships()->first();
        if ($firstMembership) {
            $user->current_workspace_id = $firstMembership->workspace_id;
            $user->save();
        }

        // Generate cross-domain auth token and sync to other domains
        $this->syncAuthToOtherDomains($user, $request);

        return redirect()->intended(route('home', absolute: false))
            ->with($messageType, $message);
    }

    /**
     * Destroy an authenticated session.
     */
    public function destroy(Request $request): RedirectResponse
    {
        // Sync logout to other domains
        $this->syncLogoutToOtherDomains($request);

        Auth::guard('web')->logout();

        $request->session()->invalidate();
        $request->session()->regenerateToken();

        return redirect('/');
    }

    /**
     * Sync authentication to other domains after login
     */
    private function syncAuthToOtherDomains(User $user, Request $request): void
    {
        try {
            $sourceDomain = $request->getHost();
            $result = $this->crossDomainAuthService->generateToken($user, $sourceDomain);
            
            $tokenRecord = $result['token_record'];
            $plainToken = $result['plain_token'];
            
            // Generate auth URLs for other domains
            $authUrls = $this->crossDomainAuthService->getAuthUrls(
                $plainToken,
                $sourceDomain,
                $request->get('return', '/')
            );

            // Store token and URLs in session for frontend to handle redirects
            $request->session()->put('cross_domain_auth_token', $plainToken);
            $request->session()->put('cross_domain_auth_urls', $authUrls);
        } catch (\Exception $e) {
            // Log error but don't fail login
            \Log::error('Failed to sync auth to other domains', [
                'error' => $e->getMessage(),
                'user_id' => $user->id,
            ]);
        }
    }

    /**
     * Sync logout to other domains
     */
    private function syncLogoutToOtherDomains(Request $request): void
    {
        try {
            $currentDomain = $request->getHost();
            $allDomains = $this->crossDomainAuthService->getAllDomains();
            $targetDomains = array_filter($allDomains, fn($domain) => $domain !== $currentDomain);

            $logoutUrls = [];
            foreach ($targetDomains as $domain) {
                $protocol = config('app.env') === 'local' ? 'http' : 'https';
                $logoutUrls[] = "{$protocol}://{$domain}/cross-domain-auth/logout-sync?return=" . urlencode('/');
            }

            // Store logout URLs in session for frontend
            $request->session()->put('cross_domain_logout_urls', $logoutUrls);
        } catch (\Exception $e) {
            \Log::error('Failed to sync logout to other domains', [
                'error' => $e->getMessage(),
            ]);
        }
    }

    public function generateMagicLink(Request $request)
    {
        $request->validate([
            'email' => ['required', 'email'],
        ]);

        $invitationToken = $request->query('invitation');

        $user = User::firstWhere('email', $request->email);

        if (! $user) {
            $user = User::create([
                'name' => explode('@', $request->email)[0],
                'email' => $request->email,
            ]);

            event(new Registered($user, $invitationToken));
        }

        $action = new LoginAction($user);

        // Use custom redirect handler if invitation is present
        if ($invitationToken) {
            $action->response(redirect()->route('auth.magic-link.callback', ['invitation' => $invitationToken]));
        } else {
            $action->response(redirect('/home'));
        }

        $magicLink = MagicLink::create($action)->url;

        Notification::send($user, new MagicLinkNotification($magicLink));

        return redirect()->back()->with('status', 'Magic link sent to user.')
            ->with('invitation', $invitationToken);
    }

    /**
     * Handle magic link callback with invitation processing
     */
    public function magicLinkCallback(Request $request): RedirectResponse
    {
        // User should already be authenticated by the magic link action
        if (! Auth::check()) {
            return redirect()->route('login')->withErrors(['error' => 'Authentication required']);
        }

        $user = Auth::user();
        $invitationToken = $request->query('invitation');

        $message = null;
        $messageType = null;

        if ($invitationToken) {
            $invitationService = app(WorkspaceInvitationService::class);
            $result = $invitationService->acceptInvitationByToken($invitationToken, $user);

            $message = $result->wasSuccessful()
                ? 'Successfully joined the workspace!'
                : 'Could not join workspace. The invitation may be invalid or expired.';

            $messageType = $result->wasSuccessful() ? 'success' : 'warning';
        }

        // Set current workspace to the first workspace membership if available (normal login flow)
        $firstMembership = $user->workspaceMemberships()->first();
        if ($firstMembership) {
            $user->current_workspace_id = $firstMembership->workspace_id;
            $user->save();
        }

        // Generate cross-domain auth token and sync to other domains
        $this->syncAuthToOtherDomains($user, $request);

        return redirect()->route('home')
            ->with($messageType, $message);
    }
}
```

### app/Http/Controllers/Auth/RegisteredUserController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Auth;

use App\Events\Registered;
use App\Http\Controllers\Controller;
use App\Models\User;
use App\Services\Workspace\WorkspaceInvitationService;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;
use Illuminate\Validation\Rules;
use Inertia\Inertia;
use Inertia\Response;

final class RegisteredUserController extends Controller
{
    /**
     * Show the registration page.
     */
    public function create(Request $request): Response
    {
        return Inertia::render('event-city/auth/register', [
            'providers' => config('makerkit.auth.socialite.providers'),
            'magicLinkEnabled' => config('makerkit.auth.magiclink.enabled'),
            'invitation' => $request->query('invitation'),
        ]);
    }

    /**
     * Handle an incoming registration request.
     *
     * @throws \Illuminate\Validation\ValidationException
     */
    public function store(Request $request): RedirectResponse
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'email' => 'required|string|lowercase|email|max:255|unique:'.User::class,
            'password' => ['required', Rules\Password::defaults()],
            'invitation' => 'nullable|string|max:255',
        ]);

        $user = User::create([
            'name' => $request->name,
            'email' => $request->email,
            'password' => Hash::make($request->password),
        ]);

        event(new Registered($user, $request->invitation));

        Auth::login($user);

        // Handle workspace invitation if present
        return $this->handleWorkspaceInvitation($request->invitation, $user);
    }

    private function handleWorkspaceInvitation(?string $invitationToken, User $user): RedirectResponse
    {
        if ($invitationToken) {
            $invitationService = app(WorkspaceInvitationService::class);
            $result = $invitationService->acceptInvitationByToken($invitationToken, $user);

            if ($result->wasSuccessful()) {
                return redirect()->route('home')
                    ->with('success', 'Welcome! You have successfully joined the workspace.');
            }

            return redirect()->route('home')
                ->with('warning', 'Account created successfully, but could not join workspace. The invitation may be invalid or expired.');
        }

        return redirect()->route('home');
    }
}
```

### app/Http/Controllers/Auth/ConfirmablePasswordController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Auth;

use App\Http\Controllers\Controller;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Validation\ValidationException;
use Inertia\Inertia;
use Inertia\Response;

final class ConfirmablePasswordController extends Controller
{
    /**
     * Show the confirm password page.
     */
    public function show(): Response
    {
        return Inertia::render('event-city/auth/confirm-password');
    }

    /**
     * Confirm the user's password.
     */
    public function store(Request $request): RedirectResponse
    {
        if (! Auth::guard('web')->validate([
            'email' => $request->user()->email,
            'password' => $request->password,
        ])) {
            throw ValidationException::withMessages([
                'password' => __('auth.password'),
            ]);
        }

        $request->session()->put('auth.password_confirmed_at', time());

        return redirect()->intended(route('dashboard', absolute: false));
    }
}
```

### app/Http/Controllers/Admin/Emergency/AlertController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Admin\Emergency;

use App\Http\Controllers\Controller;
use App\Models\Community;
use App\Models\EmergencyAlert;
use App\Services\EmergencyBroadcastService;
use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Inertia\Inertia;
use Inertia\Response;

final class AlertController extends Controller
{
    public function __construct(
        private readonly EmergencyBroadcastService $emergencyService
    ) {}

    public function index(Request $request): Response
    {
        $alerts = EmergencyAlert::query()
            ->with('community:id,name')
            ->when($request->community_id, fn($q, $c) => $q->where('community_id', $c))
            ->when($request->priority, fn($q, $p) => $q->where('priority', $p))
            ->when($request->status, fn($q, $s) => $q->where('status', $s))
            ->orderByDesc('created_at')
            ->paginate(25);

        return Inertia::render('Admin/Emergency/Alerts/Index', [
            'alerts' => $alerts,
            'filters' => $request->only(['community_id', 'priority', 'status']),
            'communities' => Community::select('id', 'name')->orderBy('name')->get(),
            'priorities' => ['critical', 'urgent', 'advisory', 'info'],
            'statuses' => ['draft', 'active', 'expired', 'cancelled'],
        ]);
    }

    public function create(): Response
    {
        return Inertia::render('Admin/Emergency/Alerts/Create', [
            'communities' => Community::select('id', 'name')->orderBy('name')->get(),
            'priorities' => [
                ['value' => 'critical', 'label' => 'Critical', 'color' => 'red', 'description' => 'Imminent threat to life/safety'],
                ['value' => 'urgent', 'label' => 'Urgent', 'color' => 'orange', 'description' => 'Significant event requiring attention'],
                ['value' => 'advisory', 'label' => 'Advisory', 'color' => 'yellow', 'description' => 'Awareness recommended'],
                ['value' => 'info', 'label' => 'Info', 'color' => 'blue', 'description' => 'General notice'],
            ],
            'categories' => ['weather', 'crime', 'health', 'utility', 'traffic', 'government', 'school', 'amber'],
            'channels' => ['email', 'sms'],
        ]);
    }

    public function store(Request $request): RedirectResponse
    {
        $validated = $request->validate([
            'community_id' => 'required|exists:communities,id',
            'priority' => 'required|in:critical,urgent,advisory,info',
            'category' => 'required|string',
            'title' => 'required|string|max:255',
            'message' => 'required|string',
            'instructions' => 'nullable|string',
            'source' => 'nullable|string',
            'source_url' => 'nullable|url',
            'expires_at' => 'nullable|date|after:now',
            'channels' => 'required|array|min:1',
            'publish_immediately' => 'boolean',
        ]);

        $alert = $this->emergencyService->createAlert($validated, auth()->id());
        $message = ($validated['publish_immediately'] ?? false)
            ? 'Alert published and broadcast initiated.'
            : 'Alert saved as draft.';

        return redirect()
            ->route('admin.emergency.alerts.show', $alert)
            ->with('success', $message);
    }

    public function show(EmergencyAlert $alert): Response
    {
        $alert->load(['community', 'creator', 'municipalPartner']);

        return Inertia::render('Admin/Emergency/Alerts/Show', [
            'alert' => $alert,
            'deliveryStats' => $this->emergencyService->getDeliveryStats($alert),
            'auditLog' => $alert->auditLogs()->with('user')->latest()->limit(20)->get(),
        ]);
    }

    public function publish(EmergencyAlert $alert): RedirectResponse
    {
        if ($alert->status !== 'draft') {
            return back()->with('error', 'Only draft alerts can be published.');
        }

        $this->emergencyService->publishAlert($alert, auth()->id());

        return back()->with('success', 'Alert published and broadcast initiated.');
    }

    public function cancel(Request $request, EmergencyAlert $alert): RedirectResponse
    {
        if (!in_array($alert->status, ['draft', 'active'])) {
            return back()->with('error', 'This alert cannot be cancelled.');
        }

        $this->emergencyService->cancelAlert($alert, auth()->id(), $request->input('reason'));

        return back()->with('success', 'Alert cancelled.');
    }
}
```

### app/Http/Controllers/Admin/Advertising/PlacementController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Admin\Advertising;

use App\Http\Controllers\Controller;
use App\Models\AdPlacement;
use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Inertia\Inertia;
use Inertia\Response;

final class PlacementController extends Controller
{
    public function index(Request $request): Response
    {
        $placements = AdPlacement::query()
            ->when($request->platform, fn($q, $p) => $q->where('platform', $p))
            ->when($request->is_active !== null, fn($q) => $q->where('is_active', $request->is_active))
            ->orderBy('platform')
            ->orderBy('priority')
            ->paginate(25);

        return Inertia::render('Admin/Advertising/Placements/Index', [
            'placements' => $placements,
            'filters' => $request->only(['platform', 'is_active']),
            'platforms' => ['day_news', 'goeventcity', 'downtown_guide', 'alphasite_community', 'golocalvoices'],
        ]);
    }

    public function create(): Response
    {
        return Inertia::render('Admin/Advertising/Placements/Create', [
            'platforms' => ['day_news', 'goeventcity', 'downtown_guide', 'alphasite_community', 'golocalvoices'],
            'formats' => ['leaderboard', 'medium_rectangle', 'sidebar', 'native', 'sponsored_article', 'audio', 'video'],
        ]);
    }

    public function store(Request $request): RedirectResponse
    {
        $validated = $request->validate([
            'platform' => 'required|string',
            'slot' => 'required|string',
            'name' => 'required|string|max:255',
            'description' => 'nullable|string',
            'format' => 'required|string',
            'width' => 'required|integer|min:1',
            'height' => 'required|integer|min:1',
            'base_cpm' => 'required|numeric|min:0',
            'base_cpc' => 'nullable|numeric|min:0',
            'priority' => 'nullable|integer|min:0',
        ]);

        $placement = AdPlacement::create($validated);

        return redirect()
            ->route('admin.advertising.placements.show', $placement)
            ->with('success', 'Placement created successfully.');
    }

    public function show(AdPlacement $placement): Response
    {
        return Inertia::render('Admin/Advertising/Placements/Show', [
            'placement' => $placement,
        ]);
    }

    public function edit(AdPlacement $placement): Response
    {
        return Inertia::render('Admin/Advertising/Placements/Edit', [
            'placement' => $placement,
            'platforms' => ['day_news', 'goeventcity', 'downtown_guide', 'alphasite_community', 'golocalvoices'],
            'formats' => ['leaderboard', 'medium_rectangle', 'sidebar', 'native', 'sponsored_article', 'audio', 'video'],
        ]);
    }

    public function update(Request $request, AdPlacement $placement): RedirectResponse
    {
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'description' => 'nullable|string',
            'base_cpm' => 'required|numeric|min:0',
            'base_cpc' => 'nullable|numeric|min:0',
            'is_active' => 'boolean',
            'priority' => 'nullable|integer|min:0',
        ]);

        $placement->update($validated);

        return redirect()
            ->route('admin.advertising.placements.show', $placement)
            ->with('success', 'Placement updated successfully.');
    }
}
```

### app/Http/Controllers/Admin/Advertising/CreativeController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Admin\Advertising;

use App\Http\Controllers\Controller;
use App\Models\AdCampaign;
use App\Models\AdCreative;
use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Inertia\Inertia;
use Inertia\Response;

final class CreativeController extends Controller
{
    public function index(Request $request): Response
    {
        $creatives = AdCreative::query()
            ->with('campaign:id,name')
            ->when($request->campaign_id, fn($q, $c) => $q->where('campaign_id', $c))
            ->when($request->status, fn($q, $s) => $q->where('status', $s))
            ->orderByDesc('created_at')
            ->paginate(25);

        return Inertia::render('Admin/Advertising/Creatives/Index', [
            'creatives' => $creatives,
            'filters' => $request->only(['campaign_id', 'status']),
            'campaigns' => AdCampaign::select('id', 'name')->orderBy('name')->get(),
            'statuses' => ['draft', 'pending_review', 'approved', 'rejected', 'active', 'paused'],
        ]);
    }

    public function create(): Response
    {
        return Inertia::render('Admin/Advertising/Creatives/Create', [
            'campaigns' => AdCampaign::select('id', 'name')->orderBy('name')->get(),
            'formats' => ['leaderboard', 'medium_rectangle', 'sidebar', 'native', 'sponsored_article', 'audio', 'video'],
        ]);
    }

    public function store(Request $request): RedirectResponse
    {
        $validated = $request->validate([
            'campaign_id' => 'required|exists:ad_campaigns,id',
            'name' => 'required|string|max:255',
            'format' => 'required|in:leaderboard,medium_rectangle,sidebar,native,sponsored_article,audio,video',
            'headline' => 'nullable|string|max:255',
            'body' => 'nullable|string',
            'image_url' => 'nullable|url',
            'video_url' => 'nullable|url',
            'audio_url' => 'nullable|url',
            'click_url' => 'required|url',
            'cta_text' => 'nullable|string|max:50',
            'width' => 'nullable|integer',
            'height' => 'nullable|integer',
        ]);

        $creative = AdCreative::create($validated);

        return redirect()
            ->route('admin.advertising.creatives.show', $creative)
            ->with('success', 'Creative created successfully.');
    }

    public function show(AdCreative $creative): Response
    {
        $creative->load('campaign');

        return Inertia::render('Admin/Advertising/Creatives/Show', [
            'creative' => $creative,
            'stats' => [
                'impressions' => $creative->impressions()->count(),
                'clicks' => $creative->clicks()->count(),
                'ctr' => $creative->ctr,
            ],
        ]);
    }

    public function edit(AdCreative $creative): Response
    {
        return Inertia::render('Admin/Advertising/Creatives/Edit', [
            'creative' => $creative,
            'campaigns' => AdCampaign::select('id', 'name')->orderBy('name')->get(),
            'formats' => ['leaderboard', 'medium_rectangle', 'sidebar', 'native', 'sponsored_article', 'audio', 'video'],
        ]);
    }

    public function update(Request $request, AdCreative $creative): RedirectResponse
    {
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'format' => 'required|in:leaderboard,medium_rectangle,sidebar,native,sponsored_article,audio,video',
            'headline' => 'nullable|string|max:255',
            'body' => 'nullable|string',
            'image_url' => 'nullable|url',
            'video_url' => 'nullable|url',
            'audio_url' => 'nullable|url',
            'click_url' => 'required|url',
            'cta_text' => 'nullable|string|max:50',
            'width' => 'nullable|integer',
            'height' => 'nullable|integer',
        ]);

        $creative->update($validated);

        return redirect()
            ->route('admin.advertising.creatives.show', $creative)
            ->with('success', 'Creative updated successfully.');
    }

    public function updateStatus(Request $request, AdCreative $creative): RedirectResponse
    {
        $validated = $request->validate([
            'status' => 'required|in:pending_review,approved,rejected,active,paused',
        ]);

        $creative->update($validated);

        return back()->with('success', 'Creative status updated.');
    }
}
```

### app/Http/Controllers/Admin/Advertising/ReportController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Admin\Advertising;

use App\Http\Controllers\Controller;
use App\Models\AdCampaign;
use App\Services\AdServerService;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Inertia\Inertia;
use Inertia\Response;

final class ReportController extends Controller
{
    public function __construct(
        private readonly AdServerService $adService
    ) {}

    public function index(Request $request): Response
    {
        $dateFrom = $request->date_from ?? now()->subDays(30)->format('Y-m-d');
        $dateTo = $request->date_to ?? now()->format('Y-m-d');

        // Overall stats
        $stats = [
            'total_impressions' => DB::table('ad_impressions')
                ->whereBetween('impressed_at', [$dateFrom, $dateTo])
                ->count(),
            'total_clicks' => DB::table('ad_clicks')
                ->whereBetween('clicked_at', [$dateFrom, $dateTo])
                ->count(),
            'total_revenue' => DB::table('ad_impressions')
                ->whereBetween('impressed_at', [$dateFrom, $dateTo])
                ->sum('cost') + DB::table('ad_clicks')
                ->whereBetween('clicked_at', [$dateFrom, $dateTo])
                ->sum('cost'),
        ];

        $stats['ctr'] = $stats['total_impressions'] > 0
            ? round(($stats['total_clicks'] / $stats['total_impressions']) * 100, 2)
            : 0;

        return Inertia::render('Admin/Advertising/Reports/Index', [
            'stats' => $stats,
            'filters' => $request->only(['date_from', 'date_to']),
        ]);
    }

    public function campaign(AdCampaign $campaign): Response
    {
        $campaign->load('advertiser', 'creatives');
        $stats = $this->adService->getCampaignStats($campaign);

        // Daily breakdown
        $dailyStats = DB::table('ad_impressions')
            ->selectRaw('DATE(impressed_at) as date, COUNT(*) as impressions')
            ->whereIn('creative_id', $campaign->creatives->pluck('id'))
            ->where('impressed_at', '>=', now()->subDays(30))
            ->groupBy('date')
            ->orderBy('date')
            ->get();

        return Inertia::render('Admin/Advertising/Reports/Campaign', [
            'campaign' => $campaign,
            'stats' => $stats,
            'dailyStats' => $dailyStats,
        ]);
    }
}
```

### app/Http/Controllers/Admin/Advertising/CampaignController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Admin\Advertising;

use App\Http\Controllers\Controller;
use App\Models\AdCampaign;
use App\Models\Business;
use App\Services\AdServerService;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Inertia\Inertia;
use Inertia\Response;

final class CampaignController extends Controller
{
    public function __construct(
        private readonly AdServerService $adService
    ) {}

    public function index(Request $request): Response
    {
        $campaigns = AdCampaign::query()
            ->with('advertiser:id,name')
            ->withCount('creatives')
            ->when($request->status, fn($q, $s) => $q->where('status', $s))
            ->when($request->search, fn($q, $s) => $q->where('name', 'like', "%{$s}%"))
            ->orderByDesc('created_at')
            ->paginate(25);

        // Add stats to each campaign
        $campaigns->getCollection()->transform(function ($campaign) {
            $campaign->stats = $this->adService->getCampaignStats($campaign);
            return $campaign;
        });

        return Inertia::render('Admin/Advertising/Campaigns/Index', [
            'campaigns' => $campaigns,
            'filters' => $request->only(['status', 'search']),
            'statuses' => ['draft', 'pending', 'active', 'paused', 'completed', 'cancelled'],
        ]);
    }

    public function create(): Response
    {
        return Inertia::render('Admin/Advertising/Campaigns/Create', [
            'advertisers' => Business::select('id', 'name')->orderBy('name')->get(),
            'platforms' => ['day_news', 'goeventcity', 'downtown_guide', 'alphasite_community', 'golocalvoices'],
            'campaignTypes' => ['cpm', 'cpc', 'flat_rate', 'sponsored'],
        ]);
    }

    public function store(Request $request): \Illuminate\Http\RedirectResponse
    {
        $validated = $request->validate([
            'advertiser_id' => 'required|exists:businesses,id',
            'name' => 'required|string|max:255',
            'description' => 'nullable|string',
            'type' => 'required|in:cpm,cpc,flat_rate,sponsored',
            'budget' => 'required|numeric|min:0',
            'daily_budget' => 'nullable|numeric|min:0',
            'start_date' => 'required|date|after_or_equal:today',
            'end_date' => 'required|date|after:start_date',
            'platforms' => 'required|array|min:1',
            'targeting' => 'nullable|array',
        ]);

        $campaign = AdCampaign::create($validated);

        return redirect()
            ->route('admin.advertising.campaigns.show', $campaign)
            ->with('success', 'Campaign created successfully.');
    }

    public function show(AdCampaign $campaign): Response
    {
        $campaign->load(['advertiser', 'creatives']);

        return Inertia::render('Admin/Advertising/Campaigns/Show', [
            'campaign' => $campaign,
            'stats' => $this->adService->getCampaignStats($campaign),
            'dailyStats' => $this->getDailyStats($campaign),
        ]);
    }

    public function edit(AdCampaign $campaign): Response
    {
        return Inertia::render('Admin/Advertising/Campaigns/Edit', [
            'campaign' => $campaign,
            'advertisers' => Business::select('id', 'name')->orderBy('name')->get(),
            'platforms' => ['day_news', 'goeventcity', 'downtown_guide', 'alphasite_community', 'golocalvoices'],
            'campaignTypes' => ['cpm', 'cpc', 'flat_rate', 'sponsored'],
        ]);
    }

    public function update(Request $request, AdCampaign $campaign): \Illuminate\Http\RedirectResponse
    {
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'description' => 'nullable|string',
            'budget' => 'required|numeric|min:' . $campaign->spent,
            'daily_budget' => 'nullable|numeric|min:0',
            'end_date' => 'required|date|after:start_date',
            'platforms' => 'required|array|min:1',
            'targeting' => 'nullable|array',
        ]);

        $campaign->update($validated);

        return redirect()
            ->route('admin.advertising.campaigns.show', $campaign)
            ->with('success', 'Campaign updated successfully.');
    }

    public function updateStatus(Request $request, AdCampaign $campaign): \Illuminate\Http\RedirectResponse
    {
        $validated = $request->validate([
            'status' => 'required|in:active,paused,cancelled',
        ]);

        $campaign->update($validated);

        return back()->with('success', 'Campaign status updated.');
    }

    protected function getDailyStats(AdCampaign $campaign): array
    {
        // Get last 30 days of stats
        return DB::table('ad_impressions')
            ->selectRaw('DATE(impressed_at) as date, COUNT(*) as impressions')
            ->whereIn('creative_id', $campaign->creatives->pluck('id'))
            ->where('impressed_at', '>=', now()->subDays(30))
            ->groupBy('date')
            ->orderBy('date')
            ->get()
            ->toArray();
    }
}
```

### app/Http/Controllers/Admin/Email/CampaignController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Admin\Email;

use App\Http\Controllers\Controller;
use App\Models\Community;
use App\Models\EmailCampaign;
use App\Models\EmailTemplate;
use App\Services\EmailGeneratorService;
use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Inertia\Inertia;
use Inertia\Response;

final class CampaignController extends Controller
{
    public function __construct(
        private readonly EmailGeneratorService $emailService
    ) {}

    public function index(Request $request): Response
    {
        $campaigns = EmailCampaign::query()
            ->with('community:id,name')
            ->when($request->community_id, fn($q, $c) => $q->where('community_id', $c))
            ->when($request->type, fn($q, $t) => $q->where('type', $t))
            ->when($request->status, fn($q, $s) => $q->where('status', $s))
            ->orderByDesc('created_at')
            ->paginate(25);

        return Inertia::render('Admin/Email/Campaigns/Index', [
            'campaigns' => $campaigns,
            'filters' => $request->only(['community_id', 'type', 'status']),
            'communities' => Community::select('id', 'name')->orderBy('name')->get(),
            'types' => ['daily_digest', 'breaking_news', 'weekly_newsletter', 'smb_report', 'custom'],
            'statuses' => ['draft', 'scheduled', 'sending', 'sent', 'cancelled'],
        ]);
    }

    public function show(EmailCampaign $campaign): Response
    {
        $campaign->load(['community', 'template']);

        return Inertia::render('Admin/Email/Campaigns/Show', [
            'campaign' => $campaign,
            'stats' => [
                'open_rate' => $campaign->open_rate,
                'click_rate' => $campaign->click_rate,
                'bounce_rate' => $campaign->delivered_count > 0
                    ? round(($campaign->bounced_count / $campaign->delivered_count) * 100, 2)
                    : 0,
            ],
        ]);
    }

    public function generateDigest(Request $request): RedirectResponse
    {
        $validated = $request->validate([
            'community_id' => 'required|exists:communities,id',
        ]);

        $community = Community::findOrFail($validated['community_id']);
        $campaign = $this->emailService->generateDailyDigest($community);

        return redirect()
            ->route('admin.email.campaigns.show', $campaign)
            ->with('success', 'Daily digest generated and scheduled.');
    }

    public function generateNewsletter(Request $request): RedirectResponse
    {
        $validated = $request->validate([
            'community_id' => 'required|exists:communities,id',
        ]);

        $community = Community::findOrFail($validated['community_id']);
        $campaign = $this->emailService->generateWeeklyNewsletter($community);

        return redirect()
            ->route('admin.email.campaigns.show', $campaign)
            ->with('success', 'Weekly newsletter generated and scheduled.');
    }
}
```

### app/Http/Controllers/Admin/Email/TemplateController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Admin\Email;

use App\Http\Controllers\Controller;
use App\Models\EmailTemplate;
use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Inertia\Inertia;
use Inertia\Response;

final class TemplateController extends Controller
{
    public function index(Request $request): Response
    {
        $templates = EmailTemplate::query()
            ->when($request->type, fn($q, $t) => $q->where('type', $t))
            ->when($request->is_active !== null, fn($q) => $q->where('is_active', $request->is_active))
            ->orderBy('type')
            ->orderBy('name')
            ->paginate(25);

        return Inertia::render('Admin/Email/Templates/Index', [
            'templates' => $templates,
            'filters' => $request->only(['type', 'is_active']),
            'types' => ['daily_digest', 'breaking_news', 'weekly_newsletter', 'smb_report', 'emergency', 'transactional'],
        ]);
    }

    public function create(): Response
    {
        return Inertia::render('Admin/Email/Templates/Create', [
            'types' => ['daily_digest', 'breaking_news', 'weekly_newsletter', 'smb_report', 'emergency', 'transactional'],
        ]);
    }

    public function store(Request $request): RedirectResponse
    {
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'slug' => 'required|string|max:255|unique:email_templates,slug',
            'type' => 'required|in:daily_digest,breaking_news,weekly_newsletter,smb_report,emergency,transactional',
            'subject_template' => 'required|string|max:255',
            'preview_text' => 'nullable|string|max:255',
            'html_template' => 'required|string',
            'text_template' => 'nullable|string',
            'variables' => 'nullable|array',
        ]);

        $template = EmailTemplate::create($validated);

        return redirect()
            ->route('admin.email.templates.show', $template)
            ->with('success', 'Template created successfully.');
    }

    public function show(EmailTemplate $template): Response
    {
        return Inertia::render('Admin/Email/Templates/Show', [
            'template' => $template,
        ]);
    }

    public function edit(EmailTemplate $template): Response
    {
        return Inertia::render('Admin/Email/Templates/Edit', [
            'template' => $template,
            'types' => ['daily_digest', 'breaking_news', 'weekly_newsletter', 'smb_report', 'emergency', 'transactional'],
        ]);
    }

    public function update(Request $request, EmailTemplate $template): RedirectResponse
    {
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'slug' => 'required|string|max:255|unique:email_templates,slug,' . $template->id,
            'subject_template' => 'required|string|max:255',
            'preview_text' => 'nullable|string|max:255',
            'html_template' => 'required|string',
            'text_template' => 'nullable|string',
            'variables' => 'nullable|array',
            'is_active' => 'boolean',
        ]);

        $template->update($validated);

        return redirect()
            ->route('admin.email.templates.show', $template)
            ->with('success', 'Template updated successfully.');
    }
}
```

### app/Http/Controllers/Admin/Email/SubscriberController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Admin\Email;

use App\Http\Controllers\Controller;
use App\Models\Community;
use App\Models\EmailSubscriber;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class SubscriberController extends Controller
{
    public function index(Request $request): Response
    {
        $subscribers = EmailSubscriber::query()
            ->with('community:id,name')
            ->when($request->community_id, fn($q, $c) => $q->where('community_id', $c))
            ->when($request->status, fn($q, $s) => $q->where('status', $s))
            ->when($request->type, fn($q, $t) => $q->where('type', $t))
            ->when($request->search, fn($q, $s) => $q->where('email', 'like', "%{$s}%"))
            ->orderByDesc('created_at')
            ->paginate(25);

        return Inertia::render('Admin/Email/Subscribers/Index', [
            'subscribers' => $subscribers,
            'filters' => $request->only(['community_id', 'status', 'type', 'search']),
            'communities' => Community::select('id', 'name')->orderBy('name')->get(),
            'statuses' => ['pending', 'active', 'unsubscribed', 'bounced', 'complained'],
            'types' => ['reader', 'smb'],
        ]);
    }

    public function show(EmailSubscriber $subscriber): Response
    {
        $subscriber->load(['community', 'business']);

        return Inertia::render('Admin/Email/Subscribers/Show', [
            'subscriber' => $subscriber,
        ]);
    }
}
```

### app/Http/Controllers/StoreController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Http\Requests\StoreStoreRequest;
use App\Http\Requests\UpdateStoreRequest;
use App\Models\Store;
use App\Services\StripeConnectService;
use Exception;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;
use Inertia\Inertia;
use Inertia\Response;
use Log;

final class StoreController extends Controller
{
    public function __construct(
        private StripeConnectService $stripeService
    ) {}

    /**
     * Display a listing of approved stores (public)
     */
    public function index(Request $request): Response
    {
        $query = Store::where('status', 'approved')
            ->with(['workspace', 'products' => fn ($q) => $q->where('is_active', true)->limit(4)]);

        // Apply search filter
        if ($request->filled('search')) {
            $query->where('name', 'ilike', '%'.$request->search.'%');
        }

        $stores = $query->latest('approved_at')
            ->paginate(12)
            ->through(fn ($store) => [
                'id' => $store->id,
                'name' => $store->name,
                'slug' => $store->slug,
                'description' => $store->description,
                'logo' => $store->logo,
                'banner' => $store->banner,
                'products_count' => $store->products()->where('is_active', true)->count(),
                'products' => $store->products->map(fn ($product) => [
                    'id' => $product->id,
                    'name' => $product->name,
                    'price' => $product->price,
                    'images' => $product->images,
                ]),
            ]);

        return Inertia::render('event-city/stores/index', [
            'stores' => $stores,
            'filters' => $request->only('search'),
        ]);
    }

    /**
     * Display workspace's stores
     */
    public function myStores(Request $request): Response
    {
        $workspace = $request->user()->currentWorkspace;

        if (! $workspace) {
            abort(403, 'No workspace selected');
        }

        $stores = Store::where('workspace_id', $workspace->id)
            ->withCount('products', 'orders')
            ->latest()
            ->get()
            ->map(fn ($store) => [
                'id' => $store->id,
                'name' => $store->name,
                'slug' => $store->slug,
                'description' => $store->description,
                'logo' => $store->logo,
                'status' => $store->status,
                'can_accept_payments' => $store->canAcceptPayments(),
                'products_count' => $store->products_count,
                'orders_count' => $store->orders_count,
                'created_at' => $store->created_at,
            ]);

        return Inertia::render('event-city/stores/my-stores', [
            'stores' => $stores,
        ]);
    }

    /**
     * Show the form for creating a new store
     */
    public function create(): Response
    {
        return Inertia::render('event-city/stores/create');
    }

    /**
     * Store a newly created store
     */
    public function store(StoreStoreRequest $request): RedirectResponse
    {
        $data = $request->validated();

        // Handle file uploads
        if ($request->hasFile('logo')) {
            $data['logo'] = $request->file('logo')->store('stores/logos', 'public');
        }

        if ($request->hasFile('banner')) {
            $data['banner'] = $request->file('banner')->store('stores/banners', 'public');
        }

        $store = Store::create($data);

        return redirect()->route('stores.show', $store->slug)
            ->with('success', 'Store created successfully! Please complete Stripe Connect onboarding to start selling.');
    }

    /**
     * Display the specified store
     */
    public function show(Request $request, string $slug): Response
    {
        $store = Store::where('slug', $slug)
            ->with(['workspace'])
            ->firstOrFail();

        // Only show approved stores to non-owners
        if ($store->status !== 'approved' && ! $request->user()?->isMemberOfWorkspace($store->workspace_id)) {
            abort(403, 'Store is not available');
        }

        $products = $store->products()
            ->where('is_active', true)
            ->when($request->filled('search'), fn ($q) => $q->where('name', 'ilike', '%'.$request->search.'%'))
            ->when($request->filled('sort'), function ($q) use ($request) {
                match ($request->sort) {
                    'price_asc' => $q->orderBy('price', 'asc'),
                    'price_desc' => $q->orderBy('price', 'desc'),
                    'newest' => $q->latest(),
                    default => $q->latest(),
                };
            })
            ->paginate(12)
            ->through(fn ($product) => [
                'id' => $product->id,
                'name' => $product->name,
                'slug' => $product->slug,
                'description' => $product->description,
                'price' => $product->price,
                'compare_at_price' => $product->compare_at_price,
                'images' => $product->images,
                'is_in_stock' => $product->isInStock(),
                'discount_percentage' => $product->discount_percentage,
            ]);

        $isOwner = $request->user()?->isMemberOfWorkspace($store->workspace_id) ?? false;

        return Inertia::render('event-city/stores/show', [
            'store' => [
                'id' => $store->id,
                'name' => $store->name,
                'slug' => $store->slug,
                'description' => $store->description,
                'logo' => $store->logo,
                'banner' => $store->banner,
                'is_owner' => $isOwner,
                'stripe_connect_id' => $isOwner ? $store->workspace->stripe_connect_id : null,
                'can_accept_payments' => $isOwner ? $store->canAcceptPayments() : null,
            ],
            'products' => $products,
            'filters' => $request->only('search', 'sort'),
        ]);
    }

    /**
     * Show the form for editing the specified store
     */
    public function edit(Request $request, Store $store): Response
    {
        if (! $request->user()->isMemberOfWorkspace($store->workspace_id)) {
            abort(403, 'Unauthorized');
        }

        return Inertia::render('event-city/stores/edit', [
            'store' => [
                'id' => $store->id,
                'name' => $store->name,
                'description' => $store->description,
                'logo' => $store->logo,
                'banner' => $store->banner,
                'status' => $store->status,
            ],
        ]);
    }

    /**
     * Update the specified store
     */
    public function update(UpdateStoreRequest $request, Store $store): RedirectResponse
    {
        if (! $request->user()->isMemberOfWorkspace($store->workspace_id)) {
            abort(403, 'Unauthorized');
        }

        $data = $request->validated();

        // Handle file uploads
        if ($request->hasFile('logo')) {
            if ($store->logo) {
                Storage::disk('public')->delete($store->logo);
            }
            $data['logo'] = $request->file('logo')->store('stores/logos', 'public');
        }

        if ($request->hasFile('banner')) {
            if ($store->banner) {
                Storage::disk('public')->delete($store->banner);
            }
            $data['banner'] = $request->file('banner')->store('stores/banners', 'public');
        }

        $store->update($data);

        return redirect()->route('stores.show', $store->slug)
            ->with('success', 'Store updated successfully!');
    }

    /**
     * Start Stripe Connect onboarding
     */
    public function connectStripe(Request $request, Store $store): RedirectResponse
    {
        if (! $request->user()->isMemberOfWorkspace($store->workspace_id)) {
            abort(403, 'Unauthorized');
        }

        $workspace = $store->workspace;

        Log::info('Stripe Connect: Starting onboarding', [
            'store_id' => $store->id,
            'workspace_id' => $workspace->id,
            'has_stripe_id' => ! empty($workspace->stripe_connect_id),
            'stripe_id' => $workspace->stripe_connect_id,
        ]);

        try {
            // Create Stripe Connect account if it doesn't exist or verify existing account
            if (! $workspace->stripe_connect_id) {
                Log::info('Stripe Connect: Creating new account', ['workspace_id' => $workspace->id]);
                $this->stripeService->createConnectAccount($workspace);
                Log::info('Stripe Connect: Account created', [
                    'workspace_id' => $workspace->id,
                    'stripe_id' => $workspace->stripe_connect_id,
                ]);
            } else {
                // Verify the account still exists in Stripe
                try {
                    Log::info('Stripe Connect: Verifying existing account', [
                        'workspace_id' => $workspace->id,
                        'stripe_id' => $workspace->stripe_connect_id,
                    ]);
                    $this->stripeService->getAccount($workspace->stripe_connect_id);
                    Log::info('Stripe Connect: Account verified', ['stripe_id' => $workspace->stripe_connect_id]);
                } catch (Exception $e) {
                    // Account doesn't exist, create a new one
                    Log::warning('Stripe Connect: Account verification failed, creating new account', [
                        'workspace_id' => $workspace->id,
                        'old_stripe_id' => $workspace->stripe_connect_id,
                        'error' => $e->getMessage(),
                    ]);
                    $this->stripeService->createConnectAccount($workspace);
                    Log::info('Stripe Connect: Account recreated', [
                        'workspace_id' => $workspace->id,
                        'new_stripe_id' => $workspace->stripe_connect_id,
                    ]);
                }
            }

            // Create account link for onboarding
            Log::info('Stripe Connect: Creating account link', [
                'workspace_id' => $workspace->id,
                'stripe_id' => $workspace->stripe_connect_id,
                'refresh_url' => route('stores.connect-refresh', $store),
                'return_url' => route('stores.connect-return', $store),
            ]);

            $accountLink = $this->stripeService->createAccountLink(
                $workspace,
                route('stores.connect-refresh', $store),
                route('stores.connect-return', $store)
            );

            Log::info('Stripe Connect: Account link created', [
                'workspace_id' => $workspace->id,
                'link_url' => $accountLink->url,
                'expires_at' => $accountLink->expires_at,
            ]);

            return redirect($accountLink->url);
        } catch (Exception $e) {
            Log::error('Stripe Connect: Failed to start onboarding', [
                'workspace_id' => $workspace->id,
                'error' => $e->getMessage(),
                'exception' => get_class($e),
                'file' => $e->getFile(),
                'line' => $e->getLine(),
                'trace' => $e->getTraceAsString(),
            ]);

            $errorMessage = $e->getMessage();

            // Provide helpful error messages for common Stripe issues
            if (str_contains($errorMessage, 'Please review the responsibilities')) {
                $errorMessage = 'Please configure your Stripe Connect platform settings at https://dashboard.stripe.com/settings/connect/platform-profile before setting up stores.';
            } elseif (str_contains($errorMessage, 'No such account')) {
                $errorMessage = 'Stripe account not found. Please try again.';
            } elseif (str_contains($errorMessage, 'Not a valid URL')) {
                $errorMessage = 'Invalid store URL. Please ensure your APP_URL is set to a valid public URL (not localhost) in production.';
            }

            return redirect()->back()
                ->with('error', 'Failed to start Stripe Connect onboarding: '.$errorMessage);
        }
    }

    /**
     * Handle Stripe Connect onboarding return
     */
    public function connectReturn(Request $request, Store $store): RedirectResponse
    {
        $workspace = $store->workspace;

        Log::info('Stripe Connect: Return callback received', [
            'store_id' => $store->id,
            'workspace_id' => $workspace->id,
            'user_id' => $request->user()?->id,
            'is_authenticated' => $request->user() !== null,
        ]);

        // Update workspace capabilities
        $this->stripeService->updateWorkspaceCapabilities($workspace);

        Log::info('Stripe Connect: Capabilities updated', [
            'workspace_id' => $workspace->id,
            'can_accept_payments' => $workspace->canAcceptPayments(),
            'charges_enabled' => $workspace->stripe_charges_enabled,
            'payouts_enabled' => $workspace->stripe_payouts_enabled,
        ]);

        // Check if Stripe setup is complete
        $stripeSetupComplete = $workspace->stripe_charges_enabled && $workspace->stripe_payouts_enabled;

        if ($store->canAcceptPayments()) {
            return redirect()->route('stores.show', $store->slug)
                ->with('success', 'Stripe Connect setup completed! You can now accept payments.');
        }

        // If Stripe is set up but store isn't approved, show awaiting approval message
        if ($stripeSetupComplete && $store->isPending()) {
            return redirect()->route('stores.show', $store->slug)
                ->with('info', 'Stripe Connect setup completed! Your store is awaiting admin approval before you can start accepting payments.');
        }

        return redirect()->route('stores.show', $store->slug)
            ->with('info', 'Please complete additional requirements to start accepting payments.');
    }

    /**
     * Handle Stripe Connect onboarding refresh
     */
    public function connectRefresh(Request $request, Store $store): RedirectResponse
    {
        try {
            $accountLink = $this->stripeService->createAccountLink(
                $store->workspace,
                route('stores.connect-refresh', $store),
                route('stores.connect-return', $store)
            );

            return redirect($accountLink->url);
        } catch (Exception $e) {
            return redirect()->route('stores.show', $store->slug)
                ->with('error', 'Failed to refresh onboarding: '.$e->getMessage());
        }
    }

    /**
     * Get Stripe dashboard link
     */
    public function stripeDashboard(Request $request, Store $store): RedirectResponse
    {
        if (! $request->user()->isMemberOfWorkspace($store->workspace_id)) {
            abort(403, 'Unauthorized');
        }

        try {
            $url = $this->stripeService->createDashboardLink($store->workspace);

            return redirect($url);
        } catch (Exception $e) {
            return redirect()->back()
                ->with('error', 'Failed to open Stripe dashboard: '.$e->getMessage());
        }
    }
}
```

### app/Http/Controllers/SocialGroupController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Http\Requests\Social\CreateGroupRequest;
use App\Models\SocialGroup;
use App\Models\SocialGroupInvitation;
use App\Models\SocialGroupMember;
use App\Models\User;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Inertia\Inertia;
use Inertia\Response;

final class SocialGroupController extends Controller
{
    public function index(): Response
    {
        $user = Auth::user();

        $myGroups = SocialGroup::whereHas('members', function ($query) use ($user) {
            $query->where('user_id', $user->id)->where('status', 'approved');
        })
            ->with(['creator', 'members'])
            ->withCount('approvedMembers')
            ->get()
            ->map(function ($group) {
                return [
                    ...$group->toArray(),
                    'members_count' => $group->approved_members_count,
                    'href' => route('social.groups.show', $group->id),
                ];
            });

        $suggestedGroups = SocialGroup::where('privacy', 'public')
            ->where('is_active', true)
            ->whereDoesntHave('members', function ($query) use ($user) {
                $query->where('user_id', $user->id);
            })
            ->with(['creator'])
            ->withCount('approvedMembers')
            ->orderByDesc('approved_members_count')
            ->limit(20)
            ->get()
            ->map(function ($group) {
                return [
                    ...$group->toArray(),
                    'members_count' => $group->approved_members_count,
                    'href' => route('social.groups.show', $group->id),
                ];
            });

        return Inertia::render('event-city/social/groups-index', [
            'my_groups' => $myGroups,
            'suggested_groups' => $suggestedGroups,
        ]);
    }

    public function create(): Response
    {
        return Inertia::render('event-city/social/groups/create');
    }

    public function store(CreateGroupRequest $request): JsonResponse
    {
        $user = Auth::user();

        $group = SocialGroup::create([
            'name' => $request->name,
            'description' => $request->description,
            'privacy' => $request->privacy,
            'cover_image' => $request->cover_image,
            'creator_id' => $user->id,
        ]);

        // Add creator as admin member
        SocialGroupMember::create([
            'group_id' => $group->id,
            'user_id' => $user->id,
            'role' => 'admin',
            'status' => 'approved',
        ]);

        return response()->json([
            'message' => 'Group created successfully',
            'group' => $group,
        ]);
    }

    public function show(SocialGroup $group): Response
    {
        $user = Auth::user();

        // Check if user can view this group
        if ($group->isSecret() && ! $user->isMemberOfGroup($group)) {
            abort(404);
        }

        $group->load(['creator', 'members.user']);

        return Inertia::render('event-city/social/groups/show', [
            'group' => [
                ...$group->toArray(),
                'members_count' => $group->membersCount(),
                'user_membership' => $group->members()->where('user_id', $user->id)->first(),
            ],
        ]);
    }

    public function join(SocialGroup $group): JsonResponse
    {
        $user = Auth::user();

        if ($user->isMemberOfGroup($group)) {
            return response()->json(['error' => 'Already a member'], 400);
        }

        $status = $group->isPublic() ? 'approved' : 'pending';

        SocialGroupMember::create([
            'group_id' => $group->id,
            'user_id' => $user->id,
            'role' => 'member',
            'status' => $status,
        ]);

        $message = $status === 'approved' ? 'Joined group successfully' : 'Join request sent';

        return response()->json(['message' => $message]);
    }

    public function leave(SocialGroup $group): JsonResponse
    {
        $user = Auth::user();

        $membership = $group->members()->where('user_id', $user->id)->first();

        if (! $membership) {
            return response()->json(['error' => 'Not a member'], 400);
        }

        if ($membership->isAdmin() && $group->admins()->count() === 1) {
            return response()->json(['error' => 'Cannot leave as the only admin'], 400);
        }

        $membership->delete();

        return response()->json(['message' => 'Left group successfully']);
    }

    public function invite(SocialGroup $group, Request $request): JsonResponse
    {
        $user = Auth::user();

        $membership = $group->members()->where('user_id', $user->id)->first();
        if (! $membership || ! in_array($membership->role, ['admin', 'moderator'])) {
            return response()->json(['error' => 'No permission to invite users'], 403);
        }

        $request->validate([
            'user_ids' => ['required', 'array'],
            'user_ids.*' => ['required', 'uuid', 'exists:users,id'],
            'message' => ['nullable', 'string', 'max:500'],
        ]);

        $invitedCount = 0;
        foreach ($request->user_ids as $userId) {
            if ($userId === $user->id) {
                continue;
            }

            $targetUser = User::find($userId);
            if (! $targetUser || $targetUser->isMemberOfGroup($group)) {
                continue;
            }

            $existingInvitation = SocialGroupInvitation::where('group_id', $group->id)
                ->where('invited_id', $userId)
                ->pending()
                ->notExpired()
                ->first();

            if ($existingInvitation) {
                continue;
            }

            SocialGroupInvitation::create([
                'group_id' => $group->id,
                'inviter_id' => $user->id,
                'invited_id' => $userId,
                'message' => $request->message,
                'expires_at' => now()->addDays(7),
            ]);

            $invitedCount++;
        }

        return response()->json([
            'message' => "Invited {$invitedCount} user(s) to the group",
            'invited_count' => $invitedCount,
        ]);
    }

    public function respondToInvitation(SocialGroupInvitation $invitation, Request $request): JsonResponse
    {
        $user = Auth::user();

        if ($invitation->invited_id !== $user->id) {
            return response()->json(['error' => 'Not authorized'], 403);
        }

        if (! $invitation->isPending() || $invitation->isExpired()) {
            return response()->json(['error' => 'Invalid invitation'], 400);
        }

        $request->validate([
            'action' => ['required', 'in:accept,decline'],
        ]);

        if ($request->action === 'accept') {
            $invitation->update(['status' => 'accepted']);

            SocialGroupMember::create([
                'group_id' => $invitation->group_id,
                'user_id' => $user->id,
                'role' => 'member',
                'status' => 'approved',
                'joined_at' => now(),
            ]);

            return response()->json(['message' => 'Invitation accepted']);
        }
        $invitation->update(['status' => 'declined']);

        return response()->json(['message' => 'Invitation declined']);

    }

    public function searchUsers(Request $request): JsonResponse
    {
        $query = $request->get('q', '');

        if (mb_strlen($query) < 2) {
            return response()->json(['users' => []]);
        }

        $users = User::where('name', 'ILIKE', "%{$query}%")
            ->orWhere('email', 'ILIKE', "%{$query}%")
            ->select(['id', 'name', 'email'])
            ->limit(10)
            ->get();

        return response()->json(['users' => $users]);
    }
}
```

### app/Http/Controllers/FollowController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\Calendar;
use App\Models\Event;
use App\Models\Follow;
use App\Models\Performer;
use App\Models\Venue;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;

final class FollowController extends Controller
{
    public function toggle(Request $request): JsonResponse
    {
        $request->validate([
            'followable_type' => 'required|string|in:event,performer,venue,calendar,tag,author',
            'followable_id' => 'required|string',
        ]);

        $followableType = match ($request->followable_type) {
            'event' => Event::class,
            'performer' => Performer::class,
            'venue' => Venue::class,
            'calendar' => Calendar::class,
            'tag' => \App\Models\Tag::class, // Will be created in Phase 2
            'author' => \App\Models\User::class, // Users can be followed as authors
            default => throw new \InvalidArgumentException('Invalid followable type'),
        };

        $followable = $followableType::findOrFail($request->followable_id);

        $follow = Follow::where('user_id', $request->user()->id)
            ->where('followable_type', $followableType)
            ->where('followable_id', $followable->id)
            ->first();

        if ($follow) {
            $follow->delete();

            return response()->json([
                'following' => false,
                'message' => 'Unfollowed successfully',
            ]);
        }

        Follow::create([
            'user_id' => $request->user()->id,
            'followable_type' => $followableType,
            'followable_id' => $followable->id,
        ]);

        return response()->json([
            'following' => true,
            'message' => 'Followed successfully',
        ]);
    }

    public function checkStatus(Request $request): JsonResponse
    {
        $request->validate([
            'followable_type' => 'required|string|in:event,performer,venue,calendar,tag,author',
            'followable_id' => 'required|string',
        ]);

        $followableType = match ($request->followable_type) {
            'event' => Event::class,
            'performer' => Performer::class,
            'venue' => Venue::class,
            'calendar' => Calendar::class,
            'tag' => \App\Models\Tag::class, // Will be created in Phase 2
            'author' => \App\Models\User::class, // Users can be followed as authors
            default => throw new \InvalidArgumentException('Invalid followable type'),
        };

        $isFollowing = Follow::where('user_id', $request->user()->id)
            ->where('followable_type', $followableType)
            ->where('followable_id', $request->followable_id)
            ->exists();

        return response()->json([
            'following' => $isFollowing,
        ]);
    }
}
```

### app/Http/Controllers/EventCity/SitemapController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\EventCity;

use App\Http\Controllers\Controller;
use App\Models\Calendar;
use App\Models\Community;
use App\Models\Event;
use App\Models\Performer;
use App\Models\Venue;
use Illuminate\Http\Response;
use Illuminate\Support\Facades\Cache;
use Spatie\Sitemap\Sitemap;
use Spatie\Sitemap\SitemapIndex;
use Spatie\Sitemap\Tags\Sitemap as SitemapTag;
use Spatie\Sitemap\Tags\Url;

final class SitemapController extends Controller
{
    public function robots(): Response
    {
        $baseUrl = 'https://'.config('domains.event-city');
        $content = "User-agent: *\nAllow: /\n\nSitemap: {$baseUrl}/sitemap.xml\n";

        return response($content, 200, ['Content-Type' => 'text/plain']);
    }

    public function index(): Response
    {
        $cacheKey = 'sitemap:event-city:index';

        $content = Cache::remember($cacheKey, $this->getCacheTtl(), function () {
            $sitemapIndex = SitemapIndex::create();
            $baseUrl = 'https://'.config('domains.event-city');

            // Add static sitemap
            $sitemapIndex->add(SitemapTag::create("{$baseUrl}/sitemap-static.xml"));

            // Add events sitemap(s)
            $eventCount = Event::published()->count();
            $eventPages = (int) ceil($eventCount / $this->getPerPage());
            if ($eventPages <= 1) {
                $sitemapIndex->add(SitemapTag::create("{$baseUrl}/sitemap-events.xml"));
            } else {
                for ($i = 1; $i <= $eventPages; $i++) {
                    $sitemapIndex->add(SitemapTag::create("{$baseUrl}/sitemap-events-{$i}.xml"));
                }
            }

            // Add venues sitemap(s)
            $venueCount = Venue::active()->count();
            $venuePages = (int) ceil($venueCount / $this->getPerPage());
            if ($venuePages <= 1) {
                $sitemapIndex->add(SitemapTag::create("{$baseUrl}/sitemap-venues.xml"));
            } else {
                for ($i = 1; $i <= $venuePages; $i++) {
                    $sitemapIndex->add(SitemapTag::create("{$baseUrl}/sitemap-venues-{$i}.xml"));
                }
            }

            // Add performers sitemap(s)
            $performerCount = Performer::active()->count();
            $performerPages = (int) ceil($performerCount / $this->getPerPage());
            if ($performerPages <= 1) {
                $sitemapIndex->add(SitemapTag::create("{$baseUrl}/sitemap-performers.xml"));
            } else {
                for ($i = 1; $i <= $performerPages; $i++) {
                    $sitemapIndex->add(SitemapTag::create("{$baseUrl}/sitemap-performers-{$i}.xml"));
                }
            }

            // Add calendars sitemap
            $sitemapIndex->add(SitemapTag::create("{$baseUrl}/sitemap-calendars.xml"));

            // Add community sitemap
            $sitemapIndex->add(SitemapTag::create("{$baseUrl}/sitemap-community.xml"));

            return $sitemapIndex->render();
        });

        return response($content, 200, ['Content-Type' => 'application/xml']);
    }

    public function events(?int $page = null): Response
    {
        $cacheKey = 'sitemap:event-city:events'.($page ? ":{$page}" : '');

        $content = Cache::remember($cacheKey, $this->getCacheTtl(), function () use ($page) {
            $sitemap = Sitemap::create();
            $baseUrl = 'https://'.config('domains.event-city');
            $perPage = $this->getPerPage();

            $query = Event::published()
                ->orderBy('updated_at', 'desc');

            if ($page !== null) {
                $query->offset(($page - 1) * $perPage)->limit($perPage);
            }

            $events = $query->get();

            foreach ($events as $event) {
                $sitemap->add(
                    Url::create("{$baseUrl}/events/{$event->id}")
                        ->setLastModificationDate($event->updated_at)
                        ->setChangeFrequency(Url::CHANGE_FREQUENCY_DAILY)
                        ->setPriority(0.8)
                );
            }

            return $sitemap->render();
        });

        return response($content, 200, ['Content-Type' => 'application/xml']);
    }

    public function venues(?int $page = null): Response
    {
        $cacheKey = 'sitemap:event-city:venues'.($page ? ":{$page}" : '');

        $content = Cache::remember($cacheKey, $this->getCacheTtl(), function () use ($page) {
            $sitemap = Sitemap::create();
            $baseUrl = 'https://'.config('domains.event-city');
            $perPage = $this->getPerPage();

            $query = Venue::active()
                ->orderBy('updated_at', 'desc');

            if ($page !== null) {
                $query->offset(($page - 1) * $perPage)->limit($perPage);
            }

            $venues = $query->get();

            foreach ($venues as $venue) {
                $sitemap->add(
                    Url::create("{$baseUrl}/venues/{$venue->id}")
                        ->setLastModificationDate($venue->updated_at)
                        ->setChangeFrequency(Url::CHANGE_FREQUENCY_MONTHLY)
                        ->setPriority(0.7)
                );
            }

            return $sitemap->render();
        });

        return response($content, 200, ['Content-Type' => 'application/xml']);
    }

    public function performers(?int $page = null): Response
    {
        $cacheKey = 'sitemap:event-city:performers'.($page ? ":{$page}" : '');

        $content = Cache::remember($cacheKey, $this->getCacheTtl(), function () use ($page) {
            $sitemap = Sitemap::create();
            $baseUrl = 'https://'.config('domains.event-city');
            $perPage = $this->getPerPage();

            $query = Performer::active()
                ->orderBy('updated_at', 'desc');

            if ($page !== null) {
                $query->offset(($page - 1) * $perPage)->limit($perPage);
            }

            $performers = $query->get();

            foreach ($performers as $performer) {
                $sitemap->add(
                    Url::create("{$baseUrl}/performers/{$performer->id}")
                        ->setLastModificationDate($performer->updated_at)
                        ->setChangeFrequency(Url::CHANGE_FREQUENCY_MONTHLY)
                        ->setPriority(0.7)
                );
            }

            return $sitemap->render();
        });

        return response($content, 200, ['Content-Type' => 'application/xml']);
    }

    public function calendars(): Response
    {
        $cacheKey = 'sitemap:event-city:calendars';

        $content = Cache::remember($cacheKey, $this->getCacheTtl(), function () {
            $sitemap = Sitemap::create();
            $baseUrl = 'https://'.config('domains.event-city');

            $calendars = Calendar::public()
                ->orderBy('updated_at', 'desc')
                ->get();

            foreach ($calendars as $calendar) {
                $sitemap->add(
                    Url::create("{$baseUrl}/calendars/{$calendar->id}")
                        ->setLastModificationDate($calendar->updated_at)
                        ->setChangeFrequency(Url::CHANGE_FREQUENCY_WEEKLY)
                        ->setPriority(0.6)
                );
            }

            return $sitemap->render();
        });

        return response($content, 200, ['Content-Type' => 'application/xml']);
    }

    public function community(): Response
    {
        $cacheKey = 'sitemap:event-city:community';

        $content = Cache::remember($cacheKey, $this->getCacheTtl(), function () {
            $sitemap = Sitemap::create();
            $baseUrl = 'https://'.config('domains.event-city');

            // Add main community listing page
            $sitemap->add(
                Url::create("{$baseUrl}/community")
                    ->setChangeFrequency(Url::CHANGE_FREQUENCY_DAILY)
                    ->setPriority(0.7)
            );

            // Add individual community pages
            $communities = Community::active()
                ->orderBy('updated_at', 'desc')
                ->get();

            foreach ($communities as $communityItem) {
                $sitemap->add(
                    Url::create("{$baseUrl}/community/{$communityItem->id}")
                        ->setLastModificationDate($communityItem->updated_at)
                        ->setChangeFrequency(Url::CHANGE_FREQUENCY_DAILY)
                        ->setPriority(0.6)
                );
            }

            return $sitemap->render();
        });

        return response($content, 200, ['Content-Type' => 'application/xml']);
    }

    public function static(): Response
    {
        $cacheKey = 'sitemap:event-city:static';

        $content = Cache::remember($cacheKey, $this->getCacheTtl(), function () {
            $sitemap = Sitemap::create();
            $baseUrl = 'https://'.config('domains.event-city');

            // Homepage
            $sitemap->add(
                Url::create($baseUrl)
                    ->setChangeFrequency(Url::CHANGE_FREQUENCY_DAILY)
                    ->setPriority(1.0)
            );

            // Events listing
            $sitemap->add(
                Url::create("{$baseUrl}/events")
                    ->setChangeFrequency(Url::CHANGE_FREQUENCY_DAILY)
                    ->setPriority(0.9)
            );

            // Venues listing
            $sitemap->add(
                Url::create("{$baseUrl}/venues")
                    ->setChangeFrequency(Url::CHANGE_FREQUENCY_WEEKLY)
                    ->setPriority(0.8)
            );

            // Performers listing
            $sitemap->add(
                Url::create("{$baseUrl}/performers")
                    ->setChangeFrequency(Url::CHANGE_FREQUENCY_WEEKLY)
                    ->setPriority(0.8)
            );

            // Calendars listing
            $sitemap->add(
                Url::create("{$baseUrl}/calendars")
                    ->setChangeFrequency(Url::CHANGE_FREQUENCY_WEEKLY)
                    ->setPriority(0.7)
            );

            // Tickets
            $sitemap->add(
                Url::create("{$baseUrl}/tickets")
                    ->setChangeFrequency(Url::CHANGE_FREQUENCY_DAILY)
                    ->setPriority(0.7)
            );

            return $sitemap->render();
        });

        return response($content, 200, ['Content-Type' => 'application/xml']);
    }

    private function getCacheTtl(): int
    {
        return config('sitemap.cache_ttl', 21600);
    }

    private function getPerPage(): int
    {
        return config('sitemap.per_page', 50000);
    }

    private function getBaseUrl(): string
    {
        return mb_rtrim(config('app.url'), '/');
    }
}
```

### app/Http/Controllers/EventCity/BusinessController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\EventCity;

use App\Http\Controllers\Controller;
use App\Models\Business;
use App\Models\Event;
use App\Services\BusinessService;
use App\Services\EventService;
use App\Services\OrganizationService;
use App\Services\ReviewService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class BusinessController extends Controller
{
    public function __construct(
        private readonly BusinessService $businessService,
        private readonly EventService $eventService,
        private readonly ReviewService $reviewService,
        private readonly OrganizationService $organizationService
    ) {}

    /**
     * Display business directory for GoEventCity
     * Unique positioning: "Event Venues & Performer Directory"
     */
    public function index(Request $request): Response
    {
        // Use shared BusinessService with EventCity-specific filters
        $filters = [
            'category' => $request->input('category'),
            'status' => 'active',
            'is_verified' => $request->boolean('verified_only') ? true : null,
            'sort_by' => $request->get('sort', 'name'),
            'sort_order' => $request->get('direction', 'asc'),
        ];

        $businesses = $this->businessService->search(
            $request->input('search'),
            $filters,
            20,
            (int) $request->input('page', 1)
        );

        // Get featured businesses with upcoming events
        $featuredBusinesses = $this->businessService->getFeatured(6);
        $featuredWithEvents = $featuredBusinesses->map(function ($business) {
            $upcomingEvents = Event::published()
                ->upcoming()
                ->where('venue_id', $business->id)
                ->orWhereHas('organizationRelationships', function ($q) use ($business) {
                    $q->where('organization_id', $business->id)
                      ->where('relatable_type', Event::class);
                })
                ->orderBy('event_date', 'asc')
                ->limit(5)
                ->get();

            return [
                'business' => $business,
                'upcoming_events_count' => $upcomingEvents->count(),
                'next_event' => $upcomingEvents->first(),
            ];
        });

        return Inertia::render('event-city/businesses/index', [
            'businesses' => $businesses,
            'featuredBusinesses' => $featuredWithEvents,
            'filters' => $request->only(['search', 'category', 'verified_only']),
            'sort' => [
                'sort' => $filters['sort_by'] ?? 'name',
                'direction' => $filters['sort_order'] ?? 'asc',
            ],
            'platform' => 'eventcity', // For theme differentiation
        ]);
    }

    /**
     * Display a single business with EventCity-specific context
     */
    public function show(Request $request, Business $business): Response
    {
        $business = $this->businessService->find($business->id);
        
        if (!$business) {
            abort(404);
        }

        // Get upcoming events at this venue/business
        $upcomingEvents = $this->eventService->getByVenue($business, 10);
        
        // Get events related via organization relationships
        $organizationEvents = Event::published()
            ->upcoming()
            ->whereHas('organizationRelationships', function ($q) use ($business) {
                $q->where('organization_id', $business->id)
                  ->where('relatable_type', Event::class);
            })
            ->with(['venue', 'performer', 'regions'])
            ->orderBy('event_date', 'asc')
            ->limit(10)
            ->get();

        // Get reviews
        $reviews = $this->reviewService->getForModel($business, ['status' => 'approved'], 10);
        $averageRating = $this->reviewService->getAverageRating($business);

        // Get organization relationships
        $organizationContent = $this->organizationService->getOrganizationContent($business, [
            'App\Models\Event',
            'App\Models\DayNewsPost',
        ]);

        // Get related businesses (similar category, nearby)
        $relatedBusinesses = $this->businessService->getByCategory(
            $business->categories[0] ?? 'venue',
            6
        )->filter(fn ($b) => $b->id !== $business->id);

        return Inertia::render('event-city/businesses/show', [
            'business' => $business,
            'upcomingEvents' => $upcomingEvents->merge($organizationEvents),
            'reviews' => $reviews,
            'averageRating' => $averageRating,
            'organizationContent' => $organizationContent,
            'relatedBusinesses' => $relatedBusinesses,
            'platform' => 'eventcity', // For theme differentiation
        ]);
    }
}

```

### app/Http/Controllers/VenueController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Http\Requests\StoreVenueRequest;
use App\Models\Follow;
use App\Models\Venue;
use App\Services\SeoService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class VenueController extends Controller
{
    /**
     * Public venues page (no authentication required)
     */
    public function publicIndex(Request $request): Response
    {
        // Build the venues query
        $query = Venue::active()
            ->with(['reviews' => fn ($q) => $q->approved()->latest()->limit(3)]);

        // Apply search filter
        if ($request->filled('search')) {
            $search = $request->search;
            $query->where(function ($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                    ->orWhere('description', 'like', "%{$search}%")
                    ->orWhere('venue_type', 'like', "%{$search}%")
                    ->orWhere('address', 'like', "%{$search}%")
                    ->orWhere('neighborhood', 'like', "%{$search}%");
            });
        }

        // Apply venue type filter
        if ($request->filled('venue_types') && is_array($request->venue_types)) {
            $query->whereIn('venue_type', $request->venue_types);
        }

        // Apply capacity filter
        if ($request->filled('min_capacity')) {
            $query->where('capacity', '>=', $request->integer('min_capacity'));
        }
        if ($request->filled('max_capacity')) {
            $query->where('capacity', '<=', $request->integer('max_capacity'));
        }

        // Apply price filter
        if ($request->filled('min_price')) {
            $query->where('price_per_hour', '>=', $request->float('min_price'));
        }
        if ($request->filled('max_price')) {
            $query->where('price_per_hour', '<=', $request->float('max_price'));
        }

        // Apply amenities filter
        if ($request->filled('amenities') && is_array($request->amenities)) {
            $amenities = $request->amenities;
            $query->where(function ($q) use ($amenities) {
                foreach ($amenities as $amenity) {
                    $q->whereJsonContains('amenities', $amenity);
                }
            });
        }

        // Apply verified filter
        if ($request->filled('verified')) {
            $query->where('verified', $request->boolean('verified'));
        }

        // Apply date availability filter
        if ($request->filled('date')) {
            $date = $request->date;
            $query->where(function ($q) use ($date) {
                $q->whereNull('unavailable_dates')
                    ->orWhere(function ($q) use ($date) {
                        $q->whereNotNull('unavailable_dates')
                            ->whereRaw('NOT JSON_CONTAINS(unavailable_dates, ?)', [json_encode($date)]);
                    });
            });
        }

        // Apply sorting
        $sortBy = $request->get('sort', 'popular');
        match ($sortBy) {
            'popular' => $query->orderByRaw('(total_reviews * 0.3 + average_rating * 0.7) DESC'),
            'recommended' => $query->orderByRaw('(average_rating * 0.7 + total_reviews * 0.3) DESC'),
            'newest' => $query->orderBy('listed_date', 'desc'),
            'price_low' => $query->orderBy('price_per_hour', 'asc'),
            'price_high' => $query->orderBy('price_per_hour', 'desc'),
            'distance' => $query->orderBy('id'), // Placeholder for distance sorting
            'rating' => $query->orderBy('average_rating', 'desc'),
            'capacity' => $query->orderBy('capacity', 'desc'),
            default => $query->orderByRaw('(total_reviews * 0.3 + average_rating * 0.7) DESC'),
        };

        // Get paginated venues
        $venues = $query->paginate(12)->withQueryString();

        // Transform venues for frontend
        $venues->getCollection()->transform(function ($venue) {
            return [
                'id' => $venue->id,
                'name' => $venue->name,
                'description' => $venue->description,
                'venueType' => $venue->venue_type,
                'capacity' => $venue->capacity,
                'rating' => round((float) ($venue->average_rating ?? 0), 1),
                'reviewCount' => $venue->total_reviews ?? 0,
                'images' => $venue->images ?? [],
                'verified' => $venue->verified,
                'location' => [
                    'address' => $venue->address,
                    'neighborhood' => $venue->neighborhood,
                    'coordinates' => [
                        'lat' => $venue->latitude,
                        'lng' => $venue->longitude,
                    ],
                ],
                'amenities' => $venue->amenities ?? [],
                'eventTypes' => $venue->event_types ?? [],
                'pricing' => [
                    'pricePerHour' => $venue->price_per_hour,
                    'pricePerEvent' => $venue->price_per_event,
                    'pricePerDay' => $venue->price_per_day,
                ],
                'availability' => [
                    'unavailableDates' => $venue->unavailable_dates ?? [],
                    'responseTimeHours' => $venue->response_time_hours,
                ],
                'lastBookedDaysAgo' => $venue->last_booked_days_ago,
                'listedDate' => $venue->listed_date?->toISOString(),
                'distance' => 0, // Placeholder - would be calculated based on user location
            ];
        });

        // Get trending venues (most popular recently)
        $trendingVenues = Venue::active()
            ->where('last_booked_days_ago', '<=', 30)
            ->orderByRaw('(total_reviews / GREATEST(last_booked_days_ago, 1)) DESC')
            ->limit(4)
            ->get()
            ->map(function ($venue) {
                return [
                    'id' => $venue->id,
                    'name' => $venue->name,
                    'venueType' => $venue->venue_type,
                    'images' => $venue->images ?? [],
                    'location' => [
                        'neighborhood' => $venue->neighborhood,
                    ],
                    'rating' => round((float) ($venue->average_rating ?? 0), 1),
                    'reviewCount' => $venue->total_reviews ?? 0,
                ];
            });

        // Get new venues (added in the last 90 days)
        $newVenues = Venue::active()
            ->where('listed_date', '>=', now()->subDays(90))
            ->orderBy('listed_date', 'desc')
            ->limit(4)
            ->get()
            ->map(function ($venue) {
                return [
                    'id' => $venue->id,
                    'name' => $venue->name,
                    'venueType' => $venue->venue_type,
                    'images' => $venue->images ?? [],
                    'location' => [
                        'neighborhood' => $venue->neighborhood,
                    ],
                    'listedDate' => $venue->listed_date?->toISOString(),
                ];
            });

        // Get venue statistics
        $totalVenues = Venue::active()->count();
        $newVenuesThisWeek = Venue::active()
            ->where('listed_date', '>=', now()->subWeek())
            ->count();

        // Get upcoming events at venues (mock data for now)
        $upcomingEvents = [];

        // Get current region for ad targeting
        $region = $request->attributes->get('detected_region');

        // Get advertisements
        $bannerAds = $this->advertisementService->getActiveAds('event_city', $region, 'banner')->take(1);
        $sidebarAds = $this->advertisementService->getActiveAds('event_city', $region, 'sidebar')->take(3);

        return Inertia::render('event-city/venues', [
            'venues' => $venues,
            'trendingVenues' => $trendingVenues,
            'newVenues' => $newVenues,
            'upcomingEvents' => $upcomingEvents,
            'stats' => [
                'totalVenues' => $totalVenues,
                'eventsThisWeek' => 427, // Mock data
                'newVenuesThisWeek' => $newVenuesThisWeek,
            ],
            'filters' => $request->only(['search', 'venue_types', 'min_capacity', 'max_capacity', 'min_price', 'max_price', 'amenities', 'verified', 'date']),
            'sort' => $sortBy,
            'advertisements' => [
                'banner' => $bannerAds->map(fn ($ad) => $this->formatAd($ad)),
                'sidebar' => $sidebarAds->map(fn ($ad) => $this->formatAd($ad)),
            ],
        ]);
    }

    public function index(Request $request): Response
    {
        $currentWorkspace = $request->user()->currentWorkspace;

        if (! $currentWorkspace) {
            abort(403, 'No workspace selected');
        }

        $query = Venue::where('workspace_id', $currentWorkspace->id)
            ->with(['workspace', 'createdBy', 'approvedReviews' => fn ($q) => $q->latest()->limit(3)])
            ->withCount(['reviews as total_reviews', 'ratings as total_ratings']);

        // Apply filters
        if ($request->filled('status')) {
            $query->where('status', $request->status);
        }

        if ($request->filled('venue_type')) {
            $query->where('venue_type', $request->venue_type);
        }

        if ($request->filled('verified')) {
            $query->where('verified', $request->boolean('verified'));
        }

        if ($request->filled('search')) {
            $search = $request->search;
            $query->where(function ($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                    ->orWhere('description', 'like', "%{$search}%")
                    ->orWhere('address', 'like', "%{$search}%");
            });
        }

        if ($request->filled('capacity_min')) {
            $query->where('capacity', '>=', $request->integer('capacity_min'));
        }

        if ($request->filled('capacity_max')) {
            $query->where('capacity', '<=', $request->integer('capacity_max'));
        }

        if ($request->filled('rating_min')) {
            $query->where('average_rating', '>=', $request->float('rating_min'));
        }

        // Sorting
        $sortBy = $request->get('sort', 'created_at');
        $sortDirection = $request->get('direction', 'desc');

        match ($sortBy) {
            'name' => $query->orderBy('name', $sortDirection),
            'rating' => $query->orderBy('average_rating', $sortDirection),
            'capacity' => $query->orderBy('capacity', $sortDirection),
            'price' => $query->orderBy('price_per_hour', $sortDirection),
            default => $query->orderBy('created_at', $sortDirection),
        };

        $venues = $query->paginate(12)->withQueryString();

        // Get current region for ad targeting
        $region = $request->attributes->get('detected_region');

        // Get advertisements
        $sidebarAds = $this->advertisementService->getActiveAds('event_city', $region, 'sidebar')->take(3);

        return Inertia::render('event-city/venues/Index', [
            'venues' => $venues,
            'filters' => $request->only(['status', 'venue_type', 'verified', 'search', 'capacity_min', 'capacity_max', 'rating_min']),
            'sort' => ['sort' => $sortBy, 'direction' => $sortDirection],
            'advertisements' => [
                'sidebar' => $sidebarAds->map(fn ($ad) => $this->formatAd($ad)),
            ],
        ]);
    }

    public function show(Request $request, Venue $venue): Response
    {
        $venue->load([
            'workspace',
            'createdBy',
            'approvedReviews.user',
            'ratings.user',
            'events' => fn ($q) => $q->published()->upcoming()->limit(5),
            'bookings' => fn ($q) => $q->confirmed()->limit(10),
        ]);

        $ratingStats = [
            'average' => $venue->average_rating,
            'total' => $venue->ratings()->count(),
            'distribution' => $venue->getRatingDistribution(),
            'by_context' => [
                'service' => $venue->getAverageRatingByContext('service'),
                'quality' => $venue->getAverageRatingByContext('quality'),
                'value' => $venue->getAverageRatingByContext('value'),
                'overall' => $venue->getAverageRatingByContext('overall'),
            ],
        ];

        $isFollowing = false;
        if ($request->user()) {
            $isFollowing = Follow::where('user_id', $request->user()->id)
                ->where('followable_type', Venue::class)
                ->where('followable_id', $venue->id)
                ->exists();
        }

        // Build SEO JSON-LD for venue
        $seoData = [
            'title' => $venue->name,
            'name' => $venue->name,
            'description' => $venue->description,
            'image' => $venue->images[0] ?? null,
            'url' => "/venues/{$venue->id}",
            'address' => $venue->address,
            'neighborhood' => $venue->neighborhood,
            'latitude' => $venue->latitude,
            'longitude' => $venue->longitude,
            'capacity' => $venue->capacity,
            'venueType' => $venue->venue_type,
            'rating' => $venue->average_rating,
            'reviewCount' => $venue->total_reviews,
        ];

        // Get current region for ad targeting
        $region = $request->attributes->get('detected_region');

        // Get advertisements
        $bannerAds = $this->advertisementService->getActiveAds('event_city', $region, 'banner')->take(1);
        $sidebarAds = $this->advertisementService->getActiveAds('event_city', $region, 'sidebar')->take(3);
        $inlineAds = $this->advertisementService->getActiveAds('event_city', $region, 'inline')->take(2);

        return Inertia::render('event-city/venues/show', [
            'seo' => [
                'jsonLd' => SeoService::buildJsonLd('venue', $seoData, 'event-city'),
            ],
            'venue' => $venue,
            'ratingStats' => $ratingStats,
            'isFollowing' => $isFollowing,
            'advertisements' => [
                'banner' => $bannerAds->map(fn ($ad) => $this->formatAd($ad)),
                'sidebar' => $sidebarAds->map(fn ($ad) => $this->formatAd($ad)),
                'inline' => $inlineAds->map(fn ($ad) => $this->formatAd($ad)),
            ],
        ]);
    }

    public function featured(Request $request): array
    {
        $currentWorkspace = $request->user()->currentWorkspace;

        if (! $currentWorkspace) {
            return [];
        }

        $venues = Venue::where('workspace_id', $currentWorkspace->id)
            ->where('status', 'active')
            ->where('verified', true)
            ->highlyRated(4.0)
            ->orderBy('average_rating', 'desc')
            ->orderBy('total_reviews', 'desc')
            ->limit(6)
            ->get()
            ->map(function ($venue) {
                return [
                    'id' => $venue->id,
                    'name' => $venue->name,
                    'venueType' => $venue->venue_type,
                    'capacity' => $venue->capacity,
                    'rating' => number_format((float) ($venue->average_rating ?? 0), 1),
                    'reviewCount' => $venue->total_reviews,
                    'image' => $venue->images[0] ?? '/images/venue-placeholder.jpg',
                    'location' => $venue->address,
                ];
            });

        return $venues->toArray();
    }

    public function create(): Response
    {
        $currentWorkspace = auth()->user()->currentWorkspace;

        if (! $currentWorkspace) {
            abort(403, 'Please select a workspace first.');
        }

        $this->authorize('create', Venue::class);

        return Inertia::render('event-city/venues/create', [
            'workspace' => [
                'can_accept_payments' => $currentWorkspace->canAcceptPayments(),
            ],
        ]);
    }

    public function store(StoreVenueRequest $request)
    {
        $this->authorize('create', Venue::class);

        $currentWorkspace = $request->user()->currentWorkspace;

        if (! $currentWorkspace) {
            abort(403, 'No workspace selected');
        }

        $validated = $request->validated();

        // Handle image uploads
        $imagePaths = [];
        if ($request->hasFile('images')) {
            foreach ($request->file('images') as $image) {
                $path = $image->store('venues', 'public');
                $imagePaths[] = $path;
            }
        }

        $venue = Venue::create([
            ...$validated,
            'images' => $imagePaths,
            'workspace_id' => $currentWorkspace->id,
            'created_by' => $request->user()->id,
            'status' => 'active',
            'listed_date' => now(),
        ]);

        return redirect()->route('venues.show', $venue)
            ->with('success', 'Venue created successfully!');
    }

    public function edit(Venue $venue): Response
    {
        $this->authorize('update', $venue);

        return Inertia::render('event-city/venues/edit', [
            'venue' => $venue,
        ]);
    }

    public function update(Request $request, Venue $venue)
    {
        $this->authorize('update', $venue);

        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'description' => 'required|string',
            'venue_type' => 'required|string',
            'capacity' => 'required|integer|min:1',
            'price_per_hour' => 'required|numeric|min:0',
            'price_per_event' => 'required|numeric|min:0',
            'price_per_day' => 'required|numeric|min:0',
            'address' => 'required|string',
            'neighborhood' => 'nullable|string',
            'latitude' => 'nullable|numeric',
            'longitude' => 'nullable|numeric',
            'amenities' => 'array',
            'event_types' => 'array',
            'images' => 'array',
            'images.*' => 'url',
        ]);

        $venue->update($validated);

        return redirect()->route('venues.show', $venue)
            ->with('success', 'Venue updated successfully!');
    }

    public function destroy(Venue $venue)
    {
        $this->authorize('delete', $venue);

        $venue->delete();

        return redirect()->route('venues')
            ->with('success', 'Venue deleted successfully!');
    }

    /**
     * Format advertisement for frontend
     */
    private function formatAd($ad): array
    {
        return [
            'id' => $ad->id,
            'placement' => $ad->placement,
            'advertable' => [
                'id' => $ad->advertable->id,
                'title' => $ad->advertable->title ?? $ad->advertable->name ?? null,
                'excerpt' => $ad->advertable->excerpt ?? $ad->advertable->description ?? null,
                'featured_image' => $ad->advertable->featured_image ?? $ad->advertable->image ?? $ad->advertable->profile_image ?? null,
                'slug' => $ad->advertable->slug ?? null,
            ],
            'expires_at' => $ad->expires_at->toISOString(),
        ];
    }
}
```

### app/Http/Controllers/TicketGiftController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\TicketOrderItem;
use App\Models\TicketGift;
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Illuminate\Support\Str;
use Inertia\Inertia;
use Inertia\Response;

final class TicketGiftController extends Controller
{
    public function create(Request $request, TicketOrderItem $ticketOrderItem): Response
    {
        // Verify ownership
        if ($ticketOrderItem->ticketOrder->user_id !== $request->user()->id) {
            abort(403);
        }

        return Inertia::render('event-city/tickets/gift', [
            'ticketOrderItem' => $ticketOrderItem->load(['ticketOrder.event', 'ticketPlan']),
        ]);
    }

    public function store(Request $request, TicketOrderItem $ticketOrderItem): RedirectResponse
    {
        // Verify ownership
        if ($ticketOrderItem->ticketOrder->user_id !== $request->user()->id) {
            return redirect()->back()->withErrors(['ticket' => 'You do not own this ticket.']);
        }

        $validated = $request->validate([
            'recipient_email' => 'required|email',
            'recipient_name' => 'nullable|string|max:255',
            'message' => 'nullable|string|max:500',
            'expires_at' => 'nullable|date|after:now',
        ]);

        // Check for existing pending gift
        $existingGift = TicketGift::where('ticket_order_item_id', $ticketOrderItem->id)
            ->where('gifter_id', $request->user()->id)
            ->pending()
            ->first();

        if ($existingGift) {
            return redirect()->back()->withErrors(['gift' => 'You already have a pending gift for this ticket.']);
        }

        // Check if recipient is a user
        $recipient = User::where('email', $validated['recipient_email'])->first();

        $gift = TicketGift::create([
            'ticket_order_item_id' => $ticketOrderItem->id,
            'gifter_id' => $request->user()->id,
            'recipient_email' => $validated['recipient_email'],
            'recipient_name' => $validated['recipient_name'] ?? null,
            'recipient_user_id' => $recipient?->id,
            'status' => TicketGift::STATUS_PENDING,
            'gift_token' => Str::random(64),
            'message' => $validated['message'] ?? null,
            'gifted_at' => now(),
            'expires_at' => $validated['expires_at'] ?? now()->addDays(30),
        ]);

        // TODO: Send email notification

        return redirect()->route('tickets.my-tickets')
            ->with('success', 'Ticket gifted successfully. The recipient will receive an email notification.');
    }

    public function redeem(Request $request, string $token): RedirectResponse
    {
        $gift = TicketGift::where('gift_token', $token)
            ->pending()
            ->firstOrFail();

        if ($gift->expires_at && $gift->expires_at->isPast()) {
            $gift->update(['status' => TicketGift::STATUS_EXPIRED]);
            return redirect()->route('tickets.my-tickets')
                ->withErrors(['gift' => 'This gift has expired.']);
        }

        // Verify email matches if user is logged in
        if ($request->user() && $gift->recipient_email !== $request->user()->email) {
            return redirect()->route('login')
                ->with('error', 'Please log in with the email address that received this gift.');
        }

        // If user is logged in, redeem gift
        if ($request->user()) {
            $gift->redeem($request->user()->id);

            return redirect()->route('tickets.my-tickets')
                ->with('success', 'Ticket gift redeemed successfully.');
        }

        // Otherwise, show redeem page
        return Inertia::render('event-city/tickets/redeem-gift', [
            'gift' => $gift->load(['ticketOrderItem.ticketOrder.event', 'gifter']),
        ]);
    }

    public function complete(Request $request, TicketGift $gift): RedirectResponse
    {
        if ($gift->status !== TicketGift::STATUS_PENDING) {
            return redirect()->back()->withErrors(['gift' => 'This gift is no longer pending.']);
        }

        if ($gift->recipient_email !== $request->user()->email) {
            return redirect()->back()->withErrors(['gift' => 'This gift is not for your email address.']);
        }

        $gift->redeem($request->user()->id);

        return redirect()->route('tickets.my-tickets')
            ->with('success', 'Ticket gift redeemed successfully.');
    }

    public function cancel(TicketGift $gift): RedirectResponse
    {
        if ($gift->gifter_id !== auth()->id()) {
            abort(403);
        }

        if ($gift->status !== TicketGift::STATUS_PENDING) {
            return redirect()->back()->withErrors(['gift' => 'This gift cannot be cancelled.']);
        }

        $gift->update(['status' => TicketGift::STATUS_CANCELLED]);

        return redirect()->back()->with('success', 'Gift cancelled successfully.');
    }
}
```

### app/Http/Controllers/CalendarController.php
```php
// ... existing code ...

    public function publicIndex(Request $request): Response
    {
        $viewMode = $request->query('view', 'list');
        $selectedDate = $request->query('date') ? new \DateTime($request->query('date')) : new \DateTime();
        
        $query = Event::published()
            ->upcoming()
            ->with(['venue', 'performer']);

        // Filter by date based on view mode
        if ($viewMode === 'today') {
            $query->whereDate('event_date', $selectedDate->format('Y-m-d'));
        } elseif ($viewMode === '7days') {
            $endDate = clone $selectedDate;
            $endDate->modify('+7 days');
            $query->whereBetween('event_date', [$selectedDate->format('Y-m-d'), $endDate->format('Y-m-d')]);
        } elseif ($viewMode === 'month') {
            $startDate = clone $selectedDate;
            $startDate->modify('first day of this month');
            $endDate = clone $selectedDate;
            $endDate->modify('last day of this month');
            $query->whereBetween('event_date', [$startDate->format('Y-m-d'), $endDate->format('Y-m-d')]);
        }

        $events = $query->orderBy('event_date', 'asc')->get();

        return Inertia::render('event-city/calendar/index', [
            'events' => $events,
            'selectedDate' => $selectedDate->format('Y-m-d'),
            'viewMode' => $viewMode,
        ]);
    }

// ... existing code ...
```

### app/Http/Controllers/OrderController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\Order;
use App\Models\Store;
use App\Services\StripeConnectService;
use Exception;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Inertia\Inertia;
use Inertia\Response;

final class OrderController extends Controller
{
    public function __construct(
        private StripeConnectService $stripeService
    ) {}

    /**
     * Display a listing of orders for the current workspace's stores
     */
    public function index(Request $request): Response
    {
        $workspace = $request->user()->currentWorkspace;

        if (! $workspace) {
            abort(403, 'No workspace selected');
        }

        $orders = Order::whereHas('store', fn ($q) => $q->where('workspace_id', $workspace->id))
            ->with(['store', 'items.product', 'user'])
            ->when($request->filled('status'), fn ($q) => $q->where('status', $request->status))
            ->when($request->filled('payment_status'), fn ($q) => $q->where('payment_status', $request->payment_status))
            ->latest()
            ->paginate(20)
            ->through(fn ($order) => [
                'id' => $order->id,
                'order_number' => $order->order_number,
                'customer_email' => $order->customer_email,
                'customer_name' => $order->customer_name,
                'total' => $order->total,
                'status' => $order->status,
                'payment_status' => $order->payment_status,
                'created_at' => $order->created_at,
                'store' => [
                    'id' => $order->store->id,
                    'name' => $order->store->name,
                    'slug' => $order->store->slug,
                ],
                'items_count' => $order->items->count(),
            ]);

        return Inertia::render('event-city/orders/index', [
            'orders' => $orders,
            'filters' => $request->only('status', 'payment_status'),
        ]);
    }

    /**
     * Display the specified order
     */
    public function show(Request $request, Order $order): Response
    {
        $order->load(['store', 'items.product', 'user']);

        // Check authorization
        if (! $request->user()->isMemberOfWorkspace($order->store->workspace_id)
            && $order->user_id !== $request->user()->id) {
            abort(403, 'Unauthorized');
        }

        return Inertia::render('event-city/orders/show', [
            'order' => [
                'id' => $order->id,
                'order_number' => $order->order_number,
                'customer_email' => $order->customer_email,
                'customer_name' => $order->customer_name,
                'subtotal' => $order->subtotal,
                'tax' => $order->tax,
                'shipping' => $order->shipping,
                'total' => $order->total,
                'status' => $order->status,
                'payment_status' => $order->payment_status,
                'shipping_address' => $order->shipping_address,
                'billing_address' => $order->billing_address,
                'notes' => $order->notes,
                'paid_at' => $order->paid_at,
                'created_at' => $order->created_at,
                'items' => $order->items->map(fn ($item) => [
                    'id' => $item->id,
                    'product_name' => $item->product_name,
                    'product_description' => $item->product_description,
                    'price' => $item->price,
                    'quantity' => $item->quantity,
                    'total' => $item->total,
                    'product' => $item->product ? [
                        'id' => $item->product->id,
                        'slug' => $item->product->slug,
                        'images' => $item->product->images,
                    ] : null,
                ]),
                'store' => [
                    'id' => $order->store->id,
                    'name' => $order->store->name,
                    'slug' => $order->store->slug,
                    'logo' => $order->store->logo,
                ],
            ],
            'is_store_owner' => $request->user()->isMemberOfWorkspace($order->store->workspace_id),
        ]);
    }

    /**
     * Create checkout session from cart
     */
    public function checkout(Request $request): JsonResponse
    {
        // Get cart using same logic as CartController
        $cart = $this->getOrCreateCart($request);
        $cart->load(['items.product.store', 'items.store']);

        if ($cart->items->isEmpty()) {
            return response()->json([
                'error' => 'Cart is empty',
            ], 400);
        }

        // Check if cart items are from multiple stores - only single store checkout supported
        $storeIds = $cart->items->pluck('store_id')->unique();
        if ($storeIds->count() > 1) {
            return response()->json([
                'error' => 'Cart contains items from multiple stores. Please checkout one store at a time.',
            ], 400);
        }

        $store = $cart->items->first()->store;

        if (! $store->canAcceptPayments()) {
            return response()->json([
                'error' => 'Store cannot accept payments at this time',
            ], 400);
        }

        try {
            DB::beginTransaction();

            // Prepare line items and validate stock
            $lineItems = [];
            $subtotal = 0;

            foreach ($cart->items as $cartItem) {
                $product = $cartItem->product;

                if (! $product->isInStock()) {
                    return response()->json([
                        'error' => "Product {$product->name} is out of stock",
                    ], 400);
                }

                if ($product->track_inventory && $product->quantity < $cartItem->quantity) {
                    return response()->json([
                        'error' => "Not enough stock for {$product->name}",
                    ], 400);
                }

                $productData = [
                    'name' => $product->name,
                    'images' => $product->images ? [asset('storage/'.$product->images[0])] : [],
                ];

                if (! empty($product->description)) {
                    $productData['description'] = $product->description;
                }

                $lineItems[] = [
                    'price_data' => [
                        'currency' => 'usd',
                        'product_data' => $productData,
                        'unit_amount' => (int) ($product->price * 100),
                    ],
                    'quantity' => $cartItem->quantity,
                ];

                $subtotal += $product->price * $cartItem->quantity;
            }

            // Create order
            $order = Order::create([
                'store_id' => $store->id,
                'user_id' => $request->user()?->id,
                'customer_email' => $request->user()?->email ?? $request->email,
                'customer_name' => $request->user()?->name ?? $request->name,
                'subtotal' => $subtotal,
                'tax' => 0,
                'shipping' => 0,
                'total' => $subtotal,
                'status' => 'pending',
                'payment_status' => 'pending',
            ]);

            // Create order items from cart
            foreach ($cart->items as $cartItem) {
                $product = $cartItem->product;

                $order->items()->create([
                    'product_id' => $product->id,
                    'product_name' => $product->name,
                    'product_description' => $product->description,
                    'price' => $product->price,
                    'quantity' => $cartItem->quantity,
                    'total' => $product->price * $cartItem->quantity,
                ]);
            }

            // Create Stripe checkout session
            $session = $this->stripeService->createCheckoutSession(
                $store,
                $lineItems,
                route('checkout.success', ['order' => $order->id]),
                route('checkout.cancel', ['order' => $order->id])
            );

            $order->update(['stripe_payment_intent_id' => $session->payment_intent]);

            // Clear cart after successful checkout session creation
            $cart->items()->delete();

            DB::commit();

            return response()->json([
                'session_id' => $session->id,
                'url' => $session->url,
            ]);
        } catch (Exception $e) {
            DB::rollBack();

            return response()->json([
                'error' => 'Failed to create checkout session: '.$e->getMessage(),
            ], 500);
        }
    }

    /**
     * Handle successful checkout
     */
    public function success(Request $request, Order $order): Response
    {
        return Inertia::render('event-city/checkout/success', [
            'order' => [
                'id' => $order->id,
                'order_number' => $order->order_number,
                'total' => $order->total,
            ],
        ]);
    }

    /**
     * Handle cancelled checkout
     */
    public function cancel(Request $request, Order $order): Response
    {
        return Inertia::render('event-city/checkout/cancel', [
            'order' => [
                'id' => $order->id,
                'order_number' => $order->order_number,
            ],
        ]);
    }

    /**
     * Update order status
     */
    public function updateStatus(Request $request, Order $order): JsonResponse
    {
        if (! $request->user()->isMemberOfWorkspace($order->store->workspace_id)) {
            abort(403, 'Unauthorized');
        }

        $validated = $request->validate([
            'status' => ['required', 'in:pending,processing,completed,cancelled'],
        ]);

        $order->update(['status' => $validated['status']]);

        return response()->json([
            'message' => 'Order status updated successfully',
            'order' => $order,
        ]);
    }

    /**
     * Get or create cart for current user/session
     */
    private function getOrCreateCart(Request $request): \App\Models\Cart
    {
        if ($request->user()) {
            $cart = \App\Models\Cart::firstOrCreate(
                ['user_id' => $request->user()->id],
                ['session_id' => session()->getId()]
            );
        } else {
            $cart = \App\Models\Cart::firstOrCreate(
                ['session_id' => session()->getId()],
                ['user_id' => null]
            );
        }

        return $cart;
    }
}
```

### app/Http/Controllers/DowntownGuide/SearchController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DowntownGuide;

use App\Http\Controllers\Controller;
use App\Services\SearchService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class SearchController extends Controller
{
    public function __construct(
        private readonly SearchService $searchService
    ) {}

    /**
     * Display search results
     */
    public function index(Request $request): Response
    {
        $query = $request->input('q', '');
        $type = $request->input('type', 'all'); // all, businesses, events, articles, coupons
        $filters = [
            'category' => $request->input('category'),
            'region_id' => $request->input('region_id'),
        ];

        if (empty($query)) {
            return Inertia::render('downtown-guide/search/index', [
                'query' => '',
                'results' => [],
                'filters' => $filters,
                'type' => $type,
                'platform' => 'downtownsguide',
            ]);
        }

        // Use shared SearchService
        $results = $this->searchService->search($query, [
            'type' => $type,
            ...$filters,
        ], 20);

        // Get search suggestions
        $suggestions = $this->searchService->getSuggestions($query, 5);

        return Inertia::render('downtown-guide/search/index', [
            'query' => $query,
            'results' => $results,
            'suggestions' => $suggestions,
            'filters' => $filters,
            'type' => $type,
            'platform' => 'downtownsguide',
        ]);
    }

    /**
     * Get search suggestions (AJAX)
     */
    public function suggestions(Request $request): \Illuminate\Http\JsonResponse
    {
        $query = $request->input('q', '');

        if (empty($query) || strlen($query) < 2) {
            return response()->json(['suggestions' => []]);
        }

        $suggestions = $this->searchService->getSuggestions($query, 10);

        return response()->json(['suggestions' => $suggestions]);
    }
}

```

### app/Http/Controllers/DowntownGuide/ReviewController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DowntownGuide;

use App\Http\Controllers\Controller;
use App\Models\Business;
use App\Models\Review;
use App\Services\ReviewService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class ReviewController extends Controller
{
    public function __construct(
        private readonly ReviewService $reviewService
    ) {}

    /**
     * Display reviews for a business
     */
    public function index(Request $request, Business $business): Response
    {
        $filters = [
            'status' => 'approved',
            'rating' => $request->input('rating'),
            'sort_by' => $request->get('sort', 'created_at'),
            'sort_order' => $request->get('direction', 'desc'),
        ];

        $reviews = $this->reviewService->getForModel($business, $filters, 20);
        $averageRating = $this->reviewService->getAverageRating($business);
        $ratingDistribution = $this->reviewService->getRatingDistribution($business);
        $reviewCount = $this->reviewService->getReviewCount($business);

        return Inertia::render('downtown-guide/reviews/index', [
            'business' => $business,
            'reviews' => $reviews,
            'averageRating' => $averageRating,
            'ratingDistribution' => $ratingDistribution,
            'reviewCount' => $reviewCount,
            'filters' => $request->only(['rating', 'sort']),
            'platform' => 'downtownsguide',
        ]);
    }

    /**
     * Show review creation form
     */
    public function create(Request $request, Business $business): Response
    {
        $this->authorize('create', Review::class);

        return Inertia::render('downtown-guide/reviews/create', [
            'business' => $business,
            'platform' => 'downtownsguide',
        ]);
    }

    /**
     * Store a new review
     */
    public function store(Request $request, Business $business): \Illuminate\Http\RedirectResponse
    {
        $this->authorize('create', Review::class);

        $validated = $request->validate([
            'title' => 'nullable|string|max:255',
            'content' => 'required|string|min:10',
            'rating' => 'required|numeric|min:1|max:5',
        ]);

        $review = $this->reviewService->create(
            $business,
            $validated,
            $request->user()->id
        );

        return redirect()
            ->route('downtown-guide.businesses.show', $business->slug)
            ->with('success', 'Review submitted successfully! It will be published after moderation.');
    }

    /**
     * Mark review as helpful
     */
    public function helpful(Request $request, Review $review): \Illuminate\Http\JsonResponse
    {
        $this->authorize('view', $review);

        $updatedReview = $this->reviewService->markAsHelpful($review, $request->user()->id);

        return response()->json([
            'helpful_count' => $updatedReview->helpful_count,
            'message' => 'Thank you for your feedback!',
        ]);
    }
}

```

### app/Http/Controllers/DowntownGuide/ProfileController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DowntownGuide;

use App\Http\Controllers\Controller;
use App\Models\User;
use App\Services\GamificationService;
use App\Services\LoyaltyService;
use App\Services\ProfileService;
use App\Services\ReferralService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class ProfileController extends Controller
{
    public function __construct(
        private readonly ProfileService $profileService,
        private readonly GamificationService $gamificationService,
        private readonly LoyaltyService $loyaltyService,
        private readonly ReferralService $referralService
    ) {}

    /**
     * Display user profile
     */
    public function show(Request $request, User $user): Response
    {
        $profile = $this->profileService->getProfile($user);
        $stats = $this->profileService->getStats($user);
        $activity = $this->profileService->getActivity($user, 10)->map(function ($item) {
            return [
                'id' => $item['id'] ?? uniqid(),
                'type' => $item['type'] ?? 'activity',
                'description' => $item['description'] ?? 'Activity',
                'created_at' => $item['created_at'] ?? now()->toISOString(),
            ];
        });

        // Get gamification data
        $userLevel = $this->gamificationService->getUserLevel($user);
        $achievements = $this->gamificationService->getUserAchievements($user);
        $points = $user->total_points ?? 0;

        // Get loyalty programs
        $loyaltyPrograms = $this->loyaltyService->getUserPrograms($user->id);

        // Get referrals
        $referrals = $this->referralService->getReferrals($user);

        return Inertia::render('downtown-guide/profile/show', [
            'user' => $profile,
            'stats' => $stats,
            'activity' => $activity,
            'level' => $userLevel,
            'achievements' => $achievements,
            'points' => $points,
            'loyaltyPrograms' => $loyaltyPrograms,
            'referrals' => $referrals,
            'platform' => 'downtownsguide',
        ]);
    }

    /**
     * Display current user's profile
     */
    public function me(Request $request): Response
    {
        return $this->show($request, $request->user());
    }

    /**
     * Update user profile
     */
    public function update(Request $request): \Illuminate\Http\RedirectResponse
    {
        $validated = $request->validate([
            'name' => 'sometimes|string|max:255',
            'bio' => 'nullable|string|max:1000',
            'avatar' => 'nullable|image|max:2048',
        ]);

        $this->profileService->updateProfile($request->user(), $validated);

        return redirect()
            ->route('downtown-guide.profile.me')
            ->with('success', 'Profile updated successfully!');
    }
}

```

### app/Http/Controllers/DowntownGuide/CouponController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DowntownGuide;

use App\Http\Controllers\Controller;
use App\Models\Business;
use App\Models\Coupon;
use App\Services\CouponService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class CouponController extends Controller
{
    public function __construct(
        private readonly CouponService $couponService
    ) {}

    /**
     * Display coupons/deals listing
     */
    public function index(Request $request): Response
    {
        $filters = [
            'business_id' => $request->input('business_id'),
            'category' => $request->input('category'),
        ];

        $coupons = $this->couponService->getActiveCoupons($filters, 20);

        // Separate deals from coupons
        $deals = $coupons->filter(fn ($c) => 
            !in_array($c->discount_type, ['percentage', 'fixed'])
        );
        $regularCoupons = $coupons->filter(fn ($c) => 
            in_array($c->discount_type, ['percentage', 'fixed'])
        );

        return Inertia::render('downtown-guide/coupons/index', [
            'coupons' => $regularCoupons,
            'deals' => $deals,
            'filters' => $request->only(['business_id', 'category']),
            'platform' => 'downtownsguide',
        ]);
    }

    /**
     * Display a single coupon/deal
     */
    public function show(Request $request, Coupon $coupon): Response
    {
        $coupon->load(['business', 'regions']);

        // Track view
        $this->couponService->trackView($coupon);

        // Get related coupons from same business
        $relatedCoupons = $this->couponService->getCouponsForBusiness(
            $coupon->business,
            true
        )->filter(fn ($c) => $c->id !== $coupon->id)->take(4);

        return Inertia::render('downtown-guide/coupons/show', [
            'coupon' => $coupon,
            'relatedCoupons' => $relatedCoupons,
            'platform' => 'downtownsguide',
        ]);
    }

    /**
     * Apply/use a coupon
     */
    public function apply(Request $request, Coupon $coupon): \Illuminate\Http\JsonResponse
    {
        $validation = $this->couponService->validate($coupon->code, $request->user()?->id);

        if (!$validation['valid']) {
            return response()->json([
                'error' => $validation['error'],
            ], 422);
        }

        // Track click
        $this->couponService->trackClick($coupon);

        // Apply coupon if user is authenticated
        if ($request->user()) {
            try {
                $usage = $this->couponService->apply($coupon, $request->user()->id);
                return response()->json([
                    'message' => 'Coupon applied successfully!',
                    'coupon' => [
                        'code' => $coupon->code,
                        'discount_type' => $coupon->discount_type,
                        'discount_value' => $coupon->discount_value,
                        'terms' => $coupon->terms,
                    ],
                ]);
            } catch (\Exception $e) {
                return response()->json([
                    'error' => $e->getMessage(),
                ], 422);
            }
        }

        return response()->json([
            'message' => 'Coupon code ready to use!',
            'coupon' => [
                'code' => $coupon->code,
                'discount_type' => $coupon->discount_type,
                'discount_value' => $coupon->discount_value,
                'terms' => $coupon->terms,
            ],
        ]);
    }
}

```

### app/Http/Controllers/DowntownGuide/SitemapController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DowntownGuide;

use App\Http\Controllers\Controller;
use Illuminate\Http\Response;
use Illuminate\Support\Facades\Cache;
use Spatie\Sitemap\Sitemap;
use Spatie\Sitemap\Tags\Url;

final class SitemapController extends Controller
{
    public function robots(): Response
    {
        $baseUrl = 'https://'.config('domains.downtown-guide');
        $content = "User-agent: *\nAllow: /\n\nSitemap: {$baseUrl}/sitemap.xml\n";

        return response($content, 200, ['Content-Type' => 'text/plain']);
    }

    public function index(): Response
    {
        $cacheKey = 'sitemap:downtown-guide:index';

        $content = Cache::remember($cacheKey, $this->getCacheTtl(), function () {
            $sitemap = Sitemap::create();
            $baseUrl = 'https://'.config('domains.downtown-guide');

            // Homepage (coming soon page)
            $sitemap->add(
                Url::create($baseUrl)
                    ->setChangeFrequency(Url::CHANGE_FREQUENCY_WEEKLY)
                    ->setPriority(1.0)
            );

            return $sitemap->render();
        });

        return response($content, 200, ['Content-Type' => 'application/xml']);
    }

    private function getCacheTtl(): int
    {
        return config('sitemap.cache_ttl', 21600);
    }
}
```

### app/Http/Controllers/DowntownGuide/AchievementController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DowntownGuide;

use App\Http\Controllers\Controller;
use App\Services\GamificationService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class AchievementController extends Controller
{
    public function __construct(
        private readonly GamificationService $gamificationService
    ) {}

    /**
     * Display achievements listing
     */
    public function index(Request $request): Response
    {
        $category = $request->input('category');
        $rarity = $request->input('rarity');

        $achievements = $this->gamificationService->getAchievements([
            'category' => $category,
            'rarity' => $rarity,
        ]);

        // Get user's achievements if authenticated
        $userAchievements = collect([]);
        if ($request->user()) {
            $userAchievements = $this->gamificationService->getUserAchievements($request->user());
        }

        return Inertia::render('downtown-guide/achievements/index', [
            'achievements' => $achievements,
            'userAchievements' => $userAchievements,
            'filters' => [
                'category' => $category,
                'rarity' => $rarity,
            ],
            'platform' => 'downtownsguide',
        ]);
    }

    /**
     * Display leaderboard
     */
    public function leaderboard(Request $request): Response
    {
        $period = $request->input('period', 'all_time'); // daily, weekly, monthly, all_time
        $type = $request->input('type', 'points'); // points, reviews, visits, referrals

        $leaderboard = $this->gamificationService->getLeaderboard($type, $period, 100);

        return Inertia::render('downtown-guide/achievements/leaderboard', [
            'leaderboard' => $leaderboard,
            'period' => $period,
            'type' => $type,
            'platform' => 'downtownsguide',
        ]);
    }
}

```

### app/Http/Controllers/DowntownGuide/BusinessController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DowntownGuide;

use App\Http\Controllers\Controller;
use App\Models\Business;
use App\Models\Region;
use App\Services\AdvertisementService;
use App\Services\BusinessService;
use App\Services\CouponService;
use App\Services\EventService;
use App\Services\LocationService;
use App\Services\NewsService;
use App\Services\OrganizationService;
use App\Services\ReviewService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class BusinessController extends Controller
{
    public function __construct(
        private readonly BusinessService $businessService,
        private readonly ReviewService $reviewService,
        private readonly CouponService $couponService,
        private readonly EventService $eventService,
        private readonly NewsService $newsService,
        private readonly OrganizationService $organizationService,
        private readonly AdvertisementService $advertisementService,
        private readonly LocationService $locationService
    ) {}

    /**
     * Display business directory for DowntownsGuide
     * Unique positioning: "Your Complete Guide to Local Businesses"
     */
    public function index(Request $request): Response
    {
        // Use shared BusinessService with DowntownsGuide-specific filters
        $filters = [
            'category' => $request->input('category'),
            'status' => 'active',
            'is_verified' => $request->boolean('verified_only') ? true : null,
            'featured' => $request->boolean('featured_only') ? true : null,
            'sort_by' => $request->get('sort', 'rating'),
            'sort_order' => $request->get('direction', 'desc'),
        ];

        $businesses = $this->businessService->search(
            $request->input('search'),
            $filters,
            20,
            (int) $request->input('page', 1)
        );

        // Get featured businesses with active deals/coupons
        $featuredBusinesses = $this->businessService->getFeatured(6);
        $featuredWithDeals = $featuredBusinesses->map(function ($business) {
            $activeCoupons = $this->couponService->getCouponsForBusiness($business, true);
            $activeDeals = $activeCoupons->filter(fn ($c) => !in_array($c->discount_type, ['percentage', 'fixed']));

            return [
                'business' => $business,
                'active_deals_count' => $activeDeals->count(),
                'active_coupons_count' => $activeCoupons->count(),
                'latest_deal' => $activeDeals->first() ? [
                    'id' => $activeDeals->first()->id,
                    'title' => $activeDeals->first()->title,
                    'discount_value' => $activeDeals->first()->discount_value,
                ] : null,
            ];
        });

        // Get current region for ad targeting
        $region = $request->attributes->get('detected_region');

        // Get advertisements
        $bannerAds = $this->advertisementService->getActiveAds('downtown_guide', $region, 'banner')->take(1);
        $featuredAds = $this->advertisementService->getActiveAds('downtown_guide', $region, 'featured')->take(1);
        $sidebarAds = $this->advertisementService->getActiveAds('downtown_guide', $region, 'sidebar')->take(3);

        return Inertia::render('downtown-guide/businesses/index', [
            'businesses' => $businesses,
            'featuredBusinesses' => $featuredWithDeals,
            'filters' => $request->only(['search', 'category', 'verified_only', 'featured_only']),
            'sort' => [
                'sort' => $filters['sort_by'],
                'direction' => $filters['sort_order'],
            ],
            'platform' => 'downtownsguide', // For theme differentiation
            'advertisements' => [
                'banner' => $bannerAds->map(fn ($ad) => $this->formatAd($ad)),
                'featured' => $featuredAds->map(fn ($ad) => $this->formatAd($ad)),
                'sidebar' => $sidebarAds->map(fn ($ad) => $this->formatAd($ad)),
            ],
        ]);
    }

    /**
     * Display a single business with DowntownsGuide-specific context
     */
    public function show(Request $request, Business $business): Response
    {
        $business = $this->businessService->find($business->id);
        
        if (!$business) {
            abort(404);
        }

        // Get reviews
        $reviews = $this->reviewService->getForModel($business, ['status' => 'approved'], 10);
        $averageRating = $this->reviewService->getAverageRating($business);
        $ratingDistribution = $this->reviewService->getRatingDistribution($business);

        // Get active coupons/deals
        $activeCoupons = $this->couponService->getCouponsForBusiness($business, true);
        $deals = $activeCoupons->filter(fn ($c) => !in_array($c->discount_type, ['percentage', 'fixed']));

        // Get upcoming events at this business
        $upcomingEvents = $this->eventService->getByVenue($business, 5);

        // Get news articles related to this business
        $relatedArticles = $this->newsService->getPublished([
            'region_id' => $business->regions->first()?->id,
        ], 5)->items();

        // Get organization relationships
        $organizationContent = $this->organizationService->getOrganizationContent($business, [
            'App\Models\DayNewsPost',
            'App\Models\Event',
            'App\Models\Coupon',
        ]);

        // Get related businesses (similar category, nearby)
        $relatedBusinesses = $this->businessService->getByCategory(
            $business->categories[0] ?? 'restaurant',
            6
        )->filter(fn ($b) => $b->id !== $business->id);

        // Get current region for ad targeting
        $region = $request->attributes->get('detected_region') ?? $business->regions->first();

        // Get advertisements
        $bannerAds = $this->advertisementService->getActiveAds('downtown_guide', $region, 'banner')->take(1);
        $sidebarAds = $this->advertisementService->getActiveAds('downtown_guide', $region, 'sidebar')->take(3);
        $inlineAds = $this->advertisementService->getActiveAds('downtown_guide', $region, 'inline')->take(2);

        return Inertia::render('downtown-guide/businesses/show', [
            'business' => $business,
            'reviews' => $reviews,
            'averageRating' => $averageRating,
            'ratingDistribution' => $ratingDistribution,
            'activeCoupons' => $activeCoupons,
            'deals' => $deals,
            'upcomingEvents' => $upcomingEvents->merge(collect($organizationContent['App\Models\Event'] ?? [])),
            'relatedArticles' => collect($relatedArticles)->merge(collect($organizationContent['App\Models\DayNewsPost'] ?? [])),
            'organizationContent' => $organizationContent,
            'relatedBusinesses' => $relatedBusinesses,
            'platform' => 'downtownsguide', // For theme differentiation
            'advertisements' => [
                'banner' => $bannerAds->map(fn ($ad) => $this->formatAd($ad)),
                'sidebar' => $sidebarAds->map(fn ($ad) => $this->formatAd($ad)),
                'inline' => $inlineAds->map(fn ($ad) => $this->formatAd($ad)),
            ],
        ]);
    }

    /**
     * Format advertisement for frontend
     */
    private function formatAd($ad): array
    {
        return [
            'id' => $ad->id,
            'placement' => $ad->placement,
            'advertable' => [
                'id' => $ad->advertable->id,
                'title' => $ad->advertable->title ?? $ad->advertable->name ?? null,
                'excerpt' => $ad->advertable->excerpt ?? $ad->advertable->description ?? null,
                'featured_image' => $ad->advertable->featured_image ?? $ad->advertable->image ?? $ad->advertable->profile_image ?? null,
                'slug' => $ad->advertable->slug ?? null,
            ],
            'expires_at' => $ad->expires_at->toISOString(),
        ];
    }
}

```

### app/Http/Controllers/TicketTransferController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\TicketOrderItem;
use App\Models\TicketTransfer;
use App\Models\User;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Illuminate\Support\Str;
use Inertia\Inertia;
use Inertia\Response;

final class TicketTransferController extends Controller
{
    public function create(Request $request, TicketOrderItem $ticketOrderItem): Response
    {
        // Verify ownership
        if ($ticketOrderItem->ticketOrder->user_id !== $request->user()->id) {
            abort(403);
        }

        return Inertia::render('event-city/tickets/transfer', [
            'ticketOrderItem' => $ticketOrderItem->load(['ticketOrder.event', 'ticketPlan']),
        ]);
    }

    public function store(Request $request, TicketOrderItem $ticketOrderItem): RedirectResponse
    {
        // Verify ownership
        if ($ticketOrderItem->ticketOrder->user_id !== $request->user()->id) {
            return redirect()->back()->withErrors(['ticket' => 'You do not own this ticket.']);
        }

        $validated = $request->validate([
            'to_email' => 'required|email',
            'message' => 'nullable|string|max:500',
            'expires_at' => 'nullable|date|after:now',
        ]);

        // Check for existing pending transfer
        $existingTransfer = TicketTransfer::where('ticket_order_item_id', $ticketOrderItem->id)
            ->where('from_user_id', $request->user()->id)
            ->pending()
            ->first();

        if ($existingTransfer) {
            return redirect()->back()->withErrors(['transfer' => 'You already have a pending transfer for this ticket.']);
        }

        // Check if recipient is a user
        $recipient = User::where('email', $validated['to_email'])->first();

        $transfer = TicketTransfer::create([
            'ticket_order_item_id' => $ticketOrderItem->id,
            'from_user_id' => $request->user()->id,
            'to_user_id' => $recipient?->id,
            'to_email' => $validated['to_email'],
            'status' => TicketTransfer::STATUS_PENDING,
            'transfer_token' => Str::random(64),
            'message' => $validated['message'] ?? null,
            'expires_at' => $validated['expires_at'] ?? now()->addDays(7),
        ]);

        // TODO: Send email notification

        return redirect()->route('tickets.my-tickets')
            ->with('success', 'Transfer request created. The recipient will receive an email notification.');
    }

    public function accept(Request $request, string $token): RedirectResponse
    {
        $transfer = TicketTransfer::where('transfer_token', $token)
            ->pending()
            ->firstOrFail();

        if ($transfer->expires_at && $transfer->expires_at->isPast()) {
            $transfer->update(['status' => TicketTransfer::STATUS_EXPIRED]);
            return redirect()->route('tickets.my-tickets')
                ->withErrors(['transfer' => 'This transfer has expired.']);
        }

        // Verify email matches if user is logged in
        if ($request->user() && $transfer->to_email !== $request->user()->email) {
            return redirect()->route('login')
                ->with('error', 'Please log in with the email address that received this transfer.');
        }

        // If user is logged in, complete transfer
        if ($request->user()) {
            $transfer->update(['to_user_id' => $request->user()->id]);
            $transfer->complete();

            return redirect()->route('tickets.my-tickets')
                ->with('success', 'Ticket transfer completed successfully.');
        }

        // Otherwise, show accept page
        return Inertia::render('event-city/tickets/accept-transfer', [
            'transfer' => $transfer->load(['ticketOrderItem.ticketOrder.event', 'fromUser']),
        ]);
    }

    public function complete(Request $request, TicketTransfer $transfer): RedirectResponse
    {
        if ($transfer->status !== TicketTransfer::STATUS_PENDING) {
            return redirect()->back()->withErrors(['transfer' => 'This transfer is no longer pending.']);
        }

        if ($transfer->to_email !== $request->user()->email) {
            return redirect()->back()->withErrors(['transfer' => 'This transfer is not for your email address.']);
        }

        $transfer->update(['to_user_id' => $request->user()->id]);
        $transfer->complete();

        return redirect()->route('tickets.my-tickets')
            ->with('success', 'Ticket transfer completed successfully.');
    }

    public function cancel(TicketTransfer $transfer): RedirectResponse
    {
        if ($transfer->from_user_id !== auth()->id()) {
            abort(403);
        }

        if ($transfer->status !== TicketTransfer::STATUS_PENDING) {
            return redirect()->back()->withErrors(['transfer' => 'This transfer cannot be cancelled.']);
        }

        $transfer->update(['status' => TicketTransfer::STATUS_CANCELLED]);

        return redirect()->back()->with('success', 'Transfer cancelled successfully.');
    }
}
```

### app/Http/Controllers/Social/ImageUploadController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Social;

use App\Http\Controllers\Controller;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Str;

final class ImageUploadController extends Controller
{
    public function upload(Request $request): JsonResponse
    {
        $request->validate([
            'image' => ['required', 'file', 'image', 'max:2048'], // 2MB max
        ]);

        $file = $request->file('image');
        $filename = Str::uuid().'.'.$file->getClientOriginalExtension();

        // Store in public disk under social/images folder
        $path = $file->storeAs('social/images', $filename, 'public');

        // Generate full URL
        $url = asset('storage/'.$path);

        return response()->json([
            'url' => $url,
            'path' => $path,
        ]);
    }
}
```

### app/Http/Controllers/PerformerController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Http\Requests\StorePerformerRequest;
use App\Models\Follow;
use App\Models\Performer;
use App\Services\SeoService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class PerformerController extends Controller
{
    /**
     * Public performers page (no authentication required)
     */
    public function publicIndex(Request $request): Response
    {
        // Get featured performers
        $featuredPerformers = Performer::active()
            ->verified()
            ->with('upcomingShows')
            ->orderBy('average_rating', 'desc')
            ->take(6)
            ->get()
            ->map(function ($performer) {
                $upcomingShow = $performer->upcomingShows->first();

                return [
                    'id' => $performer->id,
                    'name' => $performer->name,
                    'homeCity' => $performer->home_city,
                    'genres' => is_array($performer->genres) ? $performer->genres : [$performer->genres],
                    'rating' => (string) round((float) ($performer->average_rating ?? 0), 1),
                    'reviewCount' => (string) $performer->total_reviews,
                    'image' => $performer->profile_image ?? 'https://images.unsplash.com/photo-1493225457124-a3eb161ffa5f?w=400&h=300&fit=crop',
                    'upcomingShow' => $upcomingShow ? [
                        'date' => $upcomingShow->date->format('Y-m-d\TH:i:s.000\Z'),
                        'venue' => $upcomingShow->venue,
                    ] : null,
                ];
            })
            ->toArray();

        $performerCategories = [
            [
                'id' => 'bands',
                'name' => 'Bands',
                'icon' => 'music',
                'count' => Performer::whereJsonContains('genres', 'Rock')->count(),
                'color' => 'purple',
            ],
            [
                'id' => 'solo-artists',
                'name' => 'Solo Artists',
                'icon' => 'mic',
                'count' => Performer::whereJsonContains('genres', 'Singer-Songwriter')->count(),
                'color' => 'blue',
            ],
            [
                'id' => 'djs',
                'name' => 'DJs',
                'icon' => 'headphones',
                'count' => Performer::whereJsonContains('genres', 'Electronic')->count(),
                'color' => 'green',
            ],
            [
                'id' => 'acoustic',
                'name' => 'Acoustic',
                'icon' => 'guitar',
                'count' => Performer::whereJsonContains('genres', 'Acoustic')->count(),
                'color' => 'orange',
            ],
        ];

        // Get current region for ad targeting
        $region = $request->attributes->get('detected_region');

        // Get advertisements
        $bannerAds = $this->advertisementService->getActiveAds('event_city', $region, 'banner')->take(1);
        $sidebarAds = $this->advertisementService->getActiveAds('event_city', $region, 'sidebar')->take(3);

        return Inertia::render('event-city/performers', [
            'featuredPerformers' => $featuredPerformers,
            'performerCategories' => $performerCategories,
            'advertisements' => [
                'banner' => $bannerAds->map(fn ($ad) => $this->formatAd($ad)),
                'sidebar' => $sidebarAds->map(fn ($ad) => $this->formatAd($ad)),
            ],
        ]);
    }

    public function index(Request $request): Response
    {
        $currentWorkspace = $request->user()->currentWorkspace;

        if (! $currentWorkspace) {
            abort(403, 'No workspace selected');
        }

        $query = Performer::where('workspace_id', $currentWorkspace->id)
            ->with(['workspace', 'createdBy', 'upcomingShows', 'approvedReviews' => fn ($q) => $q->latest()->limit(3)])
            ->withCount(['reviews as total_reviews', 'ratings as total_ratings']);

        // Apply filters
        if ($request->filled('status')) {
            $query->where('status', $request->status);
        }

        if ($request->filled('verified')) {
            $query->where('is_verified', $request->boolean('verified'));
        }

        if ($request->filled('available')) {
            $query->where('available_for_booking', $request->boolean('available'));
        }

        if ($request->filled('genres')) {
            $genres = is_array($request->genres) ? $request->genres : [$request->genres];
            foreach ($genres as $genre) {
                $query->whereJsonContains('genres', $genre);
            }
        }

        if ($request->filled('search')) {
            $search = $request->search;
            $query->where(function ($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                    ->orWhere('bio', 'like', "%{$search}%")
                    ->orWhere('home_city', 'like', "%{$search}%");
            });
        }

        if ($request->filled('rating_min')) {
            $query->where('average_rating', '>=', $request->float('rating_min'));
        }

        if ($request->filled('family_friendly')) {
            $query->where('is_family_friendly', $request->boolean('family_friendly'));
        }

        // Sorting
        $sortBy = $request->get('sort', 'created_at');
        $sortDirection = $request->get('direction', 'desc');

        match ($sortBy) {
            'name' => $query->orderBy('name', $sortDirection),
            'rating' => $query->orderBy('average_rating', $sortDirection),
            'experience' => $query->orderBy('years_active', $sortDirection),
            'price' => $query->orderBy('base_price', $sortDirection),
            'trending' => $query->orderBy('trending_score', $sortDirection),
            default => $query->orderBy('created_at', $sortDirection),
        };

        $performers = $query->paginate(12)->withQueryString();

        // Get current region for ad targeting
        $region = $request->attributes->get('detected_region');

        // Get advertisements
        $sidebarAds = $this->advertisementService->getActiveAds('event_city', $region, 'sidebar')->take(3);

        return Inertia::render('event-city/performers/Index', [
            'performers' => $performers,
            'filters' => $request->only(['status', 'verified', 'available', 'genres', 'search', 'rating_min', 'family_friendly']),
            'sort' => ['sort' => $sortBy, 'direction' => $sortDirection],
            'advertisements' => [
                'sidebar' => $sidebarAds->map(fn ($ad) => $this->formatAd($ad)),
            ],
        ]);
    }

    public function show(Request $request, Performer $performer): Response
    {
        $performer->load([
            'workspace',
            'createdBy',
            'upcomingShows' => fn ($q) => $q->orderBy('date', 'asc'),
            'approvedReviews.user',
            'ratings.user',
            'events' => fn ($q) => $q->published()->upcoming()->limit(5),
            'bookings' => fn ($q) => $q->confirmed()->limit(10),
        ]);

        $ratingStats = [
            'average' => (float) ($performer->average_rating ?? 0),
            'total' => $performer->ratings()->count(),
            'distribution' => $performer->getRatingDistribution(),
            'by_context' => [
                'performance' => (float) ($performer->getAverageRatingByContext('performance') ?? 0),
                'professionalism' => (float) ($performer->getAverageRatingByContext('professionalism') ?? 0),
                'value' => (float) ($performer->getAverageRatingByContext('value') ?? 0),
                'overall' => (float) ($performer->getAverageRatingByContext('overall') ?? 0),
            ],
        ];

        // Format upcoming shows for frontend
        $upcomingShows = $performer->upcomingShows->map(fn ($show) => [
            'id' => $show->id,
            'date' => $show->date->toISOString(),
            'venue' => $show->venue,
            'location' => $show->location ?? '',
            'ticketsAvailable' => $show->tickets_available,
            'ticketUrl' => $show->ticket_url,
        ])->toArray();

        // Format reviews for frontend
        $reviews = $performer->approvedReviews->map(fn ($review) => [
            'id' => $review->id,
            'content' => $review->content,
            'rating' => $review->rating,
            'user' => [
                'name' => $review->user->name,
                'avatar' => $review->user->avatar_url ?? null,
            ],
            'created_at' => $review->created_at->toISOString(),
        ])->toArray();

        // Format events for frontend
        $events = $performer->events->map(fn ($event) => [
            'id' => $event->id,
            'title' => $event->title,
            'description' => $event->description,
            'event_date' => $event->event_date,
            'time' => $event->time,
            'image' => $event->image,
            'venue' => [
                'id' => $event->venue->id ?? null,
                'name' => $event->venue->name ?? '',
                'address' => $event->venue->address ?? '',
            ],
        ])->toArray();

        // Prepare performer data for frontend
        $performerData = [
            'id' => $performer->id,
            'name' => $performer->name,
            'profileImage' => $performer->profile_image,
            'genres' => $performer->genres,
            'rating' => (float) $performer->average_rating,
            'reviewCount' => $performer->total_reviews,
            'followerCount' => $performer->follower_count,
            'bio' => $performer->bio,
            'yearsActive' => $performer->years_active,
            'showsPlayed' => $performer->shows_played,
            'homeCity' => $performer->home_city,
            'isVerified' => $performer->is_verified,
            'isTouringNow' => $performer->is_touring_now,
            'availableForBooking' => $performer->available_for_booking,
            'hasMerchandise' => $performer->has_merchandise,
            'hasOriginalMusic' => $performer->has_original_music,
            'offersMeetAndGreet' => $performer->offers_meet_and_greet,
            'takesRequests' => $performer->takes_requests,
            'availableForPrivateEvents' => $performer->available_for_private_events,
            'isFamilyFriendly' => $performer->is_family_friendly,
            'hasSamples' => $performer->has_samples,
            'trendingScore' => $performer->trending_score,
            'upcomingShows' => $upcomingShows,
            'events' => $events,
        ];

        $isFollowing = false;
        if ($request->user()) {
            $isFollowing = Follow::where('user_id', $request->user()->id)
                ->where('followable_type', Performer::class)
                ->where('followable_id', $performer->id)
                ->exists();
        }

        // Build SEO JSON-LD for performer
        $seoData = [
            'title' => "{$performer->name} - Performer Profile",
            'name' => $performer->name,
            'description' => $performer->bio,
            'image' => $performer->profile_image,
            'url' => "/performers/{$performer->id}",
            'genres' => $performer->genres,
            'homeCity' => $performer->home_city,
            'isVerified' => $performer->is_verified,
        ];

        // Get current region for ad targeting
        $region = $request->attributes->get('detected_region');

        // Get advertisements
        $bannerAds = $this->advertisementService->getActiveAds('event_city', $region, 'banner')->take(1);
        $sidebarAds = $this->advertisementService->getActiveAds('event_city', $region, 'sidebar')->take(3);
        $inlineAds = $this->advertisementService->getActiveAds('event_city', $region, 'inline')->take(2);

        return Inertia::render('event-city/performers/show', [
            'seo' => [
                'jsonLd' => SeoService::buildJsonLd('performer', $seoData, 'event-city'),
            ],
            'performer' => $performerData,
            'ratingStats' => $ratingStats,
            'reviews' => $reviews,
            'isFollowing' => $isFollowing,
            'advertisements' => [
                'banner' => $bannerAds->map(fn ($ad) => $this->formatAd($ad)),
                'sidebar' => $sidebarAds->map(fn ($ad) => $this->formatAd($ad)),
                'inline' => $inlineAds->map(fn ($ad) => $this->formatAd($ad)),
            ],
        ]);
    }

    public function featured(Request $request): array
    {
        $currentWorkspace = $request->user()->currentWorkspace;

        if (! $currentWorkspace) {
            return [];
        }

        $performers = Performer::where('workspace_id', $currentWorkspace->id)
            ->where('status', 'active')
            ->where('is_verified', true)
            ->where('available_for_booking', true)
            ->highlyRated(4.0)
            ->with('upcomingShows')
            ->orderBy('trending_score', 'desc')
            ->orderBy('average_rating', 'desc')
            ->limit(6)
            ->get()
            ->map(function ($performer) {
                $nextShow = $performer->upcomingShows->first();

                return [
                    'id' => $performer->id,
                    'name' => $performer->name,
                    'image' => $performer->profile_image ?: '/images/performer-placeholder.jpg',
                    'genres' => $performer->genres,
                    'rating' => number_format((float) ($performer->average_rating ?? 0), 1),
                    'reviewCount' => $performer->total_reviews,
                    'homeCity' => $performer->home_city,
                    'yearsActive' => $performer->years_active,
                    'showsPlayed' => $performer->shows_played,
                    'isVerified' => $performer->is_verified,
                    'availableForBooking' => $performer->available_for_booking,
                    'upcomingShow' => $nextShow ? [
                        'date' => $nextShow->date->toISOString(),
                        'venue' => $nextShow->venue,
                        'ticketsAvailable' => $nextShow->tickets_available,
                    ] : null,
                ];
            });

        return $performers->toArray();
    }

    public function trending(Request $request): array
    {
        $currentWorkspace = $request->user()->currentWorkspace;

        if (! $currentWorkspace) {
            return [];
        }

        $performers = Performer::where('workspace_id', $currentWorkspace->id)
            ->where('status', 'active')
            ->where('available_for_booking', true)
            ->trending()
            ->with('upcomingShows')
            ->orderBy('trending_score', 'desc')
            ->limit(8)
            ->get()
            ->map(function ($performer) {
                return [
                    'id' => $performer->id,
                    'name' => $performer->name,
                    'image' => $performer->profile_image ?: '/images/performer-placeholder.jpg',
                    'genres' => $performer->genres,
                    'rating' => number_format((float) ($performer->average_rating ?? 0), 1),
                    'trendingScore' => $performer->trending_score,
                    'homeCity' => $performer->home_city,
                ];
            });

        return $performers->toArray();
    }

    public function create(): Response
    {
        $currentWorkspace = auth()->user()->currentWorkspace;

        if (! $currentWorkspace) {
            abort(403, 'Please select a workspace first.');
        }

        $this->authorize('create', Performer::class);

        return Inertia::render('event-city/performers/create', [
            'workspace' => [
                'can_accept_payments' => $currentWorkspace->canAcceptPayments(),
            ],
        ]);
    }

    public function store(StorePerformerRequest $request)
    {
        $this->authorize('create', Performer::class);

        $currentWorkspace = $request->user()->currentWorkspace;

        if (! $currentWorkspace) {
            abort(403, 'No workspace selected');
        }

        $validated = $request->validated();

        // Handle image uploads
        $imagePaths = [];
        if ($request->hasFile('images')) {
            foreach ($request->file('images') as $index => $image) {
                $path = $image->store('performers', 'public');
                $imagePaths[] = $path;

                // Set first image as profile image
                if ($index === 0 && ! isset($validated['profile_image'])) {
                    $validated['profile_image'] = $path;
                }
            }
        }

        $performer = Performer::create([
            ...$validated,
            'workspace_id' => $currentWorkspace->id,
            'created_by' => $request->user()->id,
            'status' => 'active',
            'follower_count' => 0,
            'trending_score' => 0,
            'added_date' => now(),
            'introductory_pricing' => true,
        ]);

        return redirect()->route('performers.show', $performer)
            ->with('success', 'Performer profile created successfully!');
    }

    public function edit(Performer $performer): Response
    {
        $this->authorize('update', $performer);

        return Inertia::render('event-city/performers/Edit', [
            'performer' => $performer,
        ]);
    }

    public function update(Request $request, Performer $performer)
    {
        $this->authorize('update', $performer);

        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'bio' => 'required|string',
            'genres' => 'required|array|min:1',
            'home_city' => 'required|string',
            'years_active' => 'required|integer|min:0',
            'shows_played' => 'required|integer|min:0',
            'profile_image' => 'nullable|url',
            'base_price' => 'nullable|numeric|min:0',
            'minimum_booking_hours' => 'required|integer|min:1',
            'travel_fee_per_mile' => 'nullable|numeric|min:0',
            'setup_fee' => 'nullable|numeric|min:0',
            'cancellation_policy' => 'nullable|string',
            'available_for_booking' => 'boolean',
            'is_family_friendly' => 'boolean',
            'has_merchandise' => 'boolean',
            'has_original_music' => 'boolean',
            'offers_meet_and_greet' => 'boolean',
            'takes_requests' => 'boolean',
            'available_for_private_events' => 'boolean',
            'has_samples' => 'boolean',
        ]);

        $performer->update($validated);

        return redirect()->route('performers.show', $performer)
            ->with('success', 'Performer profile updated successfully!');
    }

    public function destroy(Performer $performer)
    {
        $this->authorize('delete', $performer);

        $performer->delete();

        return redirect()->route('performers.index')
            ->with('success', 'Performer profile deleted successfully!');
    }

    /**
     * Format advertisement for frontend
     */
    private function formatAd($ad): array
    {
        return [
            'id' => $ad->id,
            'placement' => $ad->placement,
            'advertable' => [
                'id' => $ad->advertable->id,
                'title' => $ad->advertable->title ?? $ad->advertable->name ?? null,
                'excerpt' => $ad->advertable->excerpt ?? $ad->advertable->description ?? null,
                'featured_image' => $ad->advertable->featured_image ?? $ad->advertable->image ?? $ad->advertable->profile_image ?? null,
                'slug' => $ad->advertable->slug ?? null,
            ],
            'expires_at' => $ad->expires_at->toISOString(),
        ];
    }
}
```

### app/Http/Controllers/HubController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\Hub;
use App\Models\HubMember;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class HubController extends Controller
{
    public function index(Request $request): Response
    {
        $query = Hub::query()
            ->with(['workspace', 'createdBy', 'sections'])
            ->withCount(['members', 'events', 'follows']);

        if ($request->filled('search')) {
            $query->where(function ($q) use ($request) {
                $q->where('name', 'ILIKE', "%{$request->input('search')}%")
                    ->orWhere('description', 'ILIKE', "%{$request->input('search')}%");
            });
        }

        if ($request->filled('category')) {
            $query->where('category', $request->input('category'));
        }

        if ($request->boolean('featured')) {
            $query->featured();
        }

        if ($request->boolean('verified')) {
            $query->verified();
        }

        $hubs = $query->published()
            ->active()
            ->latest('published_at')
            ->paginate(12);

        return Inertia::render('event-city/hubs/index', [
            'hubs' => $hubs,
            'filters' => [
                'search' => $request->input('search'),
                'category' => $request->input('category'),
                'featured' => $request->boolean('featured'),
                'verified' => $request->boolean('verified'),
            ],
        ]);
    }

    public function create(Request $request): Response
    {
        return Inertia::render('event-city/hubs/create');
    }

    public function store(Request $request): RedirectResponse
    {
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'description' => 'nullable|string',
            'category' => 'nullable|string|max:255',
            'subcategory' => 'nullable|string|max:255',
            'location' => 'nullable|string|max:255',
            'website' => 'nullable|url|max:255',
            'contact_email' => 'nullable|email|max:255',
            'contact_phone' => 'nullable|string|max:255',
            'about' => 'nullable|string',
            'social_links' => 'nullable|array',
            'design_settings' => 'nullable|array',
            'monetization_settings' => 'nullable|array',
            'analytics_enabled' => 'boolean',
            'articles_enabled' => 'boolean',
            'community_enabled' => 'boolean',
            'events_enabled' => 'boolean',
            'gallery_enabled' => 'boolean',
            'performers_enabled' => 'boolean',
            'venues_enabled' => 'boolean',
        ]);

        $user = $request->user();
        $workspace = $user->currentWorkspace ?? $user->workspaces->first();

        if (!$workspace) {
            return redirect()->back()->withErrors(['workspace' => 'You must belong to a workspace to create a hub.']);
        }

        $hub = Hub::create([
            ...$validated,
            'workspace_id' => $workspace->id,
            'created_by' => $user->id,
            'slug' => Hub::generateUniqueSlug($validated['name']),
            'is_active' => true,
            'published_at' => now(),
        ]);

        // Create default owner member
        $hub->members()->create([
            'user_id' => $user->id,
            'role' => HubMember::ROLE_OWNER,
            'joined_at' => now(),
            'is_active' => true,
        ]);

        return redirect()->route('hubs.show', $hub->slug)
            ->with('success', 'Hub created successfully.');
    }

    public function show(Request $request, string $slug): Response
    {
        $hub = Hub::where('slug', $slug)
            ->with(['workspace', 'createdBy', 'sections', 'members.user'])
            ->withCount(['members', 'events', 'follows'])
            ->published()
            ->active()
            ->firstOrFail();

        $isMember = false;
        $userRole = null;
        if ($request->user()) {
            $member = $hub->members()->where('user_id', $request->user()->id)->active()->first();
            $isMember = $member !== null;
            $userRole = $member?->role;
        }

        return Inertia::render('event-city/hubs/show', [
            'hub' => $hub,
            'isMember' => $isMember,
            'userRole' => $userRole,
        ]);
    }

    public function edit(Request $request, Hub $hub): Response
    {
        $this->authorize('update', $hub);

        return Inertia::render('event-city/hubs/edit', [
            'hub' => $hub->load(['sections', 'members.user']),
        ]);
    }

    public function update(Request $request, Hub $hub): RedirectResponse
    {
        $this->authorize('update', $hub);

        $validated = $request->validate([
            'name' => 'sometimes|string|max:255',
            'description' => 'nullable|string',
            'category' => 'nullable|string|max:255',
            'subcategory' => 'nullable|string|max:255',
            'location' => 'nullable|string|max:255',
            'website' => 'nullable|url|max:255',
            'contact_email' => 'nullable|email|max:255',
            'contact_phone' => 'nullable|string|max:255',
            'about' => 'nullable|string',
            'social_links' => 'nullable|array',
            'design_settings' => 'nullable|array',
            'monetization_settings' => 'nullable|array',
            'analytics_enabled' => 'boolean',
            'articles_enabled' => 'boolean',
            'community_enabled' => 'boolean',
            'events_enabled' => 'boolean',
            'gallery_enabled' => 'boolean',
            'performers_enabled' => 'boolean',
            'venues_enabled' => 'boolean',
        ]);

        if (isset($validated['name']) && $validated['name'] !== $hub->name) {
            $validated['slug'] = Hub::generateUniqueSlug($validated['name']);
        }

        $hub->update($validated);

        return redirect()->route('hubs.show', $hub->slug)
            ->with('success', 'Hub updated successfully.');
    }

    public function destroy(Hub $hub): RedirectResponse
    {
        $this->authorize('delete', $hub);

        $hub->delete();

        return redirect()->route('hubs.index')
            ->with('success', 'Hub deleted successfully.');
    }
}
```

### app/Http/Controllers/SocialFeedController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Services\SocialFeedAlgorithmService;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class SocialFeedController extends Controller
{
    public function __construct(
        private readonly SocialFeedAlgorithmService $feedService
    ) {}

    public function index(Request $request): Response
    {
        $user = $request->user();
        $page = $request->integer('page', 1);
        $feedType = $request->string('feed', 'for-you');

        $forYouFeed = $this->feedService->getForYouFeed($user, $page);
        $followedFeed = $this->feedService->getFollowedFeed($user, $page);

        return Inertia::render('event-city/social/Feed', [
            'forYouFeed' => $forYouFeed,
            'followedFeed' => $followedFeed,
            'currentFeed' => $feedType,
        ]);
    }

    public function forYou(Request $request): JsonResponse
    {
        $user = $request->user();
        $page = $request->integer('page', 1);
        $perPage = $request->integer('per_page', 20);

        $feed = $this->feedService->getForYouFeed($user, $page, $perPage);

        return response()->json([
            'data' => $feed->items(),
            'pagination' => [
                'current_page' => $feed->currentPage(),
                'last_page' => $feed->lastPage(),
                'per_page' => $feed->perPage(),
                'total' => $feed->total(),
                'has_more' => $feed->hasMorePages(),
            ],
        ]);
    }

    public function followed(Request $request): JsonResponse
    {
        $user = $request->user();
        $page = $request->integer('page', 1);
        $perPage = $request->integer('per_page', 20);

        $feed = $this->feedService->getFollowedFeed($user, $page, $perPage);

        return response()->json([
            'data' => $feed->items(),
            'pagination' => [
                'current_page' => $feed->currentPage(),
                'last_page' => $feed->lastPage(),
                'per_page' => $feed->perPage(),
                'total' => $feed->total(),
                'has_more' => $feed->hasMorePages(),
            ],
        ]);
    }
}
```

### app/Http/Controllers/AlphaSite/ClaimController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\AlphaSite;

use App\Http\Controllers\Controller;
use App\Models\Business;
use App\Services\BusinessService;
use App\Services\AlphaSite\SubscriptionLifecycleService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;
use Illuminate\Http\RedirectResponse;

final class ClaimController extends Controller
{
    public function __construct(
        private readonly BusinessService $businessService,
        private readonly SubscriptionLifecycleService $subscriptionService
    ) {}

    /**
     * Start claim process
     */
    public function start(string $slug): Response
    {
        $business = $this->businessService->findBySlug($slug);
        
        if (!$business) {
            abort(404);
        }

        return Inertia::render('alphasite/claim/start', [
            'business' => $business,
        ]);
    }

    /**
     * Verify business ownership
     */
    public function verify(Request $request, string $slug): RedirectResponse
    {
        $business = $this->businessService->findBySlug($slug);
        
        if (!$business) {
            abort(404);
        }

        // TODO: Implement verification logic (phone, email, document)
        $request->validate([
            'verification_method' => 'required|in:phone,email,document',
            'verification_data' => 'required',
        ]);

        // Store verification attempt in session
        $request->session()->put("claim_verification:{$business->id}", [
            'method' => $request->verification_method,
            'data' => $request->verification_data,
            'verified' => false, // TODO: Implement actual verification
        ]);

        return redirect()->route('alphasite.claim.complete', $slug);
    }

    /**
     * Complete claim and subscription
     */
    public function complete(Request $request, string $slug): Response
    {
        $business = $this->businessService->findBySlug($slug);
        
        if (!$business) {
            abort(404);
        }

        $verification = $request->session()->get("claim_verification:{$business->id}");

        if (!$verification || !$verification['verified']) {
            return redirect()->route('alphasite.claim.start', $slug)
                ->with('error', 'Please verify your ownership first.');
        }

        return Inertia::render('alphasite/claim/complete', [
            'business' => $business,
            'subscriptionTiers' => [
                'standard' => ['name' => 'Standard', 'price' => 29.99],
                'premium' => ['name' => 'Premium', 'price' => 79.99],
                'enterprise' => ['name' => 'Enterprise', 'price' => 199.99],
            ],
        ]);
    }

    /**
     * Subscribe after claiming
     */
    public function subscribe(Request $request, string $slug): RedirectResponse
    {
        $business = $this->businessService->findBySlug($slug);
        
        if (!$business) {
            abort(404);
        }

        $request->validate([
            'tier' => 'required|in:standard,premium,enterprise',
            'stripe_subscription_id' => 'required|string',
        ]);

        // Get or create subscription
        $subscription = $business->subscription ?? $this->subscriptionService->initializeTrial($business);
        
        // Convert to paid
        $this->subscriptionService->convertToPaid(
            $subscription,
            $request->tier,
            $request->stripe_subscription_id,
            [] // AI services will be added separately
        );

        return redirect()->route('alphasite.business.show', $slug)
            ->with('success', 'Business claimed successfully!');
    }
}
```

### app/Http/Controllers/AlphaSite/BusinessPageController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\AlphaSite;

use App\Http\Controllers\Controller;
use App\Models\Business;
use App\Services\BusinessService;
use App\Services\AlphaSite\PageGeneratorService;
use App\Services\AlphaSite\LinkingService;
use App\Services\ReviewService;
use App\Services\CouponService;
use App\Services\EventService;
use App\Services\NewsService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class BusinessPageController extends Controller
{
    public function __construct(
        private readonly BusinessService $businessService,
        private readonly PageGeneratorService $pageGeneratorService,
        private readonly LinkingService $linkingService,
        private readonly ReviewService $reviewService,
        private readonly CouponService $couponService,
        private readonly EventService $eventService,
        private readonly NewsService $newsService
    ) {}

    /**
     * Show business page by subdomain
     */
    public function showBySubdomain(string $subdomain): Response
    {
        $business = $this->businessService->getBusinessForAlphaSite($subdomain);
        
        if (!$business) {
            abort(404);
        }

        return $this->renderBusinessPage($business, 'overview');
    }

    /**
     * Show business page by slug
     */
    public function show(string $slug): Response
    {
        $business = $this->businessService->getBusinessForAlphaSite($slug);
        
        if (!$business) {
            abort(404);
        }

        return $this->renderBusinessPage($business, 'overview');
    }

    /**
     * Show specific tab
     */
    public function showTab(string $slug, string $tab): Response
    {
        $business = $this->businessService->getBusinessForAlphaSite($slug);
        
        if (!$business) {
            abort(404);
        }

        return $this->renderBusinessPage($business, $tab);
    }

    /**
     * Render the business page with all data
     */
    private function renderBusinessPage(Business $business, string $activeTab): Response
    {
        // Generate the complete page data
        $pageData = $this->pageGeneratorService->generateBusinessPage($business);
        
        // Get cross-platform content (articles, events, coupons from other platforms)
        $crossPlatformContent = $this->linkingService->getCrossPlatformContent($business);
        
        // Get related businesses
        $relatedBusinesses = $this->businessService->getRelatedBusinesses($business);

        return Inertia::render('alphasite/business/show', [
            'business' => $business,
            'template' => $pageData['template'],
            'seo' => $pageData['seo'],
            'schema' => $pageData['schema'],
            'tabs' => $pageData['tabs'],
            'aiServices' => $pageData['aiServices'],
            'communityLinks' => $pageData['communityLinks'],
            'crossPlatformContent' => $crossPlatformContent,
            'relatedBusinesses' => $relatedBusinesses,
            'activeTab' => $activeTab,
        ]);
    }

    /**
     * Reviews tab
     */
    public function reviews(string $slug): Response
    {
        return $this->showTab($slug, 'reviews');
    }

    /**
     * Photos tab
     */
    public function photos(string $slug): Response
    {
        return $this->showTab($slug, 'photos');
    }

    /**
     * Menu tab (restaurants only)
     */
    public function menu(string $slug): Response
    {
        return $this->showTab($slug, 'menu');
    }

    /**
     * Articles tab - shows Day.News articles about this business
     */
    public function articles(string $slug): Response
    {
        return $this->showTab($slug, 'articles');
    }

    /**
     * Events tab - shows GoEventCity events for this business
     */
    public function events(string $slug): Response
    {
        return $this->showTab($slug, 'events');
    }

    /**
     * Coupons tab
     */
    public function coupons(string $slug): Response
    {
        return $this->showTab($slug, 'coupons');
    }

    /**
     * Achievements tab
     */
    public function achievements(string $slug): Response
    {
        return $this->showTab($slug, 'achievements');
    }

    /**
     * AI Chat endpoint
     */
    public function aiChat(Request $request, string $slug)
    {
        $business = $this->businessService->getBusinessForAlphaSite($slug);
        
        if (!$business) {
            abort(404);
        }

        // TODO: Implement AI chat processing
        return response()->json([
            'response' => 'AI chat functionality coming soon',
            'business_id' => $business->id,
        ]);
    }
}
```

### app/Http/Controllers/AlphaSite/SearchController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\AlphaSite;

use App\Http\Controllers\Controller;
use App\Services\BusinessService;
use App\Services\SearchService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class SearchController extends Controller
{
    public function __construct(
        private readonly BusinessService $businessService,
        private readonly SearchService $searchService
    ) {}

    /**
     * Search results page
     */
    public function index(Request $request): Response
    {
        $query = $request->input('q', '');
        
        $results = $this->searchService->search($query, [
            'types' => ['business'],
            'limit' => 24,
        ]);

        return Inertia::render('alphasite/search/index', [
            'query' => $query,
            'results' => $results,
        ]);
    }

    /**
     * Search suggestions (autocomplete)
     */
    public function suggestions(Request $request)
    {
        $query = $request->input('q', '');
        
        if (strlen($query) < 2) {
            return response()->json([]);
        }

        $suggestions = $this->searchService->getSuggestions($query, 10);

        return response()->json($suggestions);
    }
}
```

### app/Http/Controllers/AlphaSite/DirectoryController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\AlphaSite;

use App\Http\Controllers\Controller;
use App\Models\Region;
use App\Services\AdvertisementService;
use App\Services\BusinessService;
use App\Services\LocationService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class DirectoryController extends Controller
{
    public function __construct(
        private readonly BusinessService $businessService,
        private readonly AdvertisementService $advertisementService,
        private readonly LocationService $locationService
    ) {}

    /**
     * Homepage
     */
    public function home(): Response
    {
        // Get region for ad targeting
        $region = request()->attributes->get('detected_region');

        // Get advertisements
        $bannerAds = $this->advertisementService->getActiveAds('alphasite', $region, 'banner')->take(1);
        $featuredAds = $this->advertisementService->getActiveAds('alphasite', $region, 'featured')->take(1);

        return Inertia::render('alphasite/home', [
            'featuredBusinesses' => $this->businessService->getFeatured(12),
            'advertisements' => [
                'banner' => $bannerAds->map(fn ($ad) => $this->formatAd($ad)),
                'featured' => $featuredAds->map(fn ($ad) => $this->formatAd($ad)),
            ],
        ]);
    }

    /**
     * Directory index
     */
    public function index(Request $request): Response
    {
        $businesses = $this->businessService->search(
            $request->input('search'),
            [
                'status' => 'active',
                'sort_by' => $request->get('sort', 'name'),
                'sort_order' => $request->get('direction', 'asc'),
            ],
            24,
            (int) $request->input('page', 1)
        );

        // Get region for ad targeting
        $region = $request->attributes->get('detected_region');

        // Get advertisements
        $bannerAds = $this->advertisementService->getActiveAds('alphasite', $region, 'banner')->take(1);
        $sidebarAds = $this->advertisementService->getActiveAds('alphasite', $region, 'sidebar')->take(3);

        return Inertia::render('alphasite/directory/index', [
            'businesses' => $businesses,
            'filters' => $request->only(['search', 'sort', 'direction']),
            'advertisements' => [
                'banner' => $bannerAds->map(fn ($ad) => $this->formatAd($ad)),
                'sidebar' => $sidebarAds->map(fn ($ad) => $this->formatAd($ad)),
            ],
        ]);
    }

    /**
     * Directory by location
     */
    public function byLocation(string $city, string $state, Request $request): Response
    {
        $businesses = $this->businessService->search(
            $request->input('search'),
            [
                'status' => 'active',
                'city' => $city,
                'state' => $state,
                'sort_by' => $request->get('sort', 'name'),
                'sort_order' => $request->get('direction', 'asc'),
            ],
            24,
            (int) $request->input('page', 1)
        );

        // Get region for ad targeting
        $region = $request->attributes->get('detected_region');

        // Get advertisements
        $bannerAds = $this->advertisementService->getActiveAds('alphasite', $region, 'banner')->take(1);
        $sidebarAds = $this->advertisementService->getActiveAds('alphasite', $region, 'sidebar')->take(3);

        return Inertia::render('alphasite/directory/location', [
            'businesses' => $businesses,
            'city' => $city,
            'state' => $state,
            'filters' => $request->only(['search', 'sort', 'direction']),
            'advertisements' => [
                'banner' => $bannerAds->map(fn ($ad) => $this->formatAd($ad)),
                'sidebar' => $sidebarAds->map(fn ($ad) => $this->formatAd($ad)),
            ],
        ]);
    }

    /**
     * Get started page
     */
    public function getStarted(): Response
    {
        return Inertia::render('alphasite/get-started');
    }

    /**
     * Format advertisement for frontend
     */
    private function formatAd($ad): array
    {
        return [
            'id' => $ad->id,
            'placement' => $ad->placement,
            'advertable' => [
                'id' => $ad->advertable->id,
                'title' => $ad->advertable->title ?? $ad->advertable->name ?? null,
                'excerpt' => $ad->advertable->excerpt ?? $ad->advertable->description ?? null,
                'featured_image' => $ad->advertable->featured_image ?? $ad->advertable->image ?? $ad->advertable->profile_image ?? null,
                'slug' => $ad->advertable->slug ?? null,
            ],
            'expires_at' => $ad->expires_at->toISOString(),
        ];
    }
}
```

### app/Http/Controllers/AlphaSite/SMBCrmController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\AlphaSite;

use App\Http\Controllers\Controller;
use App\Models\Business;
use App\Services\BusinessService;
use App\Services\AlphaSite\SMBCrmService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class SMBCrmController extends Controller
{
    public function __construct(
        private readonly BusinessService $businessService,
        private readonly SMBCrmService $crmService
    ) {}

    /**
     * CRM Dashboard
     */
    public function dashboard(Request $request): Response
    {
        // TODO: Get business from authenticated user's claimed businesses
        $business = Business::where('claimed_by_id', $request->user()->id)->first();
        
        if (!$business) {
            abort(404, 'No claimed business found');
        }

        $dashboardData = $this->crmService->getDashboardData($business);

        return Inertia::render('alphasite/crm/dashboard', [
            'business' => $business,
            'dashboard' => $dashboardData,
        ]);
    }

    /**
     * Customers list
     */
    public function customers(Request $request): Response
    {
        $business = Business::where('claimed_by_id', $request->user()->id)->first();
        
        if (!$business) {
            abort(404);
        }

        $customers = $this->crmService->getCustomers($business, $request->all());

        return Inertia::render('alphasite/crm/customers', [
            'business' => $business,
            'customers' => $customers,
        ]);
    }

    /**
     * Show customer
     */
    public function showCustomer(Request $request, string $customer): Response
    {
        $business = Business::where('claimed_by_id', $request->user()->id)->first();
        
        if (!$business) {
            abort(404);
        }

        $customerData = $this->crmService->getCustomer($business, $customer);

        return Inertia::render('alphasite/crm/customer/show', [
            'business' => $business,
            'customer' => $customerData,
        ]);
    }

    /**
     * Interactions list
     */
    public function interactions(Request $request): Response
    {
        $business = Business::where('claimed_by_id', $request->user()->id)->first();
        
        if (!$business) {
            abort(404);
        }

        $interactions = $this->crmService->getInteractions($business, $request->all());

        return Inertia::render('alphasite/crm/interactions', [
            'business' => $business,
            'interactions' => $interactions,
        ]);
    }

    /**
     * FAQs management
     */
    public function faqs(Request $request): Response
    {
        $business = Business::where('claimed_by_id', $request->user()->id)->first();
        
        if (!$business) {
            abort(404);
        }

        $faqs = $this->crmService->getFaqs($business);

        return Inertia::render('alphasite/crm/faqs', [
            'business' => $business,
            'faqs' => $faqs,
        ]);
    }

    /**
     * Store FAQ
     */
    public function storeFaq(Request $request)
    {
        $business = Business::where('claimed_by_id', $request->user()->id)->first();
        
        if (!$business) {
            abort(404);
        }

        $request->validate([
            'question' => 'required|string',
            'answer' => 'required|string',
            'category' => 'nullable|string',
        ]);

        $this->crmService->createFaq($business, $request->all());

        return redirect()->back()->with('success', 'FAQ created successfully');
    }

    /**
     * Surveys management
     */
    public function surveys(Request $request): Response
    {
        $business = Business::where('claimed_by_id', $request->user()->id)->first();
        
        if (!$business) {
            abort(404);
        }

        $surveys = $this->crmService->getSurveys($business);

        return Inertia::render('alphasite/crm/surveys', [
            'business' => $business,
            'surveys' => $surveys,
        ]);
    }

    /**
     * AI Services configuration
     */
    public function aiServices(Request $request): Response
    {
        $business = Business::where('claimed_by_id', $request->user()->id)->first();
        
        if (!$business) {
            abort(404);
        }

        $servicesConfig = $this->crmService->getAIServicesConfig($business);

        return Inertia::render('alphasite/crm/ai-services', [
            'business' => $business,
            'servicesConfig' => $servicesConfig,
        ]);
    }
}
```

### app/Http/Controllers/AlphaSite/CommunityController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\AlphaSite;

use App\Http\Controllers\Controller;
use App\Models\AlphaSiteCommunity;
use App\Models\Region;
use App\Services\AdvertisementService;
use App\Services\AlphaSite\CommunityService;
use App\Services\LocationService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class CommunityController extends Controller
{
    public function __construct(
        private readonly CommunityService $communityService,
        private readonly AdvertisementService $advertisementService,
        private readonly LocationService $locationService
    ) {}

    /**
     * Show community page
     */
    public function show(string $city, string $state, Request $request): Response
    {
        $community = $this->communityService->getOrCreateCommunity($city, $state);
        
        $businesses = $this->communityService->getCommunityBusinesses(
            $community,
            $request->input('category'),
            24
        );

        $categories = $this->communityService->getCommunityCategories($community);

        // Get region for ad targeting (try to find region from city/state)
        $region = $request->attributes->get('detected_region');

        // Get advertisements
        $bannerAds = $this->advertisementService->getActiveAds('alphasite', $region, 'banner')->take(1);
        $sidebarAds = $this->advertisementService->getActiveAds('alphasite', $region, 'sidebar')->take(3);

        return Inertia::render('alphasite/community/show', [
            'community' => $community,
            'businesses' => $businesses,
            'categories' => $categories,
            'activeCategory' => $request->input('category'),
            'advertisements' => [
                'banner' => $bannerAds->map(fn ($ad) => $this->formatAd($ad)),
                'sidebar' => $sidebarAds->map(fn ($ad) => $this->formatAd($ad)),
            ],
        ]);
    }

    /**
     * Downtown businesses
     */
    public function downtown(string $city, string $state, Request $request): Response
    {
        // Similar to show but filtered for downtown area
        return $this->show($city, $state, $request);
    }

    /**
     * Category filtered community page
     */
    public function category(string $city, string $state, string $category, Request $request): Response
    {
        $request->merge(['category' => $category]);
        return $this->show($city, $state, $request);
    }

    /**
     * Format advertisement for frontend
     */
    private function formatAd($ad): array
    {
        return [
            'id' => $ad->id,
            'placement' => $ad->placement,
            'advertable' => [
                'id' => $ad->advertable->id,
                'title' => $ad->advertable->title ?? $ad->advertable->name ?? null,
                'excerpt' => $ad->advertable->excerpt ?? $ad->advertable->description ?? null,
                'featured_image' => $ad->advertable->featured_image ?? $ad->advertable->image ?? $ad->advertable->profile_image ?? null,
                'slug' => $ad->advertable->slug ?? null,
            ],
            'expires_at' => $ad->expires_at->toISOString(),
        ];
    }
}
```

### app/Http/Controllers/AlphaSite/IndustryController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\AlphaSite;

use App\Http\Controllers\Controller;
use App\Models\Industry;
use App\Services\BusinessService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class IndustryController extends Controller
{
    public function __construct(
        private readonly BusinessService $businessService
    ) {}

    /**
     * List all industries
     */
    public function index(): Response
    {
        $industries = Industry::active()
            ->orderBy('display_order')
            ->orderBy('name')
            ->get();

        return Inertia::render('alphasite/industries/index', [
            'industries' => $industries,
        ]);
    }

    /**
     * Show industry page
     */
    public function show(string $slug, Request $request): Response
    {
        $industry = Industry::where('slug', $slug)->where('is_active', true)->firstOrFail();
        
        $businesses = $this->businessService->getByIndustry(
            $slug,
            $request->input('city'),
            $request->input('state'),
            24
        );

        return Inertia::render('alphasite/industries/show', [
            'industry' => $industry,
            'businesses' => $businesses,
            'filters' => $request->only(['city', 'state']),
        ]);
    }

    /**
     * Industry by location
     */
    public function byLocation(string $slug, string $city, string $state, Request $request): Response
    {
        $request->merge(['city' => $city, 'state' => $state]);
        return $this->show($slug, $request);
    }
}
```

### app/Http/Controllers/CheckInController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\CheckIn;
use App\Models\Event;
use App\Notifications\CheckInConfirmationNotification;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class CheckInController extends Controller
{
    public function index(Request $request): Response
    {
        $query = CheckIn::query()
            ->with(['event.venue', 'user'])
            ->latest('checked_in_at');

        if ($request->filled('event_id')) {
            $query->forEvent($request->input('event_id'));
        }

        if ($request->filled('user_id')) {
            $query->forUser($request->input('user_id'));
        }

        if ($request->boolean('public_only')) {
            $query->public();
        }

        $checkIns = $query->paginate(20);

        return Inertia::render('event-city/check-ins/index', [
            'checkIns' => $checkIns,
            'filters' => [
                'event_id' => $request->input('event_id'),
                'user_id' => $request->input('user_id'),
                'public_only' => $request->boolean('public_only'),
            ],
        ]);
    }

    public function store(Request $request): JsonResponse|RedirectResponse
    {
        $validated = $request->validate([
            'event_id' => 'required|uuid|exists:events,id',
            'location' => 'nullable|string|max:255',
            'latitude' => 'nullable|numeric',
            'longitude' => 'nullable|numeric',
            'notes' => 'nullable|string',
            'is_public' => 'boolean',
        ]);

        $event = Event::findOrFail($validated['event_id']);

        // Check if user already checked in
        $existingCheckIn = CheckIn::where('event_id', $event->id)
            ->where('user_id', $request->user()->id)
            ->first();

        if ($existingCheckIn) {
            if ($request->expectsJson()) {
                return response()->json([
                    'message' => 'You have already checked in to this event.',
                    'check_in' => $existingCheckIn,
                ], 409);
            }

            return redirect()->back()->withErrors(['check_in' => 'You have already checked in to this event.']);
        }

        $checkIn = CheckIn::create([
            ...$validated,
            'user_id' => $request->user()->id,
            'checked_in_at' => now(),
        ]);

        // Update event check-in count
        $event->increment('member_attendance');

        // Send check-in confirmation email
        $request->user()->notify(new CheckInConfirmationNotification($checkIn));

        if ($request->expectsJson()) {
            return response()->json([
                'message' => 'Checked in successfully.',
                'check_in' => $checkIn->load(['event', 'user']),
            ], 201);
        }

        return redirect()->back()->with('success', 'Checked in successfully.');
    }

    public function show(CheckIn $checkIn): Response
    {
        $checkIn->load(['event.venue', 'user']);

        return Inertia::render('event-city/check-ins/show', [
            'checkIn' => $checkIn,
        ]);
    }

    public function destroy(CheckIn $checkIn): RedirectResponse
    {
        $this->authorize('delete', $checkIn);

        $event = $checkIn->event;
        $checkIn->delete();

        // Update event check-in count
        if ($event) {
            $event->decrement('member_attendance');
        }

        return redirect()->back()->with('success', 'Check-in removed successfully.');
    }

    public function forEvent(Event $event): JsonResponse
    {
        $checkIns = CheckIn::forEvent($event->id)
            ->with('user')
            ->public()
            ->recent(24)
            ->latest('checked_in_at')
            ->get();

        return response()->json($checkIns);
    }
}
```

### app/Http/Controllers/TicketPageController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\Event;
use App\Models\TicketOrder;
use App\Models\TicketOrderItem;
use App\Services\PromoCodeService;
use App\Services\QRCodeService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class TicketPageController extends Controller
{
    public function index(Request $request): Response
    {
        $query = Event::published()
            ->upcoming()
            ->with(['venue', 'ticketPlans' => function ($query) {
                $query->active()->available();
            }]);

        // Apply search filter
        if ($request->filled('search')) {
            $searchTerm = $request->input('search');
            $query->where(function ($q) use ($searchTerm) {
                $q->where('title', 'ILIKE', "%{$searchTerm}%")
                    ->orWhere('description', 'ILIKE', "%{$searchTerm}%")
                    ->orWhereHas('venue', function ($venueQuery) use ($searchTerm) {
                        $venueQuery->where('name', 'ILIKE', "%{$searchTerm}%");
                    });
            });
        }

        // Apply price filter
        if ($request->filled('min_price')) {
            $query->where('price_min', '>=', $request->input('min_price'));
        }
        if ($request->filled('max_price')) {
            $query->where('price_max', '<=', $request->input('max_price'));
        }

        // Apply category filter
        if ($request->filled('categories')) {
            $categories = $request->input('categories');
            $query->whereIn('category', is_array($categories) ? $categories : [$categories]);
        }

        // Apply date filter
        if ($request->filled('date')) {
            $date = $request->input('date');
            $query->whereDate('event_date', $date);
        }

        // Apply free events filter
        if ($request->boolean('free_only')) {
            $query->where('is_free', true);
        }

        // Apply sorting
        $sortBy = $request->input('sort', 'date');
        match ($sortBy) {
            'price_low' => $query->orderBy('price_min', 'asc')->orderBy('event_date', 'asc'),
            'price_high' => $query->orderBy('price_max', 'desc')->orderBy('event_date', 'asc'),
            'popularity' => $query->orderBy('community_rating', 'desc')->orderBy('event_date', 'asc'),
            'recommended' => $query->orderBy('community_rating', 'desc')
                ->orderBy('member_recommendations', 'desc')
                ->orderBy('event_date', 'asc'),
            default => $query->orderBy('event_date', 'asc'),
        };

        $events = $query->paginate(12);

        // Get featured events for empty state (with badges)
        $featuredEvents = Event::published()
            ->upcoming()
            ->with(['venue'])
            ->orderBy('community_rating', 'desc')
            ->take(20)
            ->get()
            ->filter(function ($event) {
                return ! empty($event->badges) && count($event->badges) > 0;
            })
            ->take(6)
            ->values();

        return Inertia::render('event-city/tickets/index', [
            'events' => $events,
            'featuredEvents' => $featuredEvents,
            'filters' => [
                'search' => $request->input('search'),
                'min_price' => $request->input('min_price'),
                'max_price' => $request->input('max_price'),
                'categories' => $request->input('categories'),
                'date' => $request->input('date'),
                'free_only' => $request->boolean('free_only'),
            ],
            'sort' => $sortBy,
        ]);
    }

    public function selection(Event $event): Response
    {
        $event->load(['venue', 'ticketPlans' => function ($query) {
            $query->active()->available()->orderBySortOrder();
        }]);

        // If event has pricing but no ticket plans, auto-generate basic plans
        if ($event->ticketPlans->isEmpty() && ! $event->is_free && $event->price_min > 0) {
            $this->generateBasicTicketPlans($event);
            $event->load(['ticketPlans' => function ($query) {
                $query->active()->available()->orderBySortOrder();
            }]);
        }

        return Inertia::render('event-city/tickets/ticket-selection', [
            'event' => $event,
            'ticketPlans' => $event->ticketPlans,
        ]);
    }

    public function myTickets(Request $request): Response
    {
        $qrCodeService = app(QRCodeService::class);
        
        $orders = TicketOrder::forUser($request->user()->id)
            ->with(['event.venue', 'items.ticketPlan'])
            ->latest()
            ->get()
            ->map(function ($order) use ($qrCodeService) {
                $order->items->transform(function ($item) use ($qrCodeService) {
                    if ($item->qr_code) {
                        $item->qr_code_url = $qrCodeService->getQRCodeUrl($item->qr_code);
                    }
                    return $item;
                });
                return $order;
            });

        return Inertia::render('event-city/tickets/my-tickets', [
            'orders' => $orders,
        ]);
    }

    public function verifyTicket(Request $request, string $ticketCode): Response
    {
        $qrCodeService = app(QRCodeService::class);
        $ticketOrderItem = $qrCodeService->verifyTicketCode($ticketCode);

        if (!$ticketOrderItem) {
            return Inertia::render('event-city/tickets/verify', [
                'valid' => false,
                'message' => 'Invalid or expired ticket code.',
            ]);
        }

        return Inertia::render('event-city/tickets/verify', [
            'valid' => true,
            'ticket' => [
                'code' => $ticketOrderItem->ticket_code,
                'event' => [
                    'title' => $ticketOrderItem->ticketOrder->event->title,
                    'date' => $ticketOrderItem->ticketOrder->event->event_date,
                    'venue' => $ticketOrderItem->ticketOrder->event->venue?->name,
                ],
                'plan' => [
                    'name' => $ticketOrderItem->ticketPlan->name,
                    'quantity' => $ticketOrderItem->quantity,
                ],
                'order' => [
                    'id' => $ticketOrderItem->ticketOrder->id,
                    'purchased_at' => $ticketOrderItem->ticketOrder->created_at,
                ],
                'qr_code_url' => $ticketOrderItem->qr_code ? $qrCodeService->getQRCodeUrl($ticketOrderItem->qr_code) : null,
            ],
        ]);
    }

    private function generateBasicTicketPlans(Event $event): void
    {
        // Create General Admission ticket plan
        $event->ticketPlans()->create([
            'name' => 'General Admission',
            'description' => 'Standard entry to the event',
            'price' => $event->price_min,
            'max_quantity' => 200,
            'available_quantity' => 200,
            'is_active' => true,
            'sort_order' => 1,
        ]);

        // If there's a price range, create a VIP option
        if ($event->price_max > $event->price_min) {
            $event->ticketPlans()->create([
                'name' => 'VIP Package',
                'description' => 'Premium seating with exclusive access',
                'price' => $event->price_max,
                'max_quantity' => 50,
                'available_quantity' => 50,
                'is_active' => true,
                'sort_order' => 2,
            ]);
        }
    }
}
```

### app/Http/Controllers/OrganizationRelationshipController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\OrganizationRelationship;
use App\Models\Business;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\RedirectResponse;

final class OrganizationRelationshipController extends Controller
{
    /**
     * Create a new relationship
     */
    public function store(Request $request): JsonResponse|RedirectResponse
    {
        $request->validate([
            'organization_id' => 'required|uuid|exists:businesses,id',
            'relatable_type' => 'required|string',
            'relatable_id' => 'required|uuid',
            'relationship_type' => 'required|string|in:related,sponsored,featured,partner,host,organizer,venue,sponsor,author,source,subject',
            'is_primary' => 'boolean',
            'metadata' => 'array',
        ]);

        $organization = Business::findOrFail($request->input('organization_id'));
        $relatableClass = $request->input('relatable_type');
        $relatable = $relatableClass::findOrFail($request->input('relatable_id'));

        $relationship = $relatable->relateToOrganization(
            $organization,
            $request->input('relationship_type'),
            $request->boolean('is_primary', false),
            $request->input('metadata', [])
        );

        if ($request->wantsJson()) {
            return response()->json([
                'message' => 'Relationship created successfully',
                'relationship' => $relationship->load(['organization', 'relatable']),
            ], 201);
        }

        return redirect()->back()->with('success', 'Relationship created successfully');
    }

    /**
     * Update a relationship
     */
    public function update(Request $request, OrganizationRelationship $relationship): JsonResponse|RedirectResponse
    {
        $request->validate([
            'relationship_type' => 'sometimes|string|in:related,sponsored,featured,partner,host,organizer,venue,sponsor,author,source,subject',
            'is_primary' => 'boolean',
            'metadata' => 'array',
        ]);

        $relationship->update($request->only(['relationship_type', 'is_primary', 'metadata']));

        if ($request->wantsJson()) {
            return response()->json([
                'message' => 'Relationship updated successfully',
                'relationship' => $relationship->load(['organization', 'relatable']),
            ]);
        }

        return redirect()->back()->with('success', 'Relationship updated successfully');
    }

    /**
     * Delete a relationship
     */
    public function destroy(OrganizationRelationship $relationship): JsonResponse|RedirectResponse
    {
        $relationship->delete();

        if (request()->wantsJson()) {
            return response()->json([
                'message' => 'Relationship deleted successfully',
            ]);
        }

        return redirect()->back()->with('success', 'Relationship deleted successfully');
    }

    /**
     * Bulk create relationships
     */
    public function bulkStore(Request $request): JsonResponse|RedirectResponse
    {
        $request->validate([
            'organization_id' => 'required|uuid|exists:businesses,id',
            'relationships' => 'required|array',
            'relationships.*.relatable_type' => 'required|string',
            'relationships.*.relatable_id' => 'required|uuid',
            'relationships.*.relationship_type' => 'required|string|in:related,sponsored,featured,partner,host,organizer,venue,sponsor,author,source,subject',
            'relationships.*.is_primary' => 'boolean',
            'relationships.*.metadata' => 'array',
        ]);

        $organization = Business::findOrFail($request->input('organization_id'));
        $created = [];

        foreach ($request->input('relationships') as $relData) {
            $relatableClass = $relData['relatable_type'];
            $relatable = $relatableClass::findOrFail($relData['relatable_id']);

            $relationship = $relatable->relateToOrganization(
                $organization,
                $relData['relationship_type'],
                $relData['is_primary'] ?? false,
                $relData['metadata'] ?? []
            );

            $created[] = $relationship;
        }

        if ($request->wantsJson()) {
            return response()->json([
                'message' => 'Relationships created successfully',
                'relationships' => $created,
            ], 201);
        }

        return redirect()->back()->with('success', count($created).' relationships created successfully');
    }
}

```

### app/Http/Controllers/ProductController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Http\Requests\StoreProductRequest;
use App\Http\Requests\UpdateProductRequest;
use App\Models\Product;
use App\Models\Store;
use App\Services\StripeConnectService;
use Exception;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;
use Inertia\Inertia;
use Inertia\Response;
use Log;

final class ProductController extends Controller
{
    public function __construct(
        private StripeConnectService $stripeService
    ) {}

    /**
     * Show the ecommerce discovery page with recommended products
     */
    public function discover(Request $request): Response
    {
        // Get random featured products from approved stores
        $featuredProducts = Product::query()
            ->whereHas('store', function ($query) {
                $query->where('status', 'approved');
            })
            ->where('is_active', true)
            ->inRandomOrder()
            ->limit(8)
            ->with(['store'])
            ->get();

        // Get more recommended products
        $recommendedProducts = Product::query()
            ->whereHas('store', function ($query) {
                $query->where('status', 'approved');
            })
            ->where('is_active', true)
            ->inRandomOrder()
            ->limit(12)
            ->with(['store'])
            ->get();

        return Inertia::render('event-city/ecommerce/discover', [
            'featuredProducts' => $featuredProducts,
            'recommendedProducts' => $recommendedProducts,
        ]);
    }

    /**
     * Show the form for creating a new product
     */
    public function create(Request $request, Store $store): Response
    {
        if (! $request->user()->isMemberOfWorkspace($store->workspace_id)) {
            abort(403, 'Unauthorized');
        }

        return Inertia::render('event-city/products/create', [
            'store' => [
                'id' => $store->id,
                'name' => $store->name,
                'slug' => $store->slug,
                'workspace' => [
                    'can_accept_payments' => $store->workspace->canAcceptPayments(),
                ],
            ],
        ]);
    }

    /**
     * Store a newly created product
     */
    public function store(StoreProductRequest $request): RedirectResponse
    {
        $store = Store::findOrFail($request->store_id);

        if (! $request->user()->isMemberOfWorkspace($store->workspace_id)) {
            abort(403, 'Unauthorized');
        }

        $data = $request->validated();

        // Handle image uploads
        if ($request->hasFile('images')) {
            $images = [];
            foreach ($request->file('images') as $image) {
                $images[] = $image->store('products/images', 'public');
            }
            $data['images'] = $images;
        }

        $product = Product::create($data);

        // Create product in Stripe if workspace has Stripe Connect
        if ($store->workspace->stripe_connect_id) {
            try {
                $stripeProduct = $this->stripeService->createProduct(
                    $store->workspace,
                    $product->name,
                    $product->description
                );

                $stripePrice = $this->stripeService->createPrice(
                    $store->workspace,
                    $stripeProduct->id,
                    (int) ($product->price * 100) // Convert to cents
                );

                $product->update([
                    'stripe_product_id' => $stripeProduct->id,
                    'stripe_price_id' => $stripePrice->id,
                ]);
            } catch (Exception $e) {
                // Log error but don't fail product creation
                Log::error('Failed to create Stripe product: '.$e->getMessage());
            }
        }

        return redirect()->route('stores.show', $store->slug)
            ->with('success', 'Product created successfully!');
    }

    /**
     * Display the specified product
     */
    public function show(Request $request, Store $store, Product $product): Response
    {
        if ($product->store_id !== $store->id) {
            abort(404);
        }

        // Only show active products to non-owners
        if (! $product->is_active && ! $request->user()?->isMemberOfWorkspace($store->workspace_id)) {
            abort(403, 'Product is not available');
        }

        return Inertia::render('event-city/products/show', [
            'product' => [
                'id' => $product->id,
                'name' => $product->name,
                'slug' => $product->slug,
                'description' => $product->description,
                'price' => $product->price,
                'compare_at_price' => $product->compare_at_price,
                'images' => $product->images,
                'quantity' => $product->quantity,
                'is_in_stock' => $product->isInStock(),
                'discount_percentage' => $product->discount_percentage,
                'sku' => $product->sku,
            ],
            'store' => [
                'id' => $store->id,
                'name' => $store->name,
                'slug' => $store->slug,
                'logo' => $store->logo,
            ],
            'is_owner' => $request->user()?->isMemberOfWorkspace($store->workspace_id) ?? false,
        ]);
    }

    /**
     * Show the form for editing the specified product
     */
    public function edit(Request $request, Store $store, Product $product): Response
    {
        if (! $request->user()->isMemberOfWorkspace($store->workspace_id)) {
            abort(403, 'Unauthorized');
        }

        if ($product->store_id !== $store->id) {
            abort(404);
        }

        return Inertia::render('event-city/products/edit', [
            'product' => [
                'id' => $product->id,
                'name' => $product->name,
                'slug' => $product->slug,
                'description' => $product->description,
                'price' => $product->price,
                'compare_at_price' => $product->compare_at_price,
                'images' => $product->images,
                'quantity' => $product->quantity,
                'track_inventory' => $product->track_inventory,
                'sku' => $product->sku,
                'is_active' => $product->is_active,
                'is_featured' => $product->is_featured,
            ],
            'store' => [
                'id' => $store->id,
                'name' => $store->name,
                'slug' => $store->slug,
                'workspace' => [
                    'can_accept_payments' => $store->workspace->canAcceptPayments(),
                ],
            ],
        ]);
    }

    /**
     * Update the specified product
     */
    public function update(UpdateProductRequest $request, Store $store, Product $product): RedirectResponse
    {
        if (! $request->user()->isMemberOfWorkspace($store->workspace_id)) {
            abort(403, 'Unauthorized');
        }

        if ($product->store_id !== $store->id) {
            abort(404);
        }

        $data = $request->validated();

        // Handle image uploads
        if ($request->hasFile('images')) {
            // Delete old images
            if ($product->images) {
                foreach ($product->images as $image) {
                    Storage::disk('public')->delete($image);
                }
            }

            $images = [];
            foreach ($request->file('images') as $image) {
                $images[] = $image->store('products/images', 'public');
            }
            $data['images'] = $images;
        }

        $product->update($data);

        return redirect()->route('products.show', [$store->slug, $product->slug])
            ->with('success', 'Product updated successfully!');
    }

    /**
     * Remove the specified product
     */
    public function destroy(Request $request, Store $store, Product $product): RedirectResponse
    {
        if (! $request->user()->isMemberOfWorkspace($store->workspace_id)) {
            abort(403, 'Unauthorized');
        }

        if ($product->store_id !== $store->id) {
            abort(404);
        }

        // Delete images
        if ($product->images) {
            foreach ($product->images as $image) {
                Storage::disk('public')->delete($image);
            }
        }

        $product->delete();

        return redirect()->route('stores.show', $store->slug)
            ->with('success', 'Product deleted successfully!');
    }
}
```

### app/Http/Controllers/SocialMessageController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Http\Requests\SendMessageRequest;
use App\Models\Conversation;
use App\Models\ConversationParticipant;
use App\Models\Message;
use App\Models\User;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use Inertia\Inertia;
use Inertia\Response;

final class SocialMessageController extends Controller
{
    public function index(Request $request): Response
    {
        $user = Auth::user();

        // Get user's conversations with eager loading
        $conversations = $user->conversations()
            ->with([
                'participants' => function ($query) use ($user) {
                    $query->where('user_id', '!=', $user->id);
                },
                'latestMessage.sender',
            ])
            ->orderBy('last_message_at', 'desc')
            ->get()
            ->map(function ($conversation) use ($user) {
                $otherParticipants = $conversation->participants
                    ->where('id', '!=', $user->id)
                    ->map(function ($participant) {
                        return [
                            'id' => $participant->id,
                            'name' => $participant->name,
                            'avatar' => $participant->avatar,
                            'online' => false, // TODO: implement online status tracking
                        ];
                    });

                $lastMessage = $conversation->latestMessage;

                return [
                    'id' => $conversation->id,
                    'type' => $conversation->type,
                    'title' => $conversation->title,
                    'participants' => $otherParticipants->values(),
                    'last_message' => $lastMessage ? [
                        'text' => $lastMessage->content,
                        'timestamp' => $lastMessage->created_at->toISOString(),
                        'sender' => $lastMessage->sender_id,
                        'sender_name' => $lastMessage->sender->name,
                    ] : null,
                    'unread' => $conversation->getUnreadCountForUser($user->id),
                ];
            });

        $selectedConversationId = $request->route('conversation');
        $messages = [];

        if ($selectedConversationId) {
            $selectedConversation = $user->conversations()
                ->where('conversations.id', $selectedConversationId)
                ->first();

            if ($selectedConversation) {
                // Mark conversation as read
                $selectedConversation->markAsReadForUser($user->id);

                // Get messages for the conversation
                $messages = $selectedConversation->messages()
                    ->with('sender')
                    ->orderBy('created_at', 'asc')
                    ->get()
                    ->map(function ($message) {
                        return [
                            'id' => $message->id,
                            'text' => $message->content,
                            'timestamp' => $message->created_at->toISOString(),
                            'sender' => $message->sender_id,
                            'sender_name' => $message->sender->name,
                            'type' => $message->type,
                            'metadata' => $message->metadata,
                            'edited_at' => $message->edited_at?->toISOString(),
                        ];
                    });
            }
        }

        return Inertia::render('event-city/social/messages-index', [
            'conversations' => $conversations,
            'selected_conversation' => $selectedConversationId,
            'messages' => $messages,
            'current_user' => [
                'id' => $user->id,
                'name' => $user->name,
                'avatar' => $user->avatar,
            ],
        ]);
    }

    public function show(string $conversationId): Response
    {
        return $this->index(request()->merge(['conversation' => $conversationId]));
    }

    public function sendMessage(SendMessageRequest $request, string $conversationId): JsonResponse
    {
        $user = Auth::user();

        // Verify user is participant in conversation
        $conversation = $user->conversations()
            ->where('conversations.id', $conversationId)
            ->first();

        if (! $conversation) {
            return response()->json([
                'success' => false,
                'message' => 'Conversation not found or access denied',
            ], 404);
        }

        // Create the message
        $message = Message::create([
            'conversation_id' => $conversationId,
            'sender_id' => $user->id,
            'content' => $request->input('message'),
            'type' => $request->input('type', 'text'),
            'metadata' => $request->input('metadata'),
        ]);

        // Update conversation's last message timestamp
        $conversation->update([
            'last_message_at' => now(),
        ]);

        // Load sender for response
        $message->load('sender');

        return response()->json([
            'success' => true,
            'message' => [
                'id' => $message->id,
                'text' => $message->content,
                'timestamp' => $message->created_at->toISOString(),
                'sender' => $message->sender_id,
                'sender_name' => $message->sender->name,
                'type' => $message->type,
                'metadata' => $message->metadata,
            ],
        ]);
    }

    public function newMessage(): Response
    {
        $user = Auth::user();

        // Get friends to start new conversations with (those who don't have existing conversations)
        $existingConversationUserIds = $user->conversations()
            ->where('type', 'private')
            ->with('participants')
            ->get()
            ->flatMap(function ($conversation) use ($user) {
                return $conversation->participants->where('id', '!=', $user->id)->pluck('id');
            });

        $friends = User::whereHas('friendships', function ($query) use ($user) {
            $query->where(function ($q) use ($user) {
                $q->where('user_id', $user->id)->orWhere('friend_id', $user->id);
            })->where('status', 'accepted');
        })
            ->whereNotIn('id', $existingConversationUserIds)
            ->select(['id', 'name', 'email'])
            ->limit(20)
            ->get()
            ->map(function ($friend) {
                return [
                    'id' => $friend->id,
                    'name' => $friend->name,
                    'avatar' => $friend->avatar,
                    'online' => false, // TODO: implement online status tracking
                ];
            });

        return Inertia::render('event-city/social/messages-new', [
            'friends' => $friends,
        ]);
    }

    public function startConversation(Request $request): JsonResponse
    {
        $request->validate([
            'user_id' => ['required', 'uuid', 'exists:users,id'],
            'message' => ['required', 'string', 'max:1000'],
        ]);

        $user = Auth::user();
        $friendId = $request->input('user_id');

        // Check if users are friends
        if (! $user->isFriendsWith(User::find($friendId))) {
            return response()->json([
                'success' => false,
                'message' => 'You can only start conversations with friends',
            ], 403);
        }

        // Check if conversation already exists
        $existingConversation = Conversation::where('type', 'private')
            ->whereHas('participants', function ($query) use ($user) {
                $query->where('user_id', $user->id);
            })
            ->whereHas('participants', function ($query) use ($friendId) {
                $query->where('user_id', $friendId);
            })
            ->first();

        if ($existingConversation) {
            return response()->json([
                'success' => true,
                'conversation_id' => $existingConversation->id,
                'redirect_url' => route('social.messages.show', $existingConversation->id),
            ]);
        }

        // Create new conversation
        DB::transaction(function () use ($user, $friendId, $request, &$conversation) {
            $conversation = Conversation::create([
                'type' => 'private',
                'last_message_at' => now(),
            ]);

            // Add participants
            ConversationParticipant::create([
                'conversation_id' => $conversation->id,
                'user_id' => $user->id,
                'joined_at' => now(),
            ]);

            ConversationParticipant::create([
                'conversation_id' => $conversation->id,
                'user_id' => $friendId,
                'joined_at' => now(),
            ]);

            // Send first message
            Message::create([
                'conversation_id' => $conversation->id,
                'sender_id' => $user->id,
                'content' => $request->input('message'),
                'type' => 'text',
            ]);
        });

        return response()->json([
            'success' => true,
            'conversation_id' => $conversation->id,
            'redirect_url' => route('social.messages.show', $conversation->id),
        ]);
    }
}
```

### app/Http/Controllers/TicketMarketplaceController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\Event;
use App\Models\TicketListing;
use App\Models\TicketOrderItem;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Illuminate\Support\Facades\DB;
use Inertia\Inertia;
use Inertia\Response;

final class TicketMarketplaceController extends Controller
{
    public function index(Request $request): Response
    {
        $query = TicketListing::query()
            ->with(['ticketOrderItem.ticketPlan', 'event.venue', 'seller'])
            ->active();

        if ($request->filled('event_id')) {
            $query->forEvent($request->input('event_id'));
        }

        if ($request->filled('search')) {
            $query->whereHas('event', function ($q) use ($request) {
                $q->where('title', 'ILIKE', "%{$request->input('search')}%");
            });
        }

        if ($request->filled('min_price')) {
            $query->where('price', '>=', $request->input('min_price'));
        }

        if ($request->filled('max_price')) {
            $query->where('price', '<=', $request->input('max_price'));
        }

        $listings = $query->orderBy('price', 'asc')
            ->paginate(20);

        return Inertia::render('event-city/tickets/marketplace', [
            'listings' => $listings,
            'filters' => [
                'event_id' => $request->input('event_id'),
                'search' => $request->input('search'),
                'min_price' => $request->input('min_price'),
                'max_price' => $request->input('max_price'),
            ],
        ]);
    }

    public function create(Request $request): Response
    {
        $user = $request->user();
        $ticketOrders = $user->ticketOrders()
            ->with(['items.ticketPlan', 'event'])
            ->completed()
            ->latest()
            ->get();

        return Inertia::render('event-city/tickets/list-for-sale', [
            'ticketOrders' => $ticketOrders,
        ]);
    }

    public function store(Request $request): RedirectResponse
    {
        $validated = $request->validate([
            'ticket_order_item_id' => 'required|uuid|exists:ticket_order_items,id',
            'price' => 'required|numeric|min:0',
            'quantity' => 'required|integer|min:1',
            'description' => 'nullable|string',
            'expires_at' => 'nullable|date|after:now',
        ]);

        $ticketOrderItem = TicketOrderItem::with(['ticketOrder', 'ticketPlan'])->findOrFail($validated['ticket_order_item_id']);

        // Verify ownership
        if ($ticketOrderItem->ticketOrder->user_id !== $request->user()->id) {
            return redirect()->back()->withErrors(['ticket' => 'You do not own this ticket.']);
        }

        // Verify quantity available
        if ($validated['quantity'] > $ticketOrderItem->quantity) {
            return redirect()->back()->withErrors(['quantity' => 'You cannot list more tickets than you own.']);
        }

        // Check for existing active listing
        $existingListing = TicketListing::where('ticket_order_item_id', $ticketOrderItem->id)
            ->where('seller_id', $request->user()->id)
            ->where('status', TicketListing::STATUS_ACTIVE)
            ->first();

        if ($existingListing) {
            return redirect()->back()->withErrors(['listing' => 'You already have an active listing for this ticket.']);
        }

        $listing = TicketListing::create([
            ...$validated,
            'seller_id' => $request->user()->id,
            'event_id' => $ticketOrderItem->ticketOrder->event_id,
            'status' => TicketListing::STATUS_ACTIVE,
        ]);

        return redirect()->route('tickets.marketplace.show', $listing)
            ->with('success', 'Ticket listed for sale successfully.');
    }

    public function show(TicketListing $listing): Response
    {
        $listing->load(['ticketOrderItem.ticketPlan', 'event.venue', 'seller']);

        return Inertia::render('event-city/tickets/listing-show', [
            'listing' => $listing,
        ]);
    }

    public function purchase(Request $request, TicketListing $listing): RedirectResponse
    {
        $validated = $request->validate([
            'quantity' => 'required|integer|min:1|max:'.$listing->quantity,
        ]);

        if ($listing->status !== TicketListing::STATUS_ACTIVE) {
            return redirect()->back()->withErrors(['listing' => 'This listing is no longer available.']);
        }

        if ($listing->seller_id === $request->user()->id) {
            return redirect()->back()->withErrors(['listing' => 'You cannot purchase your own listing.']);
        }

        return DB::transaction(function () use ($listing, $validated, $request) {
            $totalPrice = $listing->price * $validated['quantity'];

            // Create new ticket order for buyer
            $buyerOrder = \App\Models\TicketOrder::create([
                'event_id' => $listing->event_id,
                'user_id' => $request->user()->id,
                'status' => 'completed',
                'subtotal' => $totalPrice,
                'fees' => 0,
                'discount' => 0,
                'total' => $totalPrice,
                'payment_status' => 'completed',
                'completed_at' => now(),
            ]);

            // Create ticket order item for buyer
            $buyerOrderItem = $buyerOrder->items()->create([
                'ticket_plan_id' => $listing->ticketOrderItem->ticket_plan_id,
                'quantity' => $validated['quantity'],
                'unit_price' => $listing->price,
                'total_price' => $totalPrice,
            ]);

            // Update listing
            if ($validated['quantity'] >= $listing->quantity) {
                $listing->markAsSold($request->user()->id);
            } else {
                $listing->decrement('quantity', $validated['quantity']);
            }

            return redirect()->route('tickets.my-tickets')
                ->with('success', 'Ticket purchased successfully.');
        });
    }

    public function destroy(TicketListing $listing): RedirectResponse
    {
        if ($listing->seller_id !== auth()->id()) {
            abort(403);
        }

        $listing->update(['status' => TicketListing::STATUS_CANCELLED]);

        return redirect()->route('tickets.marketplace.index')
            ->with('success', 'Listing cancelled successfully.');
    }
}
```

### app/Http/Controllers/HubAnalyticsController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\Hub;
use App\Models\HubAnalytics;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;
use Illuminate\Support\Facades\DB;

final class HubAnalyticsController extends Controller
{
    public function index(Hub $hub, Request $request): Response
    {
        $this->authorize('view', $hub);

        $dateRange = $request->input('date_range', '30');
        $startDate = now()->subDays((int) $dateRange)->startOfDay();
        $endDate = now()->endOfDay();

        $analytics = HubAnalytics::where('hub_id', $hub->id)
            ->forDateRange($startDate->toDateString(), $endDate->toDateString())
            ->orderBy('date', 'desc')
            ->get();

        // Calculate totals
        $totals = [
            'page_views' => $analytics->sum('page_views'),
            'unique_visitors' => $analytics->sum('unique_visitors'),
            'events_created' => $analytics->sum('events_created'),
            'events_published' => $analytics->sum('events_published'),
            'articles_created' => $analytics->sum('articles_created'),
            'articles_published' => $analytics->sum('articles_published'),
            'members_joined' => $analytics->sum('members_joined'),
            'followers_gained' => $analytics->sum('followers_gained'),
            'revenue' => $analytics->sum('revenue'),
        ];

        // Calculate averages
        $days = $analytics->count() ?: 1;
        $averages = [
            'page_views' => round($totals['page_views'] / $days, 2),
            'unique_visitors' => round($totals['unique_visitors'] / $days, 2),
            'engagement_score' => round($analytics->avg('engagement_score') ?? 0, 2),
        ];

        return Inertia::render('event-city/hubs/analytics', [
            'hub' => $hub,
            'analytics' => $analytics,
            'totals' => $totals,
            'averages' => $averages,
            'dateRange' => $dateRange,
        ]);
    }

    public function trackPageView(Hub $hub): JsonResponse
    {
        $today = now()->toDateString();

        HubAnalytics::updateOrCreate(
            [
                'hub_id' => $hub->id,
                'date' => $today,
            ],
            [
                'page_views' => DB::raw('page_views + 1'),
            ]
        );

        return response()->json(['success' => true]);
    }

    public function trackVisitor(Hub $hub, Request $request): JsonResponse
    {
        $today = now()->toDateString();

        $analytics = HubAnalytics::firstOrCreate(
            [
                'hub_id' => $hub->id,
                'date' => $today,
            ],
            [
                'page_views' => 0,
                'unique_visitors' => 0,
            ]
        );

        $analytics->increment('unique_visitors');

        return response()->json(['success' => true]);
    }

    public function getStats(Hub $hub, Request $request): JsonResponse
    {
        $this->authorize('view', $hub);

        $dateRange = $request->input('date_range', '30');
        $startDate = now()->subDays((int) $dateRange)->startOfDay();
        $endDate = now()->endOfDay();

        $analytics = HubAnalytics::where('hub_id', $hub->id)
            ->forDateRange($startDate->toDateString(), $endDate->toDateString())
            ->get();

        return response()->json([
            'totals' => [
                'page_views' => $analytics->sum('page_views'),
                'unique_visitors' => $analytics->sum('unique_visitors'),
                'events_created' => $analytics->sum('events_created'),
                'events_published' => $analytics->sum('events_published'),
                'articles_created' => $analytics->sum('articles_created'),
                'articles_published' => $analytics->sum('articles_published'),
                'members_joined' => $analytics->sum('members_joined'),
                'followers_gained' => $analytics->sum('followers_gained'),
                'revenue' => $analytics->sum('revenue'),
            ],
            'chart_data' => $analytics->map(function ($item) {
                return [
                    'date' => $item->date->format('Y-m-d'),
                    'page_views' => $item->page_views,
                    'unique_visitors' => $item->unique_visitors,
                    'engagement_score' => $item->engagement_score,
                ];
            }),
        ]);
    }
}
```

### app/Http/Controllers/Api/NotificationController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Models\NotificationSubscription;
use App\Services\NotificationService;
use App\Services\WebPushService;
use App\Services\PhoneVerificationService;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Validator;

final class NotificationController extends Controller
{
    public function __construct(
        private NotificationService $notificationService,
        private WebPushService $webPushService,
        private PhoneVerificationService $phoneService
    ) {}

    /**
     * Get VAPID public key for browser push registration
     */
    public function getVapidKey(): JsonResponse
    {
        return response()->json([
            'publicKey' => config('services.webpush.public_key'),
        ]);
    }

    /**
     * Register browser push subscription
     */
    public function registerWebPush(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'platform' => 'required|in:daynews,goeventcity,downtownguide,alphasite',
            'community_id' => 'required|string|max:100',
            'endpoint' => 'required|url',
            'keys.p256dh' => 'required|string',
            'keys.auth' => 'required|string',
            'notification_types' => 'array',
        ]);

        $subscription = NotificationSubscription::updateOrCreate(
            [
                'user_id' => $request->user()->id,
                'platform' => $validated['platform'],
                'community_id' => $validated['community_id'],
            ],
            [
                'web_push_endpoint' => $validated['endpoint'],
                'web_push_p256dh' => $validated['keys']['p256dh'],
                'web_push_auth' => $validated['keys']['auth'],
                'notification_types' => $validated['notification_types'] ?? ['breaking_news', 'events', 'deals'],
                'status' => 'active',
            ]
        );

        return response()->json([
            'success' => true,
            'subscription_id' => $subscription->id,
        ]);
    }

    /**
     * Request phone verification
     */
    public function requestPhoneVerification(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'phone_number' => 'required|string|regex:/^\+1[0-9]{10}$/',
            'platform' => 'required|in:daynews,goeventcity,downtownguide,alphasite',
        ]);

        try {
            $this->phoneService->sendVerificationCode(
                $validated['phone_number'],
                $validated['platform']
            );

            return response()->json([
                'success' => true,
                'message' => 'Verification code sent',
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => $e->getMessage(),
            ], 429);
        }
    }

    /**
     * Verify phone and subscribe to SMS
     */
    public function verifyPhoneAndSubscribe(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'phone_number' => 'required|string|regex:/^\+1[0-9]{10}$/',
            'code' => 'required|string|size:6',
            'platform' => 'required|in:daynews,goeventcity,downtownguide,alphasite',
            'community_id' => 'required|string|max:100',
            'notification_types' => 'array',
        ]);

        // Verify code
        if (!$this->phoneService->verifyCode($validated['phone_number'], $validated['code'])) {
            return response()->json([
                'success' => false,
                'message' => 'Invalid or expired verification code',
            ], 400);
        }

        // Subscribe to SNS topic
        $subscriptionArn = $this->notificationService->subscribePhoneToSMS(
            $validated['phone_number'],
            $validated['platform'],
            $validated['community_id']
        );

        if (!$subscriptionArn) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to subscribe to SMS notifications',
            ], 500);
        }

        // Save subscription
        $subscription = NotificationSubscription::updateOrCreate(
            [
                'user_id' => $request->user()->id,
                'platform' => $validated['platform'],
                'community_id' => $validated['community_id'],
            ],
            [
                'phone_number' => $validated['phone_number'],
                'phone_verified' => true,
                'phone_verified_at' => now(),
                'sns_sms_subscription_arn' => $subscriptionArn,
                'notification_types' => $validated['notification_types'] ?? ['breaking_news', 'events', 'deals'],
                'status' => 'active',
            ]
        );

        return response()->json([
            'success' => true,
            'subscription_id' => $subscription->id,
        ]);
    }

    /**
     * Update notification preferences
     */
    public function updatePreferences(Request $request, NotificationSubscription $subscription): JsonResponse
    {
        $this->authorize('update', $subscription);

        $validated = $request->validate([
            'notification_types' => 'array',
            'frequency' => 'in:instant,daily_digest,weekly_digest',
            'quiet_hours_start' => 'date_format:H:i',
            'quiet_hours_end' => 'date_format:H:i',
            'status' => 'in:active,paused',
        ]);

        $subscription->update($validated);

        return response()->json([
            'success' => true,
            'subscription' => $subscription->fresh(),
        ]);
    }

    /**
     * Unsubscribe
     */
    public function unsubscribe(Request $request, NotificationSubscription $subscription): JsonResponse
    {
        $this->authorize('delete', $subscription);

        // Unsubscribe from SNS if SMS was enabled
        if ($subscription->sns_sms_subscription_arn) {
            $this->notificationService->unsubscribe($subscription->sns_sms_subscription_arn);
        }

        $subscription->update(['status' => 'unsubscribed']);

        return response()->json([
            'success' => true,
            'message' => 'Successfully unsubscribed',
        ]);
    }

    /**
     * Get user's subscriptions
     */
    public function getSubscriptions(Request $request): JsonResponse
    {
        $subscriptions = NotificationSubscription::where('user_id', $request->user()->id)
            ->where('status', '!=', 'unsubscribed')
            ->get();

        return response()->json([
            'subscriptions' => $subscriptions,
        ]);
    }
}
```

### app/Http/Controllers/Api/LocationController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Models\Region;
use App\Services\LocationService;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Validator;

final class LocationController extends Controller
{
    public function __construct(
        private readonly LocationService $locationService
    ) {}

    /**
     * Detect location from browser geolocation coordinates
     */
    public function detectFromBrowser(Request $request): JsonResponse
    {
        $validator = Validator::make($request->all(), [
            'latitude' => ['required', 'numeric', 'between:-90,90'],
            'longitude' => ['required', 'numeric', 'between:-180,180'],
        ]);

        if ($validator->fails()) {
            return response()->json([
                'success' => false,
                'errors' => $validator->errors(),
            ], 422);
        }

        $latitude = (float) $request->input('latitude');
        $longitude = (float) $request->input('longitude');

        $region = $this->locationService->findNearestRegion($latitude, $longitude);

        if ($region === null) {
            return response()->json([
                'success' => false,
                'message' => 'No region found near your location',
            ], 404);
        }

        return response()->json([
            'success' => true,
            'region' => [
                'id' => $region->id,
                'name' => $region->name,
                'slug' => $region->slug,
                'type' => $region->type,
                'full_name' => $region->full_name,
                'latitude' => $region->latitude,
                'longitude' => $region->longitude,
            ],
        ]);
    }

    /**
     * Set user's region preference
     */
    public function setRegion(Request $request): JsonResponse
    {
        $validator = Validator::make($request->all(), [
            'region_id' => ['required', 'uuid', 'exists:regions,id'],
        ]);

        if ($validator->fails()) {
            return response()->json([
                'success' => false,
                'errors' => $validator->errors(),
            ], 422);
        }

        $regionId = $request->input('region_id');
        $region = Region::find($regionId);

        if ($region === null || ! $region->is_active) {
            return response()->json([
                'success' => false,
                'message' => 'Region not found or inactive',
            ], 404);
        }

        $this->locationService->setUserLocation($regionId);

        return response()->json([
            'success' => true,
            'message' => 'Location preference saved',
            'region' => [
                'id' => $region->id,
                'name' => $region->name,
                'slug' => $region->slug,
                'type' => $region->type,
                'full_name' => $region->full_name,
                'latitude' => $region->latitude,
                'longitude' => $region->longitude,
            ],
        ]);
    }

    /**
     * Search regions by name or zipcode
     */
    public function search(Request $request): JsonResponse
    {
        $validator = Validator::make($request->all(), [
            'query' => ['required', 'string', 'min:2', 'max:100', 'regex:/^[\p{L}\p{N}\s\-\',\.]+$/u'],
            'limit' => ['nullable', 'integer', 'min:1', 'max:20'],
        ]);

        if ($validator->fails()) {
            return response()->json([
                'success' => false,
                'errors' => $validator->errors(),
            ], 422);
        }

        $query = mb_trim($request->input('query'));
        $limit = min((int) $request->input('limit', 10), 20);

        $regions = $this->locationService->searchRegions($query, $limit);

        return response()->json([
            'success' => true,
            'regions' => $regions->map(fn ($region) => [
                'id' => $region->id,
                'name' => $region->name,
                'slug' => $region->slug,
                'type' => $region->type,
                'full_name' => $region->full_name,
                'latitude' => $region->latitude,
                'longitude' => $region->longitude,
            ]),
        ]);
    }

    /**
     * Clear user's location preference
     */
    public function clear(): JsonResponse
    {
        $this->locationService->clearUserLocation();

        return response()->json([
            'success' => true,
            'message' => 'Location preference cleared',
        ]);
    }
}
```

### app/Http/Controllers/Api/N8nIntegrationController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Models\Business;
use App\Models\DayNewsPost;
use App\Models\Region;
use App\Models\RssFeed;
use Exception;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Validator;
use Illuminate\Support\Str;

final class N8nIntegrationController extends Controller
{
    /**
     * Get all active regions
     */
    public function getRegions(Request $request): JsonResponse
    {
        $regions = Region::where('is_active', true)
            ->orderBy('name')
            ->get(['id', 'name', 'slug', 'type', 'parent_id', 'latitude', 'longitude']);

        return response()->json([
            'success' => true,
            'data' => $regions,
            'total' => $regions->count(),
        ]);
    }

    /**
     * Add or update a business (upsert by google_place_id)
     */
    public function upsertBusiness(Request $request): JsonResponse
    {
        $validator = Validator::make($request->all(), [
            'google_place_id' => ['required', 'string', 'max:255'],
            'name' => ['required', 'string', 'max:255'],
            'description' => ['nullable', 'string'],
            'website' => ['nullable', 'url', 'max:255'],
            'phone' => ['nullable', 'string', 'max:50'],
            'email' => ['nullable', 'email', 'max:255'],
            'address' => ['nullable', 'string', 'max:255'],
            'city' => ['nullable', 'string', 'max:100'],
            'state' => ['nullable', 'string', 'max:50'],
            'postal_code' => ['nullable', 'string', 'max:20'],
            'country' => ['nullable', 'string', 'max:100'],
            'latitude' => ['nullable', 'numeric', 'between:-90,90'],
            'longitude' => ['nullable', 'numeric', 'between:-180,180'],
            'categories' => ['nullable', 'array'],
            'rating' => ['nullable', 'numeric', 'between:0,5'],
            'reviews_count' => ['nullable', 'integer', 'min:0'],
            'opening_hours' => ['nullable', 'array'],
            'images' => ['nullable', 'array'],
            'serp_metadata' => ['nullable', 'array'],
            // SERP API: Multiple identifiers
            'data_id' => ['nullable', 'string', 'max:255'],
            'data_cid' => ['nullable', 'string', 'max:255'],
            'lsig' => ['nullable', 'string', 'max:255'],
            'provider_id' => ['nullable', 'string', 'max:255'],
            'local_services_cid' => ['nullable', 'string', 'max:255'],
            'local_services_bid' => ['nullable', 'string', 'max:255'],
            'local_services_pid' => ['nullable', 'string', 'max:255'],
            // SERP API: Source tracking
            'serp_source' => ['nullable', 'string', 'in:local,maps,local_services'],
            'serp_last_synced_at' => ['nullable', 'date'],
            // SERP API: Business type
            'primary_type' => ['nullable', 'string', 'max:255'],
            'type_id' => ['nullable', 'string', 'max:255'],
            'type_ids' => ['nullable', 'array'],
            // SERP API: Pricing and hours
            'price_level' => ['nullable', 'string', 'max:10'],
            'open_state' => ['nullable', 'string', 'max:50'],
            'hours_display' => ['nullable', 'string', 'max:255'],
            // SERP API: Local Services
            'google_badge' => ['nullable', 'string', 'max:100'],
            'service_area' => ['nullable', 'array'],
            'years_in_business' => ['nullable', 'integer', 'min:0'],
            'bookings_nearby' => ['nullable', 'integer', 'min:0'],
            // SERP API: Enhanced verification
            'verification_status' => ['nullable', 'string', 'in:unverified,claimed,verified,google_guaranteed'],
            'verified_at' => ['nullable', 'date'],
            'claimed_at' => ['nullable', 'date'],
            // SERP API: Service options and URLs
            'service_options' => ['nullable', 'array'],
            'reserve_url' => ['nullable', 'url', 'max:255'],
            'order_online_url' => ['nullable', 'url', 'max:255'],
            'region_ids' => ['nullable', 'array'],
            'region_ids.*' => ['uuid', 'exists:regions,id'],
        ]);

        if ($validator->fails()) {
            return response()->json([
                'success' => false,
                'errors' => $validator->errors(),
            ], 422);
        }

        try {
            DB::beginTransaction();

            $businessData = $request->only([
                'google_place_id',
                'name',
                'description',
                'website',
                'phone',
                'email',
                'address',
                'city',
                'state',
                'postal_code',
                'country',
                'latitude',
                'longitude',
                'categories',
                'rating',
                'reviews_count',
                'opening_hours',
                'images',
                'serp_metadata',
                // SERP API: Multiple identifiers
                'data_id',
                'data_cid',
                'lsig',
                'provider_id',
                'local_services_cid',
                'local_services_bid',
                'local_services_pid',
                // SERP API: Source tracking
                'serp_source',
                'serp_last_synced_at',
                // SERP API: Business type
                'primary_type',
                'type_id',
                'type_ids',
                // SERP API: Pricing and hours
                'price_level',
                'open_state',
                'hours_display',
                // SERP API: Local Services
                'google_badge',
                'service_area',
                'years_in_business',
                'bookings_nearby',
                // SERP API: Enhanced verification
                'verification_status',
                'verified_at',
                'claimed_at',
                // SERP API: Service options and URLs
                'service_options',
                'reserve_url',
                'order_online_url',
            ]);

            if (empty($businessData['slug'])) {
                $businessData['slug'] = Str::slug($businessData['name']);
            }

            $business = Business::updateOrCreate(
                ['google_place_id' => $businessData['google_place_id']],
                $businessData
            );

            if ($request->has('region_ids') && is_array($request->input('region_ids'))) {
                $business->regions()->sync($request->input('region_ids'));
            }

            DB::commit();

            return response()->json([
                'success' => true,
                'data' => $business->load('regions'),
                'message' => 'Business saved successfully',
            ], 200);
        } catch (Exception $e) {
            DB::rollBack();

            return response()->json([
                'success' => false,
                'message' => 'Failed to save business',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Get all feeds for a specific business
     */
    public function getBusinessFeeds(Request $request, string $businessId): JsonResponse
    {
        $business = Business::find($businessId);

        if ($business === null) {
            return response()->json([
                'success' => false,
                'message' => 'Business not found',
            ], 404);
        }

        $feeds = $business->rssFeeds()
            ->orderBy('created_at', 'desc')
            ->get();

        return response()->json([
            'success' => true,
            'data' => $feeds,
            'total' => $feeds->count(),
        ]);
    }

    /**
     * Add or update an RSS feed
     */
    public function upsertFeed(Request $request): JsonResponse
    {
        $validator = Validator::make($request->all(), [
            'business_id' => ['required', 'uuid', 'exists:businesses,id'],
            'url' => ['required', 'url', 'max:255'],
            'feed_type' => ['nullable', 'string', 'in:blog,news,events,articles,podcast,video,other'],
            'title' => ['nullable', 'string', 'max:255'],
            'description' => ['nullable', 'string'],
            'metadata' => ['nullable', 'array'],
        ]);

        if ($validator->fails()) {
            return response()->json([
                'success' => false,
                'errors' => $validator->errors(),
            ], 422);
        }

        try {
            $feedData = $request->only([
                'business_id',
                'url',
                'feed_type',
                'title',
                'description',
                'metadata',
            ]);

            $feed = RssFeed::updateOrCreate(
                [
                    'business_id' => $feedData['business_id'],
                    'url' => $feedData['url'],
                ],
                $feedData
            );

            return response()->json([
                'success' => true,
                'data' => $feed,
                'message' => 'Feed saved successfully',
            ], 200);
        } catch (Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to save feed',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Get all active and healthy feeds
     */
    public function getAllFeeds(Request $request): JsonResponse
    {
        $query = RssFeed::with('business')
            ->where('status', 'active');

        if ($request->has('health_status')) {
            $query->where('health_status', $request->input('health_status'));
        }

        if ($request->has('feed_type')) {
            $query->where('feed_type', $request->input('feed_type'));
        }

        $feeds = $query->orderBy('created_at', 'desc')->get();

        return response()->json([
            'success' => true,
            'data' => $feeds,
            'total' => $feeds->count(),
        ]);
    }

    /**
     * Update feed health status
     */
    public function updateFeedHealth(Request $request, string $feedId): JsonResponse
    {
        $validator = Validator::make($request->all(), [
            'health_status' => ['required', 'string', 'in:healthy,degraded,unhealthy'],
            'last_error' => ['nullable', 'string'],
            'status' => ['nullable', 'string', 'in:active,inactive,broken'],
        ]);

        if ($validator->fails()) {
            return response()->json([
                'success' => false,
                'errors' => $validator->errors(),
            ], 422);
        }

        $feed = RssFeed::find($feedId);

        if ($feed === null) {
            return response()->json([
                'success' => false,
                'message' => 'Feed not found',
            ], 404);
        }

        try {
            $updateData = [
                'health_status' => $request->input('health_status'),
                'last_checked_at' => now(),
            ];

            if ($request->has('last_error')) {
                $updateData['last_error'] = $request->input('last_error');
            }

            if ($request->input('health_status') === 'healthy') {
                $updateData['last_successful_fetch_at'] = now();
                $updateData['last_error'] = null;
            }

            if ($request->has('status')) {
                $updateData['status'] = $request->input('status');
            }

            $feed->update($updateData);

            return response()->json([
                'success' => true,
                'data' => $feed,
                'message' => 'Feed health updated successfully',
            ]);
        } catch (Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to update feed health',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Publish a generated article
     */
    public function publishArticle(Request $request): JsonResponse
    {
        $validator = Validator::make($request->all(), [
            'workspace_id' => ['required', 'uuid', 'exists:workspaces,id'],
            'author_id' => ['required', 'uuid', 'exists:users,id'],
            'rss_feed_id' => ['nullable', 'uuid', 'exists:rss_feeds,id'],
            'rss_feed_item_id' => ['nullable', 'uuid', 'exists:rss_feed_items,id'],
            'source_type' => ['nullable', 'string', 'max:50'],
            'title' => ['required', 'string', 'max:255'],
            'content' => ['required', 'string'],
            'excerpt' => ['nullable', 'string'],
            'featured_image' => ['nullable', 'url'],
            'category' => ['nullable', 'string', 'max:100'],
            'type' => ['nullable', 'string', 'max:100'],
            'metadata' => ['nullable', 'array'],
            'region_ids' => ['nullable', 'array'],
            'region_ids.*' => ['uuid', 'exists:regions,id'],
            'status' => ['nullable', 'string', 'in:draft,published'],
            'published_at' => ['nullable', 'date'],
        ]);

        if ($validator->fails()) {
            return response()->json([
                'success' => false,
                'errors' => $validator->errors(),
            ], 422);
        }

        try {
            DB::beginTransaction();

            $postData = $request->only([
                'workspace_id',
                'author_id',
                'rss_feed_id',
                'rss_feed_item_id',
                'source_type',
                'title',
                'content',
                'excerpt',
                'featured_image',
                'category',
                'type',
                'metadata',
                'status',
            ]);

            $postData['slug'] = Str::slug($postData['title']);
            $postData['status'] = $postData['status'] ?? 'draft';
            $postData['type'] = $postData['type'] ?? 'article';

            if ($request->has('published_at')) {
                $postData['published_at'] = $request->input('published_at');
            } elseif ($postData['status'] === 'published') {
                $postData['published_at'] = now();
            }

            $post = DayNewsPost::create($postData);

            if ($request->has('region_ids') && is_array($request->input('region_ids'))) {
                $post->regions()->sync($request->input('region_ids'));
            }

            if ($request->filled('rss_feed_item_id')) {
                $feedItem = \App\Models\RssFeedItem::find($request->input('rss_feed_item_id'));
                if ($feedItem !== null) {
                    $feedItem->markAsProcessed();
                }
            }

            DB::commit();

            return response()->json([
                'success' => true,
                'data' => $post->load('regions', 'rssFeed', 'rssFeedItem'),
                'message' => 'Article published successfully',
            ], 201);
        } catch (Exception $e) {
            DB::rollBack();

            return response()->json([
                'success' => false,
                'message' => 'Failed to publish article',
                'error' => $e->getMessage(),
            ], 500);
        }
    }

    /**
     * Update article status (draft to published or vice versa)
     */
    public function updateArticleStatus(Request $request, int $articleId): JsonResponse
    {
        $validator = Validator::make($request->all(), [
            'status' => ['required', 'string', 'in:draft,published'],
            'published_at' => ['nullable', 'date'],
        ]);

        if ($validator->fails()) {
            return response()->json([
                'success' => false,
                'errors' => $validator->errors(),
            ], 422);
        }

        $article = DayNewsPost::find($articleId);

        if ($article === null) {
            return response()->json([
                'success' => false,
                'message' => 'Article not found',
            ], 404);
        }

        try {
            $updateData = [
                'status' => $request->input('status'),
            ];

            if ($request->input('status') === 'published') {
                // If publishing, set published_at if not provided
                $updateData['published_at'] = $request->input('published_at', now());
            } elseif ($request->input('status') === 'draft') {
                // If moving back to draft, clear published_at
                $updateData['published_at'] = null;
            }

            $article->update($updateData);

            return response()->json([
                'success' => true,
                'data' => $article->load('regions', 'rssFeed', 'rssFeedItem'),
                'message' => 'Article status updated successfully',
            ]);
        } catch (Exception $e) {
            return response()->json([
                'success' => false,
                'message' => 'Failed to update article status',
                'error' => $e->getMessage(),
            ], 500);
        }
    }
}
```

### app/Http/Controllers/Api/AdvertisementController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Api;

use App\Http\Controllers\Controller;
use App\Models\Advertisement;
use App\Models\Region;
use App\Services\AdvertisementService;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;

final class AdvertisementController extends Controller
{
    public function __construct(
        private readonly AdvertisementService $adService
    ) {}

    public function index(Request $request): JsonResponse
    {
        $platform = $request->query('platform', 'day_news');
        $placement = $request->query('placement', 'sidebar');
        $regionId = $request->query('region_id');

        $region = $regionId ? Region::find($regionId) : null;

        $ads = $this->adService->getActiveAds($platform, $region, $placement);

        return response()->json([
            'ads' => $ads->map(fn ($ad) => [
                'id' => $ad->id,
                'placement' => $ad->placement,
                'advertable_type' => $ad->advertable_type,
                'advertable' => [
                    'id' => $ad->advertable->id,
                    'title' => $ad->advertable->title,
                    'excerpt' => $ad->advertable->excerpt,
                    'featured_image' => $ad->advertable->featured_image,
                    'slug' => $ad->advertable->slug,
                ],
                'expires_at' => $ad->expires_at->toISOString(),
            ]),
        ]);
    }

    public function trackImpression(Request $request, Advertisement $ad): JsonResponse
    {
        $this->adService->trackImpression($ad);

        return response()->json(['success' => true]);
    }

    public function trackClick(Request $request, Advertisement $ad): JsonResponse
    {
        $this->adService->trackClick($ad);

        return response()->json(['success' => true]);
    }
}
```

### app/Http/Controllers/TicketPlanController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\Event;
use App\Models\TicketPlan;
use App\Rules\FreeIfWorkspaceNotApproved;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;

final class TicketPlanController extends Controller
{
    public function index(Request $request): JsonResponse
    {
        $eventId = $request->query('event_id');

        if (! $eventId) {
            return response()->json(['error' => 'Event ID is required'], 400);
        }

        $ticketPlans = TicketPlan::forEvent($eventId)
            ->active()
            ->orderBySortOrder()
            ->get();

        return response()->json($ticketPlans);
    }

    public function store(Request $request): JsonResponse
    {
        $event = Event::with('workspace')->find($request->event_id);

        $rules = [
            'event_id' => 'required|uuid|exists:events,id',
            'name' => 'required|string|max:255',
            'description' => 'nullable|string',
            'price' => 'required|numeric|min:0',
            'max_quantity' => 'required|integer|min:1',
            'available_quantity' => 'required|integer|min:0',
            'is_active' => 'boolean',
            'metadata' => 'nullable|array',
            'sort_order' => 'integer|min:0',
        ];

        // Add workspace approval check for pricing
        if ($event && $event->workspace) {
            $rules['price'] = ['required', 'numeric', 'min:0', new FreeIfWorkspaceNotApproved($event->workspace)];
        }

        $validated = $request->validate($rules);

        $ticketPlan = TicketPlan::create($validated);

        return response()->json($ticketPlan, 201);
    }

    public function show(TicketPlan $ticketPlan): JsonResponse
    {
        return response()->json($ticketPlan->load('event'));
    }

    public function update(Request $request, TicketPlan $ticketPlan): JsonResponse
    {
        $rules = [
            'name' => 'string|max:255',
            'description' => 'nullable|string',
            'price' => 'numeric|min:0',
            'max_quantity' => 'integer|min:1',
            'available_quantity' => 'integer|min:0',
            'is_active' => 'boolean',
            'metadata' => 'nullable|array',
            'sort_order' => 'integer|min:0',
        ];

        // Add workspace approval check for pricing if price is being updated
        if ($request->has('price') && $ticketPlan->event && $ticketPlan->event->workspace) {
            $rules['price'] = ['numeric', 'min:0', new FreeIfWorkspaceNotApproved($ticketPlan->event->workspace)];
        }

        $validated = $request->validate($rules);

        $ticketPlan->update($validated);

        return response()->json($ticketPlan);
    }

    public function destroy(TicketPlan $ticketPlan): JsonResponse
    {
        $ticketPlan->delete();

        return response()->json(['message' => 'Ticket plan deleted successfully']);
    }

    public function forEvent(Event $event): JsonResponse
    {
        $ticketPlans = $event->ticketPlans()
            ->active()
            ->available()
            ->orderBySortOrder()
            ->get();

        return response()->json($ticketPlans);
    }
}
```

### app/Http/Controllers/CommunityController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Http\Requests\StoreCommunityThreadReplyRequest;
use App\Models\Community;
use App\Models\CommunityThread;
use App\Models\CommunityThreadReply;
use App\Models\CommunityThreadReplyLike;
use App\Models\CommunityThreadView;
use App\Models\Event;
use App\Models\Performer;
use App\Models\User;
use App\Models\Venue;
use Carbon\Carbon;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Inertia\Inertia; // Added missing import for User model
use Inertia\Response;

// Added missing import for Carbon

final class CommunityController extends Controller
{
    /**
     * Display the community index page
     */
    public function index(Request $request): Response
    {
        $communitiesQuery = Community::active()
            ->with(['threads' => fn ($q) => $q->latest()->limit(5)]);

        $communities = $communitiesQuery->withCount(['activeMembers', 'threads'])->get()->map(function ($community) {
            return [
                'id' => $community->id,
                'slug' => $community->slug,
                'name' => $community->name,
                'description' => $community->description,
                'image' => $community->image,
                'memberCount' => $community->active_members_count,
                'threadCount' => $community->threads_count,
                'categories' => $community->categories ?? [],
                'threadTypes' => $community->thread_types ?? [
                    'Discussion',
                    'Question',
                    'Announcement',
                    'Resource',
                    'Event',
                ],
                'popularTags' => $community->popular_tags ?? [],
            ];
        });
        // Get showcase data from featured communities or recent events
        $showcaseData = $this->getShowcaseData();

        return Inertia::render('event-city/community/index', [
            'communities' => $communities,
            'showcaseData' => $showcaseData,
        ]);
    }

    /**
     * Show a specific community page
     */
    public function show(Request $request, string $id): Response
    {
        $community = Community::where('id', $id)
            ->active()
            ->withCount(['activeMembers', 'threads'])
            ->firstOrFail();

        // Build the threads query
        $query = CommunityThread::where('community_id', $community->id)
            ->with(['author', 'community'])
            ->withCount(['replies', 'views']);

        // Apply filters
        if ($request->filled('type')) {
            $query->where('type', $request->type);
        }

        if ($request->filled('tag')) {
            $query->whereJsonContains('tags', $request->tag);
        }

        if ($request->filled('author')) {
            $query->whereHas('author', function ($q) use ($request) {
                $q->where('name', $request->author);
            });
        }

        if ($request->filled('search')) {
            $search = $request->search;
            $query->where(function ($q) use ($search) {
                $q->where('title', 'like', "%{$search}%")
                    ->orWhere('content', 'like', "%{$search}%")
                    ->orWhere('preview', 'like', "%{$search}%");
            });
        }

        // Apply date range filter
        if ($request->filled('date_range')) {
            $dateRange = $request->date_range;
            $cutoffDate = match ($dateRange) {
                'today' => now()->subDay(),
                'week' => now()->subWeek(),
                'month' => now()->subMonth(),
                'year' => now()->subYear(),
                default => null,
            };

            if ($cutoffDate) {
                $query->where('created_at', '>=', $cutoffDate);
            }
        }

        // Apply sorting
        $sortBy = $request->get('sort_by', 'recent');
        match ($sortBy) {
            'popular' => $query->orderBy('views', 'desc'),
            'unanswered' => $query->having('replies_count', 0)->orderBy('created_at', 'desc'),
            default => $query->orderBy('is_pinned', 'desc')->orderBy('created_at', 'desc'),
        };

        $threads = $query->paginate(20)->withQueryString();

        // Transform threads data
        $threadsData = $threads->through(function ($thread) {
            return [
                'id' => $thread->id,
                'title' => $thread->title,
                'preview' => $thread->preview ?? mb_substr(strip_tags($thread->content), 0, 200).'...',
                'type' => $thread->type,
                'tags' => $thread->tags ?? [],
                'views' => $thread->views,
                'replyCount' => $thread->replies_count,
                'viewsCount' => $thread->views_count,
                'isPinned' => $thread->is_pinned,
                'isLocked' => $thread->is_locked,
                'createdAt' => $thread->created_at->toISOString(),
                'author' => [
                    'id' => $thread->author->id,
                    'name' => $thread->author->name,
                    'avatar' => $thread->author->avatar,
                    'role' => 'Community Member', // Could be enhanced with user roles
                ],
            ];
        });

        return Inertia::render('event-city/community/show', [
            'community' => [
                'id' => $community->id,
                'name' => $community->name,
                'description' => $community->description,
                'image' => $community->image,
                'memberCount' => $community->active_members_count,
                'categories' => $community->categories ?? [],
                'threadTypes' => $community->thread_types ?? [
                    'Discussion',
                    'Question',
                    'Announcement',
                    'Resource',
                    'Event',
                ],
                'popularTags' => $community->popular_tags ?? [],
            ],
            'threads' => $threadsData,
            'filters' => $request->only(['type', 'tag', 'author', 'search', 'date_range']),
            'sort' => ['sort_by' => $sortBy],
        ]);
    }

    /**
     * Create a new community thread
     */
    public function createThread(Request $request, string $id): Response
    {
        $this->authorize('create', CommunityThread::class);

        $community = Community::where('id', $id)->active()->firstOrFail();

        return Inertia::render('event-city/community/create-thread', [
            'community' => [
                'id' => $community->id,
                'name' => $community->name,
                'threadTypes' => $community->thread_types ?? [
                    'Discussion',
                    'Question',
                    'Announcement',
                    'Resource',
                    'Event',
                ],
                'popularTags' => $community->popular_tags ?? [],
            ],
        ]);
    }

    /**
     * Store a new community thread
     */
    public function storeThread(Request $request, string $id)
    {
        $this->authorize('create', CommunityThread::class);

        $community = Community::where('id', $id)->active()->firstOrFail();

        $validated = $request->validate([
            'title' => 'required|string|max:255',
            'content' => 'required|string',
            'type' => 'required|string|in:Discussion,Question,Announcement,Resource,Event',
            'tags' => 'array|max:10',
            'tags.*' => 'string|max:50',
        ]);

        $thread = CommunityThread::create([
            ...$validated,
            'preview' => mb_substr(strip_tags($validated['content']), 0, 200).'...',
            'community_id' => $community->id,
            'author_id' => $request->user()->id,
        ]);

        return redirect()->route('community.show', $community->id)
            ->with('success', 'Thread created successfully!');
    }

    /**
     * Show a specific thread
     */
    public function showThread(Request $request, string $id, string $threadId): Response
    {
        $community = Community::where('id', $id)->active()->firstOrFail();
        $thread = CommunityThread::where('id', $threadId)
            ->where('community_id', $community->id)
            ->with(['author', 'community'])
            ->withCount(['views', 'replies'])
            ->firstOrFail();

        // Record a view for the thread
        $this->recordThreadView($thread, $request);

        // Get replies with nested structure (parent replies with their children)
        $replies = $thread->replies()
            ->with(['author', 'replies.author'])
            ->withCount('likes') // Eager load likes count for replies
            ->whereNull('reply_to_id') // Only get top-level replies
            ->orderBy('created_at', 'asc')
            ->get();

        // Transform replies to frontend format
        $repliesData = $replies->map(function ($reply) use ($request) {
            return $this->transformReplyToFrontend($reply, $request->user());
        });

        return Inertia::render('event-city/community/thread', [
            'community' => [
                'id' => $community->id,
                'name' => $community->name,
            ],
            'thread' => [
                'id' => $thread->id,
                'title' => $thread->title,
                'content' => $thread->content,
                'type' => $thread->type,
                'tags' => $thread->tags ?? [],
                'viewsCount' => $thread->views_count,
                'replyCount' => $thread->replies_count,
                'isPinned' => $thread->is_pinned,
                'isLocked' => $thread->is_locked,
                'createdAt' => $thread->created_at->toISOString(),
                'author' => [
                    'id' => $thread->author->id,
                    'name' => $thread->author->name,
                    'avatar' => $thread->author->avatar,
                    'role' => 'Community Member',
                ],
            ],
            'replies' => $repliesData,
        ]);
    }

    /**
     * Store a new reply to a thread
     */
    public function storeReply(StoreCommunityThreadReplyRequest $request, string $threadId): RedirectResponse
    {
        $thread = CommunityThread::with('community')->findOrFail($threadId);

        // Check if thread is locked
        if ($thread->is_locked) {
            return back()->with('error', 'This thread is locked and cannot accept new replies.');
        }

        CommunityThreadReply::create([
            'thread_id' => $thread->id,
            'user_id' => auth()->id(),
            'content' => $request->validated()['content'],
            'reply_to_id' => $request->validated()['reply_to_id'] ?? null,
        ]);

        return back()->with('success', 'Reply posted successfully!');
    }

    /**
     * Update an existing reply
     */
    public function updateReply(StoreCommunityThreadReplyRequest $request, string $replyId): RedirectResponse
    {
        $reply = CommunityThreadReply::where('id', $replyId)
            ->where('user_id', auth()->id())
            ->firstOrFail();

        $reply->update([
            'content' => $request->validated()['content'],
            'is_edited' => true,
            'edited_at' => now(),
        ]);

        return back()->with('success', 'Reply updated successfully!');
    }

    /**
     * Delete a reply
     */
    public function destroyReply(string $replyId): RedirectResponse
    {
        $reply = CommunityThreadReply::where('id', $replyId)
            ->where('user_id', auth()->id())
            ->firstOrFail();

        $reply->delete();

        return back()->with('success', 'Reply deleted successfully!');
    }

    /**
     * Like/unlike a reply
     */
    public function likeReply(string $replyId): RedirectResponse
    {
        $reply = CommunityThreadReply::findOrFail($replyId);
        $user = auth()->user();

        if (! $user) {
            return back()->with('error', 'You must be logged in to like a reply.');
        }

        // Toggle like: if user already liked, unlike; otherwise, like
        $like = CommunityThreadReplyLike::where('reply_id', $reply->id)
            ->where('user_id', $user->id)
            ->first();

        if ($like) {
            $like->delete();
            $message = 'Reply unliked!';
        } else {
            CommunityThreadReplyLike::create([
                'reply_id' => $reply->id,
                'user_id' => $user->id,
            ]);
            $message = 'Reply liked!';
        }

        return back()->with('success', $message);
    }

    /**
     * Get showcase data for the community index page
     */
    private function getShowcaseData(): array
    {
        // Get recent events with images for showcase
        $events = Event::published()
            ->upcoming()
            ->whereNotNull('image')
            ->with(['venue', 'performer'])
            ->take(3)
            ->get();

        // Get overall stats for the showcase
        $totalEvents = Event::published()->upcoming()->count();
        $totalVenues = Venue::count();
        $totalPerformers = Performer::count();

        $showcaseItems = [];

        foreach ($events as $index => $event) {
            $showcaseItems[] = [
                'id' => $index + 1,
                'image' => $event->image,
                'title' => $event->title,
                'eventUrl' => "/events/{$event->id}",
                'stats' => [
                    'events' => $totalEvents,
                    'venues' => $totalVenues,
                    'performers' => $totalPerformers,
                ],
            ];
        }

        // If no events, provide default showcase
        if (empty($showcaseItems)) {
            $showcaseItems = [
                [
                    'id' => 1,
                    'image' => 'https://images.unsplash.com/photo-1523580494863-6f3031224c94?ixlib=rb-1.2.1&auto=format&fit=crop&w=1350&q=80',
                    'title' => 'Community Events',
                    'eventUrl' => '/events',
                    'stats' => [
                        'events' => $totalEvents,
                        'venues' => $totalVenues,
                        'performers' => $totalPerformers,
                    ],
                ],
            ];
        }

        return $showcaseItems;
    }

    /**
     * Transform a reply model to frontend format
     */
    private function transformReplyToFrontend(CommunityThreadReply $reply, ?User $user = null): array
    {
        return [
            'id' => $reply->id,
            'content' => $reply->content,
            'images' => $reply->images ?? [],
            'likesCount' => $reply->likes_count, // Use the computed attribute
            'isLiked' => $user ? $reply->likes()->where('user_id', $user->id)->exists() : false,
            'isSolution' => $reply->is_solution,
            'isPinned' => $reply->is_pinned,
            'isEdited' => $reply->is_edited,
            'editedAt' => $reply->edited_at?->toISOString(),
            'createdAt' => $reply->created_at->toISOString(),
            'author' => [
                'id' => $reply->author->id,
                'name' => $reply->author->name,
                'avatar' => $reply->author->avatar ?? 'https://api.dicebear.com/9.x/glass/svg?seed='.$reply->author->id,
                'role' => 'Community Member',
            ],
            'replyToId' => $reply->reply_to_id,
            'replies' => $reply->replies->map(function ($childReply) use ($user) {
                return $this->transformReplyToFrontend($childReply, $user);
            })->toArray(),
        ];
    }

    /**
     * Record a view for a given thread.
     */
    private function recordThreadView(CommunityThread $thread, Request $request): void
    {
        $userId = $request->user()?->id;
        $sessionId = session()->getId();

        // Check if a view already exists for this user/session within a reasonable timeframe (e.g., last hour)
        $existingView = CommunityThreadView::where('thread_id', $thread->id)
            ->when($userId, fn ($query) => $query->where('user_id', $userId))
            ->when(! $userId, fn ($query) => $query->where('session_id', $sessionId))
            ->where('created_at', '>=', Carbon::now()->subHour())
            ->first();

        if (! $existingView) {
            CommunityThreadView::create([
                'thread_id' => $thread->id,
                'user_id' => $userId,
                'session_id' => $sessionId,
                'viewed_at' => Carbon::now(),
            ]);
        }
    }
}
```

### app/Http/Controllers/EngagementController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Services\UserEngagementTrackingService;
use Exception;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Illuminate\Validation\Rule;

final class EngagementController extends Controller
{
    public function __construct(
        private readonly UserEngagementTrackingService $engagementService
    ) {}

    public function track(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'engagements' => 'required|array|max:100',
            'engagements.*.user_id' => 'required|uuid|exists:users,id',
            'engagements.*.type' => [
                'required',
                'string',
                Rule::in([
                    'post_view',
                    'post_like',
                    'post_comment',
                    'post_share',
                    'profile_view',
                    'scroll_depth',
                    'time_spent',
                    // Day News article engagement types
                    'article_view',
                    'article_like',
                    'article_comment',
                    'article_share',
                    'article_read_time',
                    'article_scroll_depth',
                ]),
            ],
            'engagements.*.data' => 'sometimes|array',
        ]);

        try {
            $engagements = collect($validated['engagements'])->map(function ($engagement) {
                return [
                    'user_id' => $engagement['user_id'],
                    'type' => $engagement['type'],
                    'data' => json_encode($engagement['data'] ?? []),
                    'created_at' => now(),
                    'updated_at' => now(),
                ];
            })->toArray();

            $this->engagementService->recordBulkEngagement($engagements);

            return response()->json([
                'success' => true,
                'tracked' => count($engagements),
            ]);

        } catch (Exception $e) {
            Log::error('Failed to track engagement batch', [
                'error' => $e->getMessage(),
                'user_id' => $request->user()->id,
                'engagement_count' => count($validated['engagements']),
            ]);

            return response()->json([
                'success' => false,
                'error' => 'Failed to track engagement data',
            ], 500);
        }
    }

    public function sessionStart(Request $request): JsonResponse
    {
        try {
            $this->engagementService->trackSessionStart($request->user());

            return response()->json(['success' => true]);
        } catch (Exception $e) {
            Log::error('Failed to track session start', [
                'error' => $e->getMessage(),
                'user_id' => $request->user()->id,
            ]);

            return response()->json([
                'success' => false,
                'error' => 'Failed to track session start',
            ], 500);
        }
    }

    public function sessionEnd(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'session_duration' => 'sometimes|integer|min:0|max:86400', // Max 24 hours
        ]);

        try {
            $this->engagementService->trackSessionEnd($request->user());

            return response()->json(['success' => true]);
        } catch (Exception $e) {
            Log::error('Failed to track session end', [
                'error' => $e->getMessage(),
                'user_id' => $request->user()->id,
                'session_duration' => $validated['session_duration'] ?? null,
            ]);

            return response()->json([
                'success' => false,
                'error' => 'Failed to track session end',
            ], 500);
        }
    }
}
```

### app/Http/Controllers/CartController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\Cart;
use App\Models\CartItem;
use App\Models\Product;
use Exception;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Inertia\Inertia;
use Inertia\Response;

final class CartController extends Controller
{
    /**
     * Display the cart
     */
    public function index(Request $request): Response
    {
        $cart = $this->getOrCreateCart($request);
        $cart->load(['items.product.store', 'items.store']);

        return Inertia::render('event-city/cart/index', [
            'cart' => [
                'id' => $cart->id,
                'items' => $cart->items->map(fn ($item) => [
                    'id' => $item->id,
                    'quantity' => $item->quantity,
                    'price' => (float) $item->price,
                    'total' => (float) $item->total,
                    'product' => [
                        'id' => $item->product->id,
                        'name' => $item->product->name,
                        'slug' => $item->product->slug,
                        'images' => $item->product->images,
                        'is_in_stock' => $item->product->isInStock(),
                    ],
                    'store' => [
                        'id' => $item->store->id,
                        'name' => $item->store->name,
                        'slug' => $item->store->slug,
                    ],
                ]),
                'items_count' => $cart->items_count,
                'total' => (float) $cart->total,
            ],
        ]);
    }

    /**
     * Add item to cart
     */
    public function add(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'product_id' => ['required', 'exists:products,id'],
            'quantity' => ['required', 'integer', 'min:1'],
        ]);

        $product = Product::with('store')->findOrFail($validated['product_id']);

        // Check if product is in stock
        if (! $product->isInStock()) {
            return response()->json([
                'error' => 'Product is out of stock',
            ], 400);
        }

        // Check if requested quantity is available
        if ($product->track_inventory && $validated['quantity'] > $product->quantity) {
            return response()->json([
                'error' => "Only {$product->quantity} items available",
            ], 400);
        }

        try {
            DB::beginTransaction();

            $cart = $this->getOrCreateCart($request);

            // Check if item already exists in cart
            $cartItem = CartItem::where('cart_id', $cart->id)
                ->where('product_id', $product->id)
                ->first();

            if ($cartItem) {
                // Update quantity
                $newQuantity = $cartItem->quantity + $validated['quantity'];

                // Check stock again for new total
                if ($product->track_inventory && $newQuantity > $product->quantity) {
                    DB::rollBack();

                    return response()->json([
                        'error' => "Only {$product->quantity} items available",
                    ], 400);
                }

                $cartItem->update(['quantity' => $newQuantity]);
            } else {
                // Create new cart item
                $cartItem = CartItem::create([
                    'cart_id' => $cart->id,
                    'product_id' => $product->id,
                    'store_id' => $product->store_id,
                    'quantity' => $validated['quantity'],
                    'price' => $product->price,
                ]);
            }

            DB::commit();

            // Reload cart with items
            $cart->load(['items.product', 'items.store']);

            return response()->json([
                'message' => 'Product added to cart',
                'cart' => [
                    'items_count' => $cart->items_count,
                    'total' => $cart->total,
                ],
            ]);
        } catch (Exception $e) {
            DB::rollBack();

            return response()->json([
                'error' => 'Failed to add item to cart',
            ], 500);
        }
    }

    /**
     * Update cart item quantity
     */
    public function update(Request $request, CartItem $cartItem): Response
    {
        $validated = $request->validate([
            'quantity' => ['required', 'integer', 'min:1'],
        ]);

        $cart = $this->getOrCreateCart($request);

        // Verify cart ownership
        if ($cartItem->cart_id !== $cart->id) {
            abort(403);
        }

        $product = $cartItem->product;

        // Check stock availability
        if ($product->track_inventory && $validated['quantity'] > $product->quantity) {
            return back()->withErrors([
                'quantity' => "Only {$product->quantity} items available",
            ]);
        }

        $cartItem->update(['quantity' => $validated['quantity']]);

        $cart->load(['items.product.store', 'items.store']);

        return Inertia::render('event-city/cart/index', [
            'cart' => [
                'id' => $cart->id,
                'items' => $cart->items->map(fn ($item) => [
                    'id' => $item->id,
                    'quantity' => $item->quantity,
                    'price' => (float) $item->price,
                    'total' => (float) $item->total,
                    'product' => [
                        'id' => $item->product->id,
                        'name' => $item->product->name,
                        'slug' => $item->product->slug,
                        'images' => $item->product->images,
                        'is_in_stock' => $item->product->isInStock(),
                    ],
                    'store' => [
                        'id' => $item->store->id,
                        'name' => $item->store->name,
                        'slug' => $item->store->slug,
                    ],
                ]),
                'items_count' => $cart->items_count,
                'total' => (float) $cart->total,
            ],
        ]);
    }

    /**
     * Remove item from cart
     */
    public function remove(Request $request, CartItem $cartItem): Response
    {
        $cart = $this->getOrCreateCart($request);

        // Verify cart ownership
        if ($cartItem->cart_id !== $cart->id) {
            abort(403);
        }

        $cartItem->delete();

        $cart->load(['items.product.store', 'items.store']);

        return Inertia::render('event-city/cart/index', [
            'cart' => [
                'id' => $cart->id,
                'items' => $cart->items->map(fn ($item) => [
                    'id' => $item->id,
                    'quantity' => $item->quantity,
                    'price' => (float) $item->price,
                    'total' => (float) $item->total,
                    'product' => [
                        'id' => $item->product->id,
                        'name' => $item->product->name,
                        'slug' => $item->product->slug,
                        'images' => $item->product->images,
                        'is_in_stock' => $item->product->isInStock(),
                    ],
                    'store' => [
                        'id' => $item->store->id,
                        'name' => $item->store->name,
                        'slug' => $item->store->slug,
                    ],
                ]),
                'items_count' => $cart->items_count,
                'total' => (float) $cart->total,
            ],
        ]);
    }

    /**
     * Clear all items from cart
     */
    public function clear(Request $request): JsonResponse
    {
        $cart = $this->getOrCreateCart($request);
        $cart->items()->delete();

        return response()->json([
            'message' => 'Cart cleared',
            'cart' => [
                'items_count' => 0,
                'total' => 0,
            ],
        ]);
    }

    /**
     * Get cart count for header display
     */
    public function count(Request $request): JsonResponse
    {
        $cart = $this->getOrCreateCart($request);

        return response()->json([
            'count' => $cart->items_count,
        ]);
    }

    /**
     * Get cart items for dropdown
     */
    public function items(Request $request): JsonResponse
    {
        $cart = $this->getOrCreateCart($request);
        $cart->load(['items.product.store', 'items.store']);

        return response()->json([
            'items' => $cart->items->map(fn ($item) => [
                'id' => $item->id,
                'quantity' => $item->quantity,
                'price' => (float) $item->price,
                'product' => [
                    'id' => $item->product->id,
                    'name' => $item->product->name,
                    'slug' => $item->product->slug,
                    'images' => $item->product->images,
                ],
                'store' => [
                    'slug' => $item->store->slug,
                ],
            ]),
            'total' => (float) $cart->total,
        ]);
    }

    /**
     * Get or create cart for current user/session
     */
    private function getOrCreateCart(Request $request): Cart
    {
        if ($request->user()) {
            $cart = Cart::firstOrCreate(
                ['user_id' => $request->user()->id],
                ['session_id' => session()->getId()]
            );
        } else {
            $cart = Cart::firstOrCreate(
                ['session_id' => session()->getId()],
                ['user_id' => null]
            );
        }

        return $cart;
    }
}
```

### app/Http/Controllers/DayNews/PostPublishController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Models\DayNewsPost;
use App\Services\DayNewsPaymentService;
use App\Services\DayNewsPostService;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class PostPublishController extends Controller
{
    public function __construct(
        private readonly DayNewsPostService $postService,
        private readonly DayNewsPaymentService $paymentService
    ) {}

    public function show(Request $request, DayNewsPost $post): Response
    {
        $this->authorize('publish', $post);

        $post->load(['regions', 'payment', 'workspace']);

        $isFree = $this->postService->isPostFree(
            workspace: $post->workspace,
            type: $post->type,
            category: $post->category
        );

        $cost = $isFree ? 0 : $this->postService->calculateCost(
            type: $post->type,
            adDays: $post->metadata['ad_days'] ?? null
        );

        return Inertia::render('day-news/posts/publish', [
            'post' => [
                'id' => $post->id,
                'type' => $post->type,
                'category' => $post->category,
                'title' => $post->title,
                'excerpt' => $post->excerpt,
                'content' => $post->content,
                'featured_image' => $post->featured_image,
                'metadata' => $post->metadata,
                'regions' => $post->regions->map(fn ($r) => [
                    'id' => $r->id,
                    'name' => $r->name,
                ]),
            ],
            'pricing' => [
                'is_free' => $isFree,
                'cost' => $cost / 100,
                'reason' => $isFree ? $this->getFreeReason($post) : null,
            ],
        ]);
    }

    public function store(Request $request, DayNewsPost $post): RedirectResponse
    {
        $this->authorize('publish', $post);

        $post->load(['workspace']);

        $isFree = $this->postService->isPostFree(
            workspace: $post->workspace,
            type: $post->type,
            category: $post->category
        );

        if ($isFree) {
            $this->postService->publishPost($post);

            return redirect()
                ->route('day-news.posts.index')
                ->with('success', 'Post published successfully!');
        }

        $session = $this->paymentService->createCheckoutSession(
            post: $post,
            workspace: $post->workspace,
            successUrl: route('day-news.posts.payment.success').'?session_id={CHECKOUT_SESSION_ID}',
            cancelUrl: route('day-news.posts.edit', $post)
        );

        return Inertia::location($session->url);
    }

    private function getFreeReason(DayNewsPost $post): string
    {
        if ($post->category && in_array($post->category, config('services.day_news.free_categories', []))) {
            return 'Free category: '.ucfirst(str_replace('_', ' ', $post->category));
        }

        $publishedCount = DayNewsPost::forWorkspace($post->workspace_id)
            ->where('status', 'published')
            ->count();

        if ($publishedCount === 0) {
            return 'First post is free';
        }

        return 'Free post';
    }
}
```

### app/Http/Controllers/DayNews/EventController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Models\Event;
use App\Services\EventService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class EventController extends Controller
{
    public function __construct(
        private readonly EventService $eventService
    ) {}

    /**
     * Display events for Day News
     */
    public function index(Request $request): Response
    {
        $currentRegion = $request->attributes->get('detected_region');

        // Use shared EventService
        $filters = [
            'region_id' => $currentRegion?->id,
            'category' => $request->input('category'),
            'date_from' => $request->filled('date') ? $request->date : null,
            'sort_by' => $request->get('sort', 'event_date'),
            'sort_order' => $request->get('direction', 'asc'),
        ];

        $events = $this->eventService->getUpcoming($filters, 12);

        return Inertia::render('day-news/events/index', [
            'events' => $events,
            'filters' => $request->only(['category', 'date', 'search']),
            'sort' => [
                'sort' => $filters['sort_by'],
                'direction' => $filters['sort_order'],
            ],
            'currentRegion' => $currentRegion,
        ]);
    }

    /**
     * Display a single event
     */
    public function show(Request $request, Event $event): Response
    {
        $event->load(['venue', 'performer', 'regions']);

        // Get related events using EventService
        $similarEvents = $this->eventService->getRelated($event, 6);

        return Inertia::render('day-news/events/show', [
            'event' => $event,
            'similarEvents' => $similarEvents,
        ]);
    }
}

```

### app/Http/Controllers/DayNews/TrendingController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Services\DayNews\TrendingService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class TrendingController extends Controller
{
    public function __construct(
        private readonly TrendingService $trendingService
    ) {}

    /**
     * Display trending page
     */
    public function index(Request $request): Response
    {
        $currentRegion = $request->attributes->get('detected_region');
        $timePeriod = $request->get('period', 'now'); // now, hour, day, week, month
        $category = $request->get('category', 'all'); // all, stories, topics, categories, people

        $data = [
            'stories' => [],
            'topics' => [],
            'categories' => [],
            'people' => [],
            'community_pulse' => [],
        ];

        if ($category === 'all' || $category === 'stories') {
            $data['stories'] = $this->trendingService->getTrendingStories($timePeriod, $currentRegion, 20);
        }

        if ($category === 'all' || $category === 'topics') {
            $data['topics'] = $this->trendingService->getTrendingTopics($timePeriod, $currentRegion, 10);
        }

        if ($category === 'all' || $category === 'categories') {
            $data['categories'] = $this->trendingService->getTrendingCategories($timePeriod, $currentRegion, 10);
        }

        if ($category === 'all' || $category === 'people') {
            $data['people'] = $this->trendingService->getTrendingPeople($timePeriod, $currentRegion, 10);
        }

        if ($category === 'all') {
            $data['community_pulse'] = $this->trendingService->getCommunityPulse($currentRegion);
        }

        // Get active readers count (simplified - users who viewed articles in last hour)
        $activeReaders = \App\Models\User::whereHas('authoredDayNewsPosts', function ($q) {
            $q->published()->where('published_at', '>=', now()->subHour());
        })->count();

        return Inertia::render('day-news/trending/index', [
            'timePeriod' => $timePeriod,
            'category' => $category,
            'trendingStories' => $data['stories'],
            'trendingTopics' => $data['topics'],
            'trendingCategories' => $data['categories'],
            'trendingPeople' => $data['people'],
            'communityPulse' => $data['community_pulse'],
            'activeReaders' => $activeReaders,
            'currentRegion' => $currentRegion,
        ]);
    }
}

```

### app/Http/Controllers/DayNews/SearchController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Services\DayNews\SearchService;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class SearchController extends Controller
{
    public function __construct(
        private readonly SearchService $searchService
    ) {}

    /**
     * Display search results page
     */
    public function index(Request $request): Response
    {
        $query = $request->get('q', '');
        $filter = $request->get('filter', 'all'); // all, articles, events, businesses, tags
        $sortBy = $request->get('sort', 'relevance'); // relevance, date, popularity
        $timeFilter = $request->get('time', 'any'); // any, today, week, month, year

        $results = [
            'articles' => collect(),
            'events' => collect(),
            'businesses' => collect(),
            'tags' => collect(),
        ];

        $totalResults = 0;

        if ($query) {
            // Use SearchService for unified search
            $searchResults = $this->searchService->search($query, [
                'filter' => $filter,
                'sort' => $sortBy,
                'time' => $timeFilter,
            ]);

            // Format results
            $results['articles'] = collect($searchResults['articles'])->map(fn ($post) => [
                'id' => (string) $post->id,
                'type' => 'article',
                'title' => $post->title,
                'excerpt' => $post->excerpt,
                'image' => $post->featured_image,
                'published_at' => $post->published_at?->toISOString(),
                'author' => $post->author ? [
                    'name' => $post->author->name,
                    'avatar' => $post->author->profile_photo_url ?? null,
                ] : null,
                'slug' => $post->slug,
                'regions' => $post->regions->pluck('name')->toArray(),
            ]);

            $results['events'] = collect($searchResults['events'])->map(fn ($event) => [
                'id' => (string) $event->id,
                'type' => 'event',
                'title' => $event->title,
                'description' => $event->description,
                'image' => $event->featured_image,
                'date' => $event->event_date?->toISOString(),
                'venue' => $event->venue?->name,
                'location' => $event->venue?->address,
                'slug' => route('daynews.events.show', $event->id),
            ]);

            $results['businesses'] = collect($searchResults['businesses'])->map(fn ($business) => [
                'id' => (string) $business->id,
                'type' => 'business',
                'title' => $business->name,
                'description' => $business->description,
                'image' => $business->logo_url,
                'address' => $business->address,
                'rating' => $business->rating,
                'review_count' => $business->total_reviews,
                'slug' => $business->slug,
            ]);

            $results['tags'] = collect($searchResults['tags'])->map(fn ($tag) => [
                'id' => $tag->id,
                'type' => 'tag',
                'title' => $tag->name,
                'description' => $tag->description,
                'article_count' => $tag->article_count,
                'followers' => $tag->followers_count,
                'slug' => $tag->slug,
            ]);

            $totalResults = $results['articles']->count() + $results['events']->count() + $results['businesses']->count() + $results['tags']->count();

            // Record search history
            $this->searchService->recordSearch($query, $request->user()?->id, $totalResults, [
                'filter' => $filter,
                'sort' => $sortBy,
                'time' => $timeFilter,
            ]);
        }

        // Get trending searches and suggestions
        $trendingSearches = $this->searchService->getTrendingSearches();
        $suggestions = strlen($query) >= 2 ? $this->searchService->getSuggestions($query, 5) : [];

        return Inertia::render('day-news/search/index', [
            'query' => $query,
            'filter' => $filter,
            'sort' => $sortBy,
            'timeFilter' => $timeFilter,
            'results' => [
                'articles' => $results['articles']->values()->all(),
                'events' => $results['events']->values()->all(),
                'businesses' => $results['businesses']->values()->all(),
                'tags' => $results['tags']->values()->all(),
            ],
            'totalResults' => $totalResults,
            'trendingSearches' => $trendingSearches,
            'suggestions' => $suggestions,
        ]);
    }

    /**
     * Get search suggestions (autocomplete)
     */
    public function suggestions(Request $request): JsonResponse
    {
        $query = $request->get('q', '');
        $suggestions = $this->searchService->getSuggestions($query, 10);

        return response()->json(['suggestions' => $suggestions]);
    }
}

```

### app/Http/Controllers/DayNews/ArchiveController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Services\DayNews\ArchiveService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class ArchiveController extends Controller
{
    public function __construct(
        private readonly ArchiveService $archiveService
    ) {}

    /**
     * Display archive browser
     */
    public function index(Request $request): Response
    {
        $currentRegion = $request->attributes->get('detected_region');
        $view = $request->get('view', 'timeline'); // timeline, calendar, search
        $date = $request->get('date');
        $startDate = $request->get('start_date');
        $endDate = $request->get('end_date');
        $search = $request->get('search');
        $categories = $request->get('categories', []);

        $stats = $this->archiveService->getArchiveStats($currentRegion);

        $articles = collect();

        if ($date) {
            $articles = $this->archiveService->getArticlesByDate($date, $currentRegion);
        } elseif ($startDate || $endDate || $search || !empty($categories)) {
            $articles = $this->archiveService->searchArchive(
                $search ?? '',
                $startDate,
                $endDate,
                $categories,
                $currentRegion
            );
        }

        // Get calendar data for current month
        $now = now();
        $calendarData = $this->archiveService->getCalendarData($now->year, $now->month, $currentRegion);

        return Inertia::render('day-news/archive/index', [
            'stats' => $stats,
            'articles' => $articles,
            'calendarData' => $calendarData,
            'filters' => [
                'view' => $view,
                'date' => $date,
                'start_date' => $startDate,
                'end_date' => $endDate,
                'search' => $search,
                'categories' => $categories,
            ],
            'currentRegion' => $currentRegion,
            'currentMonth' => $now->month,
            'currentYear' => $now->year,
        ]);
    }

    /**
     * Get calendar data for specific month/year
     */
    public function calendar(Request $request, int $year, int $month): \Illuminate\Http\JsonResponse
    {
        $currentRegion = $request->attributes->get('detected_region');
        $calendarData = $this->archiveService->getCalendarData($year, $month, $currentRegion);

        return response()->json($calendarData);
    }
}

```

### app/Http/Controllers/DayNews/LegalNoticeController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Models\LegalNotice;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class LegalNoticeController extends Controller
{
    /**
     * Display legal notices listing
     */
    public function index(Request $request): Response
    {
        $currentRegion = $request->attributes->get('detected_region');
        $type = $request->get('type', 'all');
        $status = $request->get('status', 'active');
        $search = $request->get('search', '');

        $query = LegalNotice::query()
            ->with(['user', 'regions'])
            ->orderBy('publish_date', 'desc');

        // Filter by status
        if ($status === 'active') {
            $query->active();
        } elseif ($status === 'expires_soon') {
            $query->expiresSoon();
        } else {
            $query->where('status', $status);
        }

        // Filter by type
        if ($type !== 'all') {
            $query->byType($type);
        }

        // Filter by region
        if ($currentRegion) {
            $query->forRegion($currentRegion->id);
        }

        // Search
        if ($search) {
            $query->where(function ($q) use ($search) {
                $q->where('title', 'like', "%{$search}%")
                    ->orWhere('content', 'like', "%{$search}%")
                    ->orWhere('case_number', 'like', "%{$search}%");
            });
        }

        $notices = $query->paginate(20)->withQueryString();

        return Inertia::render('day-news/legal-notices/index', [
            'notices' => $notices,
            'filters' => [
                'type' => $type,
                'status' => $status,
                'search' => $search,
            ],
            'currentRegion' => $currentRegion,
        ]);
    }

    /**
     * Show legal notice creation form
     */
    public function create(): Response
    {
        return Inertia::render('day-news/legal-notices/create');
    }

    /**
     * Store new legal notice
     */
    public function store(\App\Http\Requests\DayNews\StoreLegalNoticeRequest $request): \Illuminate\Http\RedirectResponse
    {
        $validated = $request->validated();

        $notice = LegalNotice::create([
            'user_id' => $request->user()->id,
            'workspace_id' => $request->user()->currentWorkspace?->id,
            'type' => $validated['type'],
            'case_number' => $validated['case_number'] ?? null,
            'title' => $validated['title'],
            'content' => $validated['content'],
            'court' => $validated['court'] ?? null,
            'publish_date' => $validated['publish_date'],
            'expiry_date' => $validated['expiry_date'] ?? null,
            'status' => 'active',
            'metadata' => $validated['metadata'] ?? null,
        ]);

        // Attach regions
        if (!empty($validated['region_ids'])) {
            $notice->regions()->attach($validated['region_ids']);
        } else {
            $currentRegion = $request->attributes->get('detected_region');
            if ($currentRegion) {
                $notice->regions()->attach($currentRegion->id);
            }
        }

        return redirect()
            ->route('day-news.legal-notices.show', $notice->id)
            ->with('success', 'Legal notice published successfully!');
    }

    /**
     * Display single legal notice
     */
    public function show(Request $request, LegalNotice $notice): Response
    {
        $notice->load(['user', 'regions']);
        $notice->incrementViewsCount();

        return Inertia::render('day-news/legal-notices/show', [
            'notice' => $notice,
        ]);
    }
}

```

### app/Http/Controllers/DayNews/AuthorController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Models\User;
use App\Services\DayNews\AuthorService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class AuthorController extends Controller
{
    public function __construct(
        private readonly AuthorService $authorService
    ) {}

    /**
     * Display authors listing
     */
    public function index(Request $request): Response
    {
        $currentRegion = $request->attributes->get('detected_region');
        $search = $request->get('search', '');

        $query = User::whereHas('authoredDayNewsPosts', function ($q) {
            $q->published();
        })
            ->withCount(['authoredDayNewsPosts' => function ($q) {
                $q->published();
            }])
            ->orderBy('authored_day_news_posts_count', 'desc');

        // Filter by region
        if ($currentRegion) {
            $query->whereHas('authoredDayNewsPosts.regions', function ($q) use ($currentRegion) {
                $q->where('region_id', $currentRegion->id);
            });
        }

        // Search
        if ($search) {
            $query->where(function ($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                    ->orWhere('bio', 'like', "%{$search}%");
            });
        }

        $authors = $query->paginate(20)->withQueryString();

        return Inertia::render('day-news/authors/index', [
            'authors' => $authors,
            'filters' => [
                'search' => $search,
            ],
            'currentRegion' => $currentRegion,
        ]);
    }

    /**
     * Display author profile
     */
    public function show(Request $request, string $author): Response
    {
        $authorModel = $this->authorService->getAuthorByIdentifier($author);
        
        if (!$authorModel) {
            abort(404, 'Author not found');
        }

        $authorModel->loadCount(['authoredDayNewsPosts' => function ($q) {
            $q->published();
        }]);

        // Get author's articles
        $articles = $authorModel->authoredDayNewsPosts()
            ->published()
            ->with(['regions'])
            ->orderBy('published_at', 'desc')
            ->paginate(12);

        // Get analytics
        $analytics = $this->authorService->getAuthorAnalytics($authorModel, 30);

        // Update trust score
        $this->authorService->updateAuthorMetrics($authorModel);
        $authorModel->refresh();

        return Inertia::render('day-news/authors/show', [
            'author' => [
                'id' => $authorModel->id,
                'name' => $authorModel->name,
                'bio' => $authorModel->bio,
                'avatar' => $authorModel->profile_photo_url ?? $authorModel->avatar,
                'author_slug' => $authorModel->author_slug,
                'trust_score' => $authorModel->trust_score,
                'trust_tier' => $authorModel->trust_tier,
                'is_verified_author' => $authorModel->is_verified_author,
                'posts_count' => $authorModel->authored_day_news_posts_count,
            ],
            'articles' => $articles,
            'analytics' => $analytics,
        ]);
    }

    /**
     * Show author profile creation/edit form
     */
    public function create(): Response
    {
        return Inertia::render('day-news/authors/create');
    }

    /**
     * Store author profile
     */
    public function store(\App\Http\Requests\DayNews\StoreAuthorProfileRequest $request): \Illuminate\Http\RedirectResponse
    {
        $validated = $request->validated();

        $user = $request->user();

        if (empty($validated['author_slug'])) {
            $validated['author_slug'] = $this->authorService->generateAuthorSlug($user);
        }

        $user->update($validated);

        // Update trust metrics
        $this->authorService->updateAuthorMetrics($user);

        $identifier = $user->author_slug ?: $user->id;
        
        return redirect()
            ->route('day-news.authors.show', $identifier)
            ->with('success', 'Author profile updated successfully!');
    }
}

```

### app/Http/Controllers/DayNews/PostPaymentController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Services\DayNewsPaymentService;
use Exception;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Inertia\Response;

final class PostPaymentController extends Controller
{
    public function __construct(
        private readonly DayNewsPaymentService $paymentService
    ) {}

    public function success(Request $request): RedirectResponse|Response
    {
        $sessionId = $request->query('session_id');

        if (! $sessionId) {
            return redirect()
                ->route('day-news.posts.index')
                ->with('error', 'Payment session not found.');
        }

        try {
            $post = $this->paymentService->handleSuccessfulPayment($sessionId);

            return redirect()
                ->route('day-news.posts.index')
                ->with('success', 'Payment successful! Your post has been published.');
        } catch (Exception $e) {
            return redirect()
                ->route('day-news.posts.index')
                ->with('error', 'Payment processing failed. Please contact support.');
        }
    }

    public function cancel(Request $request): RedirectResponse
    {
        return redirect()
            ->route('day-news.posts.index')
            ->with('info', 'Payment cancelled. Your post remains as a draft.');
    }
}
```

### app/Http/Controllers/DayNews/CouponController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Http\Requests\DayNews\StoreCouponRequest;
use App\Http\Requests\DayNews\UpdateCouponRequest;
use App\Models\Coupon;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class CouponController extends Controller
{
    public function __construct(
        private readonly \App\Services\CouponService $couponService
    ) {}

    /**
     * Display coupons listing
     */
    public function index(Request $request): Response
    {
        $currentRegion = $request->attributes->get('detected_region');
        $search = $request->get('search', '');
        $businessId = $request->get('business_id');

        // Use shared CouponService
        $filters = [
            'region_id' => $currentRegion?->id,
            'business_id' => $businessId,
        ];

        $coupons = $this->couponService->getActiveCoupons($filters, 20);

        // Filter by search if provided
        if ($search) {
            $coupons = $coupons->filter(function ($coupon) use ($search) {
                return stripos($coupon->title, $search) !== false
                    || stripos($coupon->description ?? '', $search) !== false
                    || stripos($coupon->business_name ?? '', $search) !== false;
            });
        }

        // Paginate manually since getActiveCoupons returns Collection
        $perPage = 20;
        $currentPage = (int) $request->get('page', 1);
        $items = $coupons->slice(($currentPage - 1) * $perPage, $perPage);
        $total = $coupons->count();

        return Inertia::render('day-news/coupons/index', [
            'coupons' => [
                'data' => $items->map(fn ($coupon) => [
                'id' => $coupon->id,
                'title' => $coupon->title,
                'description' => $coupon->description,
                'discount_type' => $coupon->discount_type,
                'discount_value' => $coupon->discount_value,
                'terms' => $coupon->terms,
                'code' => $coupon->code,
                'image' => $coupon->image,
                'business_name' => $coupon->business_name,
                'business_location' => $coupon->business_location,
                'start_date' => $coupon->start_date->toDateString(),
                'end_date' => $coupon->end_date->toDateString(),
                'usage_limit' => $coupon->usage_limit,
                'used_count' => $coupon->used_count,
                'views_count' => $coupon->views_count,
                'clicks_count' => $coupon->clicks_count,
                'business' => $coupon->business ? [
                    'id' => $coupon->business->id,
                    'name' => $coupon->business->name,
                ] : null,
                'regions' => $coupon->regions->map(fn ($r) => [
                    'id' => $r->id,
                    'name' => $r->name,
                ]),
                ])->values(),
                'current_page' => $currentPage,
                'last_page' => (int) ceil($total / $perPage),
                'per_page' => $perPage,
                'total' => $total,
            ],
            'filters' => [
                'search' => $search,
                'business_id' => $businessId,
            ],
            'currentRegion' => $currentRegion,
        ]);
    }

    /**
     * Show coupon creation form
     */
    public function create(): Response
    {
        return Inertia::render('day-news/coupons/create');
    }

    /**
     * Store new coupon
     */
    public function store(StoreCouponRequest $request): \Illuminate\Http\RedirectResponse
    {
        $validated = $request->validated();
        $currentRegion = $request->attributes->get('detected_region');

        // Prepare data for CouponService
        $couponData = [
            'business_id' => $validated['business_id'] ?? null,
            'title' => $validated['title'],
            'description' => $validated['description'] ?? null,
            'discount_type' => $validated['discount_type'],
            'discount_value' => $validated['discount_value'] ?? null,
            'terms' => $validated['terms'] ?? null,
            'code' => $validated['code'] ?? null,
            'business_name' => $validated['business_name'],
            'business_location' => $validated['business_location'] ?? null,
            'start_date' => $validated['start_date'],
            'end_date' => $validated['end_date'],
            'usage_limit' => $validated['usage_limit'] ?? null,
            'status' => 'active', // Coupons are free to publish
        ];

        // Handle image upload
        if ($request->hasFile('image')) {
            $path = $request->file('image')->store('coupons', 'public');
            $couponData['image'] = $path;
        }

        // Attach regions
        if (!empty($validated['region_ids'])) {
            $couponData['regions'] = $validated['region_ids'];
        } elseif ($currentRegion) {
            $couponData['regions'] = [$currentRegion->id];
        }

        // Use CouponService to create
        $coupon = $this->couponService->create($couponData, $request->user()->id);

        return redirect()
            ->route('day-news.coupons.show', $coupon->id)
            ->with('success', 'Coupon published successfully!');
    }

    /**
     * Display single coupon
     */
    public function show(Request $request, Coupon $coupon): Response
    {
        $coupon->load(['business', 'regions']);
        
        // Track view using CouponService
        $this->couponService->trackView($coupon);

        // Get related coupons using CouponService
        $relatedFilters = [
            'region_id' => $coupon->regions->first()?->id,
        ];
        $allRelated = $this->couponService->getActiveCoupons($relatedFilters, 10);
        $related = $allRelated->filter(fn ($c) => $c->id !== $coupon->id)->take(6);

        return Inertia::render('day-news/coupons/show', [
            'coupon' => [
                'id' => $coupon->id,
                'title' => $coupon->title,
                'description' => $coupon->description,
                'discount_type' => $coupon->discount_type,
                'discount_value' => $coupon->discount_value,
                'terms' => $coupon->terms,
                'code' => $coupon->code,
                'image' => $coupon->image,
                'business_name' => $coupon->business_name,
                'business_location' => $coupon->business_location,
                'start_date' => $coupon->start_date->toDateString(),
                'end_date' => $coupon->end_date->toDateString(),
                'usage_limit' => $coupon->usage_limit,
                'used_count' => $coupon->used_count,
                'views_count' => $coupon->views_count,
                'clicks_count' => $coupon->clicks_count,
                'business' => $coupon->business ? [
                    'id' => $coupon->business->id,
                    'name' => $coupon->business->name,
                ] : null,
                'regions' => $coupon->regions->map(fn ($r) => [
                    'id' => $r->id,
                    'name' => $r->name,
                ]),
            ],
            'related' => $related->map(fn ($item) => [
                'id' => $item->id,
                'title' => $item->title,
                'description' => $item->description,
            ]),
        ]);
    }

    /**
     * Record coupon usage (click/use)
     */
    public function use(Request $request, Coupon $coupon): \Illuminate\Http\JsonResponse
    {
        // Validate coupon using CouponService
        $validation = $this->couponService->validate($coupon->code, $request->user()?->id);
        
        if (!$validation['valid']) {
            return response()->json([
                'error' => $validation['error'],
            ], 422);
        }

        // Track click using CouponService
        $this->couponService->trackClick($coupon);

        // Record usage if user is authenticated
        if ($request->user()) {
            try {
                $this->couponService->apply($coupon, $request->user()->id);
            } catch (\Exception $e) {
                return response()->json([
                    'error' => $e->getMessage(),
                ], 422);
            }
        }

        return response()->json([
            'message' => 'Coupon usage recorded',
            'coupon' => [
                'code' => $coupon->code,
                'discount_type' => $coupon->discount_type,
                'discount_value' => $coupon->discount_value,
                'terms' => $coupon->terms,
            ],
        ]);
    }

    /**
     * Show edit form
     */
    public function edit(Coupon $coupon): Response
    {
        $this->authorize('update', $coupon);

        $coupon->load(['regions']);

        return Inertia::render('day-news/coupons/edit', [
            'coupon' => $coupon,
        ]);
    }

    /**
     * Update coupon
     */
    public function update(UpdateCouponRequest $request, Coupon $coupon): \Illuminate\Http\RedirectResponse
    {
        $validated = $request->validated();

        // Handle image upload
        if ($request->hasFile('image')) {
            $path = $request->file('image')->store('coupons', 'public');
            $validated['image'] = $path;
        }

        // Update regions if provided
        if (isset($validated['region_ids'])) {
            $validated['regions'] = $validated['region_ids'];
            unset($validated['region_ids']);
        }

        // Use CouponService to update
        $this->couponService->update($coupon, $validated);

        return redirect()
            ->route('day-news.coupons.show', $coupon->id)
            ->with('success', 'Coupon updated successfully!');
    }

    /**
     * Delete coupon
     */
    public function destroy(Coupon $coupon): \Illuminate\Http\RedirectResponse
    {
        $this->authorize('delete', $coupon);

        $coupon->delete();

        return redirect()
            ->route('day-news.coupons.index')
            ->with('success', 'Coupon deleted successfully!');
    }
}

```

### app/Http/Controllers/DayNews/PostController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Http\Requests\DayNews\StoreDayNewsPostRequest;
use App\Http\Requests\DayNews\UpdateDayNewsPostRequest;
use App\Models\DayNewsPost;
use App\Models\Region;
use App\Services\DayNewsPostService;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;
use Inertia\Inertia;
use Inertia\Response;

final class PostController extends Controller
{
    public function __construct(
        private readonly DayNewsPostService $postService
    ) {
        //
    }

    public function index(Request $request): Response
    {
        $this->authorize('viewAny', DayNewsPost::class);

        $workspace = $request->user()->currentWorkspace;

        if (! $workspace) {
            abort(403, 'No workspace selected');
        }

        $query = DayNewsPost::where('workspace_id', $workspace->id)
            ->with(['regions', 'payment', 'author']);

        if ($request->filled('type')) {
            $query->byType($request->type);
        }

        if ($request->filled('status')) {
            $query->where('status', $request->status);
        }

        $posts = $query->latest()
            ->paginate(15)
            ->through(fn ($post) => [
                'id' => $post->id,
                'type' => $post->type,
                'category' => $post->category,
                'title' => $post->title,
                'slug' => $post->slug,
                'excerpt' => $post->excerpt,
                'status' => $post->status,
                'view_count' => $post->view_count,
                'published_at' => $post->published_at?->toISOString(),
                'expires_at' => $post->expires_at?->toISOString(),
                'regions' => $post->regions->map(fn ($r) => ['id' => $r->id, 'name' => $r->name]),
                'payment' => $post->payment ? [
                    'amount' => $post->payment->getAmountInDollars(),
                    'status' => $post->payment->status,
                ] : null,
                'can_edit' => $post->status === 'draft',
                'can_delete' => $request->user()->can('delete', $post),
            ]);

        return Inertia::render('day-news/posts/index', [
            'posts' => $posts,
            'filters' => $request->only(['type', 'status']),
        ]);
    }

    public function create(Request $request): Response
    {
        $this->authorize('create', DayNewsPost::class);

        $regions = Region::where('is_active', true)
            ->orderBy('name')
            ->get()
            ->map(fn ($r) => [
                'id' => $r->id,
                'name' => $r->name,
                'type' => $r->type,
            ]);

        $type = $request->query('type', 'article');

        return Inertia::render('day-news/posts/create', [
            'regions' => $regions,
            'initialType' => $type,
        ]);
    }

    public function store(StoreDayNewsPostRequest $request): RedirectResponse
    {
        $workspace = $request->user()->currentWorkspace;

        $data = $request->validated();

        if ($request->hasFile('featured_image')) {
            $data['featured_image'] = $request->file('featured_image')->store('day-news-posts', 'public');
        }

        $post = $this->postService->createPost(
            user: $request->user(),
            workspace: $workspace,
            data: $data
        );

        if ($post->status === 'published') {
            return redirect()
                ->route('day-news.posts.index')
                ->with('success', 'Post published successfully!');
        }

        return redirect()
            ->route('day-news.posts.publish', $post)
            ->with('info', 'Draft created. Please complete payment to publish.');
    }

    public function edit(DayNewsPost $post): Response
    {
        $this->authorize('update', $post);

        $post->load(['regions', 'payment']);

        $regions = Region::where('is_active', true)
            ->orderBy('name')
            ->get()
            ->map(fn ($r) => [
                'id' => $r->id,
                'name' => $r->name,
                'type' => $r->type,
            ]);

        return Inertia::render('day-news/posts/edit', [
            'post' => [
                'id' => $post->id,
                'type' => $post->type,
                'category' => $post->category,
                'title' => $post->title,
                'slug' => $post->slug,
                'content' => $post->content,
                'excerpt' => $post->excerpt,
                'featured_image' => $post->featured_image,
                'metadata' => $post->metadata,
                'status' => $post->status,
                'regions' => $post->regions->map(fn ($r) => $r->id),
            ],
            'regions' => $regions,
        ]);
    }

    public function update(UpdateDayNewsPostRequest $request, DayNewsPost $post): RedirectResponse
    {
        $this->authorize('update', $post);

        $data = $request->validated();

        if ($request->hasFile('featured_image')) {
            if ($post->featured_image) {
                Storage::disk('public')->delete($post->featured_image);
            }
            $data['featured_image'] = $request->file('featured_image')->store('day-news-posts', 'public');
        }

        $this->postService->updatePost($post, $data);

        return back()->with('success', 'Post updated successfully.');
    }

    public function destroy(DayNewsPost $post): RedirectResponse
    {
        $this->authorize('delete', $post);

        if ($post->featured_image) {
            Storage::disk('public')->delete($post->featured_image);
        }

        $this->postService->deletePost($post);

        return redirect()
            ->route('day-news.posts.index')
            ->with('success', 'Post deleted successfully.');
    }
}
```

### app/Http/Controllers/DayNews/PhotoController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Models\Photo;
use App\Models\PhotoAlbum;
use App\Services\DayNews\PhotoService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class PhotoController extends Controller
{
    public function __construct(
        private readonly PhotoService $photoService
    ) {}

    /**
     * Display photos gallery
     */
    public function index(Request $request): Response
    {
        $currentRegion = $request->attributes->get('detected_region');
        $category = $request->get('category', 'all');
        $search = $request->get('search', '');

        $query = Photo::approved()
            ->public()
            ->with(['user', 'regions', 'album'])
            ->orderBy('created_at', 'desc');

        // Filter by region
        if ($currentRegion) {
            $query->forRegion($currentRegion->id);
        }

        // Filter by category
        if ($category !== 'all') {
            $query->byCategory($category);
        }

        // Search
        if ($search) {
            $query->where(function ($q) use ($search) {
                $q->where('title', 'like', "%{$search}%")
                    ->orWhere('description', 'like', "%{$search}%");
            });
        }

        $photos = $query->paginate(24)->withQueryString();

        return Inertia::render('day-news/photos/index', [
            'photos' => $photos,
            'filters' => [
                'category' => $category,
                'search' => $search,
            ],
            'currentRegion' => $currentRegion,
        ]);
    }

    /**
     * Show photo upload form
     */
    public function create(): Response
    {
        $albums = PhotoAlbum::where('user_id', auth()->id())
            ->orderBy('created_at', 'desc')
            ->get();

        return Inertia::render('day-news/photos/create', [
            'albums' => $albums,
        ]);
    }

    /**
     * Store new photo
     */
    public function store(\App\Http\Requests\DayNews\StorePhotoRequest $request): \Illuminate\Http\RedirectResponse
    {
        $validated = $request->validated();

        $photo = $this->photoService->uploadPhoto(
            $request->file('image'),
            $validated,
            $request->user()->id,
            $validated['album_id'] ?? null
        );

        return redirect()
            ->route('day-news.photos.show', $photo->id)
            ->with('success', 'Photo uploaded successfully!');
    }

    /**
     * Display single photo
     */
    public function show(Request $request, Photo $photo): Response
    {
        $photo->load(['user', 'regions', 'album', 'albums']);
        $photo->incrementViewsCount();

        // Get related photos
        $related = Photo::approved()
            ->public()
            ->where('id', '!=', $photo->id)
            ->where(function ($q) use ($photo) {
                $q->where('category', $photo->category)
                    ->orWhereHas('regions', function ($regionQuery) use ($photo) {
                        $regionQuery->whereIn('region_id', $photo->regions->pluck('id'));
                    });
            })
            ->with(['user', 'album'])
            ->limit(12)
            ->get();

        return Inertia::render('day-news/photos/show', [
            'photo' => $photo,
            'related' => $related,
        ]);
    }

    /**
     * Delete photo
     */
    public function destroy(Photo $photo): \Illuminate\Http\RedirectResponse
    {
        $this->authorize('delete', $photo);

        $this->photoService->deletePhoto($photo);

        return redirect()
            ->route('day-news.photos.index')
            ->with('success', 'Photo deleted successfully!');
    }

    /**
     * Display photo albums
     */
    public function albums(Request $request): Response
    {
        $currentRegion = $request->attributes->get('detected_region');

        $query = PhotoAlbum::where('visibility', 'public')
            ->with(['user', 'photos' => function ($q) {
                $q->approved()->limit(4);
            }])
            ->orderBy('created_at', 'desc');

        if ($currentRegion) {
            $query->whereHas('photos.regions', function ($q) use ($currentRegion) {
                $q->where('region_id', $currentRegion->id);
            });
        }

        $albums = $query->paginate(20)->withQueryString();

        return Inertia::render('day-news/photos/albums', [
            'albums' => $albums,
            'currentRegion' => $currentRegion,
        ]);
    }

    /**
     * Show album
     */
    public function showAlbum(Request $request, PhotoAlbum $album): Response
    {
        $album->load(['user', 'photos' => function ($q) {
            $q->approved()->orderBy('created_at', 'desc');
        }]);
        $album->incrementViewsCount();

        return Inertia::render('day-news/photos/album-show', [
            'album' => $album,
        ]);
    }

    /**
     * Create album
     */
    public function createAlbum(): Response
    {
        return Inertia::render('day-news/photos/create-album');
    }

    /**
     * Store album
     */
    public function storeAlbum(\App\Http\Requests\DayNews\StorePhotoAlbumRequest $request): \Illuminate\Http\RedirectResponse
    {
        $validated = $request->validated();

        $album = $this->photoService->createAlbum(
            $validated,
            $request->user()->id,
            $request->user()->currentWorkspace?->id
        );

        return redirect()
            ->route('day-news.photos.album.show', $album->id)
            ->with('success', 'Album created successfully!');
    }
}

```

### app/Http/Controllers/DayNews/RegionHomeController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Models\DayNewsPost;
use App\Models\Region;
use App\Services\AdvertisementService;
use App\Services\LocationService;
use App\Services\SeoService;
use Inertia\Inertia;
use Inertia\Response;

final class RegionHomeController extends Controller
{
    public function __construct(
        private readonly LocationService $locationService,
        private readonly AdvertisementService $advertisementService,
    ) {}

    public function show(string $regionSlug): Response
    {
        $region = Region::active()->where('slug', $regionSlug)->first();

        if ($region === null) {
            abort(404);
        }

        // Store region preference in session/cookie
        $this->locationService->setUserLocation($region->id);

        // Get all published posts for this region
        $allArticles = DayNewsPost::published()
            ->with(['author', 'regions', 'workspace'])
            ->whereHas('regions', fn ($q) => $q->where('regions.id', $region->id))
            ->orderBy('published_at', 'desc')
            ->limit(20)
            ->get();

        // Get advertisements for different placements
        $bannerAds = $this->advertisementService->getActiveAds('day_news', $region, 'banner')->take(1);
        $featuredAds = $this->advertisementService->getActiveAds('day_news', $region, 'featured')->take(1);
        $inlineAds = $this->advertisementService->getActiveAds('day_news', $region, 'inline')->take(3);
        $sidebarAds = $this->advertisementService->getActiveAds('day_news', $region, 'sidebar')->take(3);

        // Build SEO JSON-LD with region-specific data
        $seoData = [
            'title' => "Local News for {$region->name}",
            'description' => "Stay informed with the latest news from {$region->name}. Get timely updates on local stories, events, and community coverage.",
            'url' => "/{$region->slug}",
        ];

        return Inertia::render('day-news/index', [
            'seo' => [
                'jsonLd' => SeoService::buildJsonLd('website', $seoData, 'day-news'),
            ],
            'news' => $allArticles,
            'hasRegion' => true,
            'advertisements' => [
                'banner' => $bannerAds->map(fn ($ad) => [
                    'id' => $ad->id,
                    'placement' => $ad->placement,
                    'advertable' => [
                        'id' => $ad->advertable->id,
                        'title' => $ad->advertable->title,
                        'excerpt' => $ad->advertable->excerpt,
                        'featured_image' => $ad->advertable->featured_image,
                        'slug' => $ad->advertable->slug,
                    ],
                    'expires_at' => $ad->expires_at->toISOString(),
                ]),
                'featured' => $featuredAds->map(fn ($ad) => [
                    'id' => $ad->id,
                    'placement' => $ad->placement,
                    'advertable' => [
                        'id' => $ad->advertable->id,
                        'title' => $ad->advertable->title,
                        'excerpt' => $ad->advertable->excerpt,
                        'featured_image' => $ad->advertable->featured_image,
                        'slug' => $ad->advertable->slug,
                    ],
                    'expires_at' => $ad->expires_at->toISOString(),
                ]),
                'inline' => $inlineAds->map(fn ($ad) => [
                    'id' => $ad->id,
                    'placement' => $ad->placement,
                    'advertable' => [
                        'id' => $ad->advertable->id,
                        'title' => $ad->advertable->title,
                        'excerpt' => $ad->advertable->excerpt,
                        'featured_image' => $ad->advertable->featured_image,
                        'slug' => $ad->advertable->slug,
                    ],
                    'expires_at' => $ad->expires_at->toISOString(),
                ]),
                'sidebar' => $sidebarAds->map(fn ($ad) => [
                    'id' => $ad->id,
                    'placement' => $ad->placement,
                    'advertable' => [
                        'id' => $ad->advertable->id,
                        'title' => $ad->advertable->title,
                        'excerpt' => $ad->advertable->excerpt,
                        'featured_image' => $ad->advertable->featured_image,
                        'slug' => $ad->advertable->slug,
                    ],
                    'expires_at' => $ad->expires_at->toISOString(),
                ]),
            ],
        ]);
    }
}
```

### app/Http/Controllers/DayNews/CreatorController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Models\CreatorProfile;
use App\Models\Region;
use App\Services\AdvertisementService;
use App\Services\DayNews\PodcastService;
use App\Services\LocationService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class CreatorController extends Controller
{
    public function __construct(
        private readonly PodcastService $podcastService,
        private readonly AdvertisementService $advertisementService,
        private readonly LocationService $locationService
    ) {}

    /**
     * Get the view path based on domain/route
     */
    protected function getViewPath(Request $request, string $page): string
    {
        if ($this->isStandaloneView($request)) {
            return "local-voices/{$page}";
        }
        
        return "day-news/local-voices/{$page}";
    }

    /**
     * Get view mode for frontend
     */
    protected function getViewMode(Request $request): string
    {
        return $this->isStandaloneView($request) ? 'standalone' : 'integrated';
    }

    /**
     * Check if this is standalone view (Go Local Voices)
     */
    protected function isStandaloneView(Request $request): bool
    {
        return $request->getHost() === config('domains.local-voices')
            || $request->routeIs('localvoices.*');
    }

    /**
     * Display local voices (podcasts) listing
     */
    public function index(Request $request): Response
    {
        $currentRegion = $request->attributes->get('detected_region');
        $category = $request->get('category', 'all');
        $sort = $request->get('sort', 'trending');
        $search = $request->get('search', '');

        $query = \App\Models\Podcast::published()
            ->with(['creator', 'regions'])
            ->withCount(['episodes' => function ($q) {
                $q->published();
            }]);

        // Filter by region
        if ($currentRegion) {
            $query->forRegion($currentRegion->id);
        }

        // Filter by category
        if ($category !== 'all') {
            $query->byCategory($category);
        }

        // Search
        if ($search) {
            $query->where(function ($q) use ($search) {
                $q->where('title', 'like', "%{$search}%")
                    ->orWhere('description', 'like', "%{$search}%");
            });
        }

        // Sort
        match ($sort) {
            'newest' => $query->orderBy('published_at', 'desc'),
            'popular' => $query->orderBy('subscribers_count', 'desc'),
            default => $query->orderBy('total_listens', 'desc'), // trending
        };

        $podcasts = $query->paginate(20)->withQueryString();

        // Get advertisements (use local_voices platform for standalone, day_news for integrated)
        $platform = $this->isStandaloneView($request) ? 'local_voices' : 'day_news';
        $bannerAds = $this->advertisementService->getActiveAds($platform, $currentRegion, 'banner')->take(1);
        $sidebarAds = $this->advertisementService->getActiveAds($platform, $currentRegion, 'sidebar')->take(3);

        return Inertia::render($this->getViewPath($request, 'index'), [
            'podcasts' => $podcasts,
            'filters' => [
                'category' => $category,
                'sort' => $sort,
                'search' => $search,
            ],
            'currentRegion' => $currentRegion,
            'viewMode' => $this->getViewMode($request),
            'advertisements' => [
                'banner' => $bannerAds->map(fn ($ad) => $this->formatAd($ad)),
                'sidebar' => $sidebarAds->map(fn ($ad) => $this->formatAd($ad)),
            ],
        ]);
    }

    /**
     * Show creator registration form
     */
    public function create(): Response
    {
        $existingProfile = CreatorProfile::where('user_id', auth()->id())->first();

        return Inertia::render($this->getViewPath(request(), 'register'), [
            'existingProfile' => $existingProfile ? [
                'id' => $existingProfile->id,
                'display_name' => $existingProfile->display_name,
                'status' => $existingProfile->status,
            ] : null,
            'viewMode' => $this->getViewMode(request()),
        ]);
    }

    /**
     * Store creator profile
     */
    public function store(\App\Http\Requests\DayNews\StoreCreatorProfileRequest $request): \Illuminate\Http\RedirectResponse
    {
        $validated = $request->validated();

        $profile = $this->podcastService->createCreatorProfile(
            $validated,
            $request->user()->id
        );

        // Handle image uploads
        if ($request->hasFile('avatar')) {
            $path = $request->file('avatar')->store('creators/avatars', 'public');
            $profile->update(['avatar' => $path]);
        }

        if ($request->hasFile('cover_image')) {
            $path = $request->file('cover_image')->store('creators/covers', 'public');
            $profile->update(['cover_image' => $path]);
        }

        // Handle social links
        if (!empty($validated['social_links'])) {
            $profile->update(['social_links' => $validated['social_links']]);
        }

        $routeName = $this->isStandaloneView($request) 
            ? 'localvoices.dashboard' 
            : 'daynews.local-voices.dashboard';
            
        return redirect()
            ->route($routeName)
            ->with('success', 'Creator profile submitted for approval!');
    }

    /**
     * Show creator dashboard
     */
    public function dashboard(): Response
    {
        $profile = CreatorProfile::where('user_id', auth()->id())->firstOrFail();
        $podcasts = $profile->podcasts()->with(['episodes' => function ($q) {
            $q->orderBy('created_at', 'desc')->limit(3);
        }])->get();

        return Inertia::render($this->getViewPath(request(), 'dashboard'), [
            'profile' => [
                'id' => $profile->id,
                'display_name' => $profile->display_name,
                'bio' => $profile->bio,
                'avatar' => $profile->avatar,
                'cover_image' => $profile->cover_image,
                'status' => $profile->status,
                'followers_count' => $profile->followers_count,
                'podcasts_count' => $profile->podcasts_count,
                'episodes_count' => $profile->episodes_count,
                'total_listens' => $profile->total_listens,
            ],
            'podcasts' => $podcasts->map(fn ($p) => [
                'id' => $p->id,
                'title' => $p->title,
                'slug' => $p->slug,
                'description' => $p->description,
                'cover_image' => $p->cover_image,
                'status' => $p->status,
                'episodes_count' => $p->episodes_count,
                'subscribers_count' => $p->subscribers_count,
                'total_listens' => $p->total_listens,
                'episodes' => $p->episodes->map(fn ($e) => [
                    'id' => $e->id,
                    'title' => $e->title,
                    'status' => $e->status,
                ]),
            ]),
            'viewMode' => $this->getViewMode(request()),
        ]);
    }

    /**
     * Format advertisement for frontend
     */
    private function formatAd($ad): array
    {
        return [
            'id' => $ad->id,
            'placement' => $ad->placement,
            'advertable' => [
                'id' => $ad->advertable->id,
                'title' => $ad->advertable->title ?? $ad->advertable->name ?? null,
                'excerpt' => $ad->advertable->excerpt ?? $ad->advertable->description ?? null,
                'featured_image' => $ad->advertable->featured_image ?? $ad->advertable->image ?? $ad->advertable->cover_image ?? null,
                'slug' => $ad->advertable->slug ?? null,
            ],
            'expires_at' => $ad->expires_at->toISOString(),
        ];
    }
}

```

### app/Http/Controllers/DayNews/PodcastController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Models\Podcast;
use App\Models\PodcastEpisode;
use App\Models\Region;
use App\Services\AdvertisementService;
use App\Services\DayNews\PodcastService;
use App\Services\LocationService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class PodcastController extends Controller
{
    public function __construct(
        private readonly PodcastService $podcastService,
        private readonly AdvertisementService $advertisementService,
        private readonly LocationService $locationService
    ) {}

    /**
     * Get the view path based on domain/route
     */
    protected function getViewPath(Request $request, string $page): string
    {
        if ($this->isStandaloneView($request)) {
            return "local-voices/{$page}";
        }
        
        return "day-news/local-voices/{$page}";
    }

    /**
     * Get view mode for frontend
     */
    protected function getViewMode(Request $request): string
    {
        return $this->isStandaloneView($request) ? 'standalone' : 'integrated';
    }

    /**
     * Check if this is standalone view (Go Local Voices)
     */
    protected function isStandaloneView(Request $request): bool
    {
        return $request->getHost() === config('domains.local-voices')
            || $request->routeIs('localvoices.*');
    }

    /**
     * Display single podcast
     */
    public function show(Request $request, Podcast $podcast): Response
    {
        $podcast->load(['creator.user', 'regions', 'episodes' => function ($q) {
            $q->published()->orderBy('published_at', 'desc');
        }]);

        // Get advertisements
        $platform = $this->isStandaloneView($request) ? 'local_voices' : 'day_news';
        $currentRegion = $request->attributes->get('detected_region') ?? $podcast->regions->first();
        $bannerAds = $this->advertisementService->getActiveAds($platform, $currentRegion, 'banner')->take(1);
        $sidebarAds = $this->advertisementService->getActiveAds($platform, $currentRegion, 'sidebar')->take(3);
        $inlineAds = $this->advertisementService->getActiveAds($platform, $currentRegion, 'inline')->take(2);

        return Inertia::render($this->getViewPath($request, 'podcast-show'), [
            'podcast' => [
                'id' => $podcast->id,
                'title' => $podcast->title,
                'slug' => $podcast->slug,
                'description' => $podcast->description,
                'cover_image' => $podcast->cover_image,
                'category' => $podcast->category,
                'episodes_count' => $podcast->episodes_count,
                'subscribers_count' => $podcast->subscribers_count,
                'total_listens' => $podcast->total_listens,
                'created_at' => $podcast->created_at->toISOString(),
                'creator' => [
                    'id' => $podcast->creator->id,
                    'display_name' => $podcast->creator->display_name,
                    'avatar' => $podcast->creator->avatar,
                    'user_id' => $podcast->creator->user_id,
                ],
                'episodes' => $podcast->episodes->map(fn ($ep) => [
                    'id' => $ep->id,
                    'title' => $ep->title,
                    'slug' => $ep->slug,
                    'description' => $ep->description,
                    'episode_number' => $ep->episode_number,
                    'duration' => $ep->duration,
                    'formatted_duration' => $ep->formatted_duration ?? '0:00',
                    'published_at' => $ep->published_at?->toISOString(),
                    'listens_count' => $ep->listens_count,
                ]),
            ],
            'viewMode' => $this->getViewMode($request),
            'advertisements' => [
                'banner' => $bannerAds->map(fn ($ad) => $this->formatAd($ad)),
                'sidebar' => $sidebarAds->map(fn ($ad) => $this->formatAd($ad)),
                'inline' => $inlineAds->map(fn ($ad) => $this->formatAd($ad)),
            ],
        ]);
    }

    /**
     * Show podcast creation form
     */
    public function create(): Response
    {
        $profile = \App\Models\CreatorProfile::where('user_id', auth()->id())
            ->approved()
            ->firstOrFail();

        return Inertia::render($this->getViewPath(request(), 'podcast-create'), [
            'profile' => [
                'id' => $profile->id,
                'display_name' => $profile->display_name,
            ],
            'viewMode' => $this->getViewMode(request()),
        ]);
    }

    /**
     * Store new podcast
     */
    public function store(\App\Http\Requests\DayNews\StorePodcastRequest $request): \Illuminate\Http\RedirectResponse
    {
        $validated = $request->validated();

        $profile = \App\Models\CreatorProfile::where('user_id', $request->user()->id)
            ->approved()
            ->firstOrFail();

        $podcast = $this->podcastService->createPodcast(
            array_merge($validated, ['cover_image' => $request->file('cover_image')]),
            $profile->id
        );

        $routeName = $this->isStandaloneView($request) 
            ? 'localvoices.podcast.show' 
            : 'daynews.local-voices.podcast.show';
            
        return redirect()
            ->route($routeName, $podcast->slug)
            ->with('success', 'Podcast created successfully!');
    }

    /**
     * Show episode upload form
     */
    public function createEpisode(Podcast $podcast): Response
    {
        $this->authorize('update', $podcast);

        return Inertia::render($this->getViewPath(request(), 'episode-create'), [
            'podcast' => $podcast,
            'viewMode' => $this->getViewMode(request()),
        ]);
    }

    /**
     * Store episode
     */
    public function storeEpisode(\App\Http\Requests\DayNews\StorePodcastEpisodeRequest $request, Podcast $podcast): \Illuminate\Http\RedirectResponse
    {
        $this->authorize('update', $podcast);

        $validated = $request->validated();

        $episode = PodcastEpisode::create([
            'podcast_id' => $podcast->id,
            'title' => $validated['title'],
            'description' => $validated['description'] ?? null,
            'show_notes' => $validated['show_notes'] ?? null,
            'episode_number' => $validated['episode_number'] ?? null,
            'status' => 'draft',
        ]);

        // Upload audio file
        $this->podcastService->uploadEpisode($episode, $request->file('audio_file'));

        $routeName = $this->isStandaloneView($request) 
            ? 'localvoices.podcast.show' 
            : 'daynews.local-voices.podcast.show';
            
        return redirect()
            ->route($routeName, ['podcast' => $podcast->slug])
            ->with('success', 'Episode uploaded successfully!');
    }

    /**
     * Display single episode
     */
    public function showEpisode(Request $request, Podcast $podcast, PodcastEpisode $episode): Response
    {
        $episode->load(['podcast.creator.user']);
        $episode->incrementListensCount();

        // Get related episodes
        $related = $podcast->episodes()
            ->published()
            ->where('id', '!=', $episode->id)
            ->limit(6)
            ->get();

        return Inertia::render($this->getViewPath($request, 'episode-show'), [
            'episode' => [
                'id' => $episode->id,
                'title' => $episode->title,
                'slug' => $episode->slug,
                'description' => $episode->description,
                'show_notes' => $episode->show_notes,
                'audio_url' => $episode->audio_url,
                'formatted_duration' => $episode->formatted_duration ?? '0:00',
                'episode_number' => $episode->episode_number,
                'published_at' => $episode->published_at?->toISOString(),
                'listens_count' => $episode->listens_count,
                'downloads_count' => $episode->downloads_count,
                'likes_count' => $episode->likes_count,
                'comments_count' => $episode->comments_count,
                'podcast' => [
                    'id' => $podcast->id,
                    'title' => $podcast->title,
                    'slug' => $podcast->slug,
                    'cover_image' => $podcast->cover_image,
                    'creator' => [
                        'id' => $podcast->creator->id,
                        'display_name' => $podcast->creator->display_name,
                        'avatar' => $podcast->creator->avatar,
                    ],
                ],
            ],
            'related' => $related->map(fn ($ep) => [
                'id' => $ep->id,
                'title' => $ep->title,
                'slug' => $ep->slug,
                'formatted_duration' => $ep->formatted_duration ?? '0:00',
                'published_at' => $ep->published_at?->toISOString(),
            ]),
            'viewMode' => $this->getViewMode($request),
        ]);
    }

    /**
     * Publish episode
     */
    public function publishEpisode(Podcast $podcast, PodcastEpisode $episode): \Illuminate\Http\RedirectResponse
    {
        $this->authorize('update', $podcast);

        $this->podcastService->publishEpisode($episode);

        $routeName = $this->isStandaloneView($request) 
            ? 'localvoices.podcast.show' 
            : 'daynews.local-voices.podcast.show';
            
        return redirect()
            ->route($routeName, $podcast->slug)
            ->with('success', 'Episode published successfully!');
    }

    /**
     * Format advertisement for frontend
     */
    private function formatAd($ad): array
    {
        return [
            'id' => $ad->id,
            'placement' => $ad->placement,
            'advertable' => [
                'id' => $ad->advertable->id,
                'title' => $ad->advertable->title ?? $ad->advertable->name ?? null,
                'excerpt' => $ad->advertable->excerpt ?? $ad->advertable->description ?? null,
                'featured_image' => $ad->advertable->featured_image ?? $ad->advertable->image ?? $ad->advertable->cover_image ?? null,
                'slug' => $ad->advertable->slug ?? null,
            ],
            'expires_at' => $ad->expires_at->toISOString(),
        ];
    }
}

```

### app/Http/Controllers/DayNews/SitemapController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Models\DayNewsPost;
use App\Models\Region;
use Illuminate\Http\Response;
use Illuminate\Support\Facades\Cache;
use Spatie\Sitemap\Sitemap;
use Spatie\Sitemap\SitemapIndex;
use Spatie\Sitemap\Tags\Sitemap as SitemapTag;
use Spatie\Sitemap\Tags\Url;

final class SitemapController extends Controller
{
    public function robots(): Response
    {
        $baseUrl = 'https://'.config('domains.day-news');
        $content = "User-agent: *\nAllow: /\n\nSitemap: {$baseUrl}/sitemap.xml\n";

        return response($content, 200, ['Content-Type' => 'text/plain']);
    }

    public function index(): Response
    {
        $cacheKey = 'sitemap:day-news:index';

        $content = Cache::remember($cacheKey, $this->getCacheTtl(), function () {
            $sitemapIndex = SitemapIndex::create();
            $baseUrl = 'https://'.config('domains.day-news');

            // Add static sitemap
            $sitemapIndex->add(SitemapTag::create("{$baseUrl}/sitemap-static.xml"));

            // Add regions sitemap
            $sitemapIndex->add(SitemapTag::create("{$baseUrl}/sitemap-regions.xml"));

            // Add posts sitemap(s)
            $postCount = DayNewsPost::published()->count();
            $postPages = (int) ceil($postCount / $this->getPerPage());

            if ($postPages <= 1) {
                $sitemapIndex->add(SitemapTag::create("{$baseUrl}/sitemap-posts.xml"));
            } else {
                for ($i = 1; $i <= $postPages; $i++) {
                    $sitemapIndex->add(SitemapTag::create("{$baseUrl}/sitemap-posts-{$i}.xml"));
                }
            }

            return $sitemapIndex->render();
        });

        return response($content, 200, ['Content-Type' => 'application/xml']);
    }

    public function posts(?int $page = null): Response
    {
        $cacheKey = 'sitemap:day-news:posts'.($page ? ":{$page}" : '');

        $content = Cache::remember($cacheKey, $this->getCacheTtl(), function () use ($page) {
            $sitemap = Sitemap::create();
            $baseUrl = 'https://'.config('domains.day-news');
            $perPage = $this->getPerPage();

            $query = DayNewsPost::published()
                ->orderBy('published_at', 'desc');

            if ($page !== null) {
                $query->offset(($page - 1) * $perPage)->limit($perPage);
            }

            $posts = $query->get();

            foreach ($posts as $post) {
                $sitemap->add(
                    Url::create("{$baseUrl}/posts/{$post->slug}")
                        ->setLastModificationDate($post->updated_at)
                        ->setChangeFrequency(Url::CHANGE_FREQUENCY_WEEKLY)
                        ->setPriority(0.8)
                );
            }

            return $sitemap->render();
        });

        return response($content, 200, ['Content-Type' => 'application/xml']);
    }

    public function static(): Response
    {
        $cacheKey = 'sitemap:day-news:static';

        $content = Cache::remember($cacheKey, $this->getCacheTtl(), function () {
            $sitemap = Sitemap::create();
            $baseUrl = 'https://'.config('domains.day-news');

            // Homepage
            $sitemap->add(
                Url::create($baseUrl)
                    ->setChangeFrequency(Url::CHANGE_FREQUENCY_DAILY)
                    ->setPriority(1.0)
            );

            return $sitemap->render();
        });

        return response($content, 200, ['Content-Type' => 'application/xml']);
    }

    public function regions(): Response
    {
        $cacheKey = 'sitemap:day-news:regions';

        $content = Cache::remember($cacheKey, $this->getCacheTtl(), function () {
            $sitemap = Sitemap::create();
            $baseUrl = 'https://'.config('domains.day-news');

            $regions = Region::active()
                ->orderBy('type', 'desc')
                ->orderBy('name')
                ->get();

            foreach ($regions as $region) {
                $sitemap->add(
                    Url::create("{$baseUrl}/{$region->slug}")
                        ->setChangeFrequency(Url::CHANGE_FREQUENCY_WEEKLY)
                        ->setPriority(0.9)
                );
            }

            return $sitemap->render();
        });

        return response($content, 200, ['Content-Type' => 'application/xml']);
    }

    private function getCacheTtl(): int
    {
        return config('sitemap.cache_ttl', 21600);
    }

    private function getPerPage(): int
    {
        return config('sitemap.per_page', 50000);
    }
}
```

### app/Http/Controllers/DayNews/ClassifiedController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Http\Requests\DayNews\StoreClassifiedRequest;
use App\Services\DayNews\ClassifiedService;
use App\Services\DayNewsPaymentService;
use App\Models\Classified;
use App\Models\ClassifiedPayment;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class ClassifiedController extends Controller
{
    public function __construct(
        private readonly ClassifiedService $classifiedService,
        private readonly DayNewsPaymentService $paymentService
    ) {}

    /**
     * Display classifieds listing
     */
    public function index(Request $request): Response
    {
        $currentRegion = $request->attributes->get('detected_region');
        $category = $request->get('category', 'all');
        $subcategory = $request->get('subcategory', 'all');
        $search = $request->get('search', '');

        $query = Classified::active()
            ->with(['user', 'images', 'regions'])
            ->orderBy('is_featured', 'desc')
            ->orderBy('posted_at', 'desc');

        // Filter by region
        if ($currentRegion) {
            $query->forRegion($currentRegion->id);
        }

        // Filter by category
        if ($category !== 'all') {
            $query->byCategory($category);
            if ($subcategory !== 'all') {
                $query->where('subcategory', $subcategory);
            }
        }

        // Search
        if ($search) {
            $query->where(function ($q) use ($search) {
                $q->where('title', 'like', "%{$search}%")
                    ->orWhere('description', 'like', "%{$search}%");
            });
        }

        $classifieds = $query->paginate(20)->withQueryString();

        return Inertia::render('day-news/classifieds/index', [
            'classifieds' => $classifieds,
            'filters' => [
                'category' => $category,
                'subcategory' => $subcategory,
                'search' => $search,
            ],
            'currentRegion' => $currentRegion,
        ]);
    }

    /**
     * Show classified creation form
     */
    public function create(): Response
    {
        return Inertia::render('day-news/classifieds/create');
    }

    /**
     * Store new classified (step 1: basic info)
     */
    public function store(StoreClassifiedRequest $request): \Illuminate\Http\RedirectResponse
    {
        $validated = $request->validated();

        $classified = $this->classifiedService->createListing(
            $validated,
            $request->user()->id,
            $request->user()->currentWorkspace
        );

        return redirect()
            ->route('day-news.classifieds.select-regions', $classified->id)
            ->with('success', 'Listing created! Now select regions.');
    }

    /**
     * Show region selection page
     */
    public function selectRegions(Classified $classified): Response
    {
        $this->authorize('update', $classified);

        $currentRegion = request()->attributes->get('detected_region');
        $regions = \App\Models\Region::where('type', 'city')
            ->orderBy('name')
            ->get()
            ->map(fn ($r) => [
                'id' => $r->id,
                'name' => $r->name,
                'type' => $r->type,
                'full_name' => $r->name . ($r->metadata['state'] ?? ''),
            ]);

        return Inertia::render('day-news/classifieds/select-regions', [
            'classified' => [
                'id' => $classified->id,
                'title' => $classified->title,
            ],
            'regions' => $regions,
            'currentRegion' => $currentRegion,
        ]);
    }

    /**
     * Store selected regions and show timeframe selection
     */
    public function storeRegions(Request $request, Classified $classified): \Illuminate\Http\RedirectResponse
    {
        $this->authorize('update', $classified);

        $validated = $request->validate([
            'region_ids' => 'required|array|min:1',
            'region_ids.*' => 'exists:regions,id',
        ]);

        // Store regions temporarily (will be finalized after payment)
        session(['classified_regions_' . $classified->id => $validated['region_ids']]);

        return redirect()
            ->route('day-news.classifieds.select-timeframe', $classified->id);
    }

    /**
     * Show timeframe selection page
     */
    public function selectTimeframe(Classified $classified): Response
    {
        $this->authorize('update', $classified);

        $regionIds = session('classified_regions_' . $classified->id, []);

        // Get region names for display
        $regions = \App\Models\Region::whereIn('id', $regionIds)->get();

        return Inertia::render('day-news/classifieds/select-timeframe', [
            'classified' => [
                'id' => $classified->id,
                'title' => $classified->title,
            ],
            'regionIds' => $regionIds,
            'regions' => $regions->map(fn ($r) => [
                'id' => $r->id,
                'name' => $r->name,
            ]),
        ]);
    }

    /**
     * Store timeframe and proceed to payment
     */
    public function storeTimeframe(Request $request, Classified $classified): \Illuminate\Http\RedirectResponse
    {
        $this->authorize('update', $classified);

        $validated = $request->validate([
            'days' => 'required|integer|min:1|max:90',
        ]);

        $regionIds = session('classified_regions_' . $classified->id, []);
        $regionsData = array_map(fn ($id) => ['region_id' => $id, 'days' => $validated['days']], $regionIds);

        $totalCost = $this->classifiedService->calculateCost($regionsData, $validated['days']);

        // Create payment record
        $payment = ClassifiedPayment::create([
            'classified_id' => $classified->id,
            'workspace_id' => $classified->workspace_id,
            'amount' => $totalCost,
            'status' => 'pending',
            'regions_data' => $regionsData,
            'total_days' => $validated['days'],
        ]);

        // Create Stripe checkout session
        $session = $this->paymentService->createClassifiedCheckoutSession(
            $classified,
            $payment,
            route('day-news.classifieds.payment.success', ['classified' => $classified->id]),
            route('day-news.classifieds.payment.cancel', ['classified' => $classified->id])
        );

        return Inertia::location($session->url);
    }

    /**
     * Display single classified
     */
    public function show(Request $request, Classified $classified): Response
    {
        $classified->load(['user', 'images', 'regions']);
        $classified->incrementViewsCount();

        // Get related classifieds
        $related = Classified::active()
            ->where('id', '!=', $classified->id)
            ->where('category', $classified->category)
            ->whereHas('regions', function ($q) use ($classified) {
                $q->whereIn('region_id', $classified->regions->pluck('id'));
            })
            ->with(['user', 'images'])
            ->limit(6)
            ->get()
            ->map(fn ($item) => [
                'id' => $item->id,
                'title' => $item->title,
                'description' => $item->description,
                'price' => $item->price,
                'price_type' => $item->price_type,
                'images' => $item->images->map(fn ($img) => [
                    'id' => $img->id,
                    'image_url' => $img->image_url,
                ]),
            ]);

        return Inertia::render('day-news/classifieds/show', [
            'classified' => [
                'id' => $classified->id,
                'category' => $classified->category,
                'subcategory' => $classified->subcategory,
                'title' => $classified->title,
                'description' => $classified->description,
                'price' => $classified->price,
                'price_type' => $classified->price_type,
                'condition' => $classified->condition,
                'location' => $classified->location,
                'is_featured' => $classified->is_featured,
                'posted_at' => $classified->posted_at?->toISOString(),
                'expires_at' => $classified->expires_at?->toISOString(),
                'views_count' => $classified->views_count,
                'images' => $classified->images->map(fn ($img) => [
                    'id' => $img->id,
                    'image_url' => $img->image_url,
                ]),
                'user' => [
                    'id' => $classified->user->id,
                    'name' => $classified->user->name,
                ],
                'regions' => $classified->regions->map(fn ($r) => [
                    'id' => $r->id,
                    'name' => $r->name,
                ]),
            ],
            'related' => $related,
        ]);
    }

    /**
     * Payment success callback
     */
    public function paymentSuccess(Request $request, Classified $classified): \Illuminate\Http\RedirectResponse
    {
        $sessionId = $request->get('session_id');

        if (!$sessionId) {
            return redirect()
                ->route('day-news.classifieds.index')
                ->with('error', 'Invalid payment session');
        }

        $payment = ClassifiedPayment::where('classified_id', $classified->id)
            ->where('stripe_checkout_session_id', $sessionId)
            ->firstOrFail();

        // Verify payment via Stripe
        $classified = $this->paymentService->handleSuccessfulClassifiedPayment($sessionId);
        $payment = $classified->payment;

        if ($payment && $payment->isPaid()) {
            // Activate classified
            $this->classifiedService->activateClassified(
                $classified,
                $payment->regions_data,
                $payment->total_days
            );

            // Clear session data
            session()->forget('classified_regions_' . $classified->id);

            return redirect()
                ->route('day-news.classifieds.confirmation', $classified->id)
                ->with('success', 'Payment successful! Your listing is now active.');
        }

        return redirect()
            ->route('day-news.classifieds.select-timeframe', $classified->id)
            ->with('error', 'Payment not completed. Please try again.');
    }

    /**
     * Payment cancel callback
     */
    public function paymentCancel(Classified $classified): \Illuminate\Http\RedirectResponse
    {
        return redirect()
            ->route('day-news.classifieds.select-timeframe', $classified->id)
            ->with('info', 'Payment cancelled. You can try again.');
    }

    /**
     * Show confirmation page
     */
    public function confirmation(Classified $classified): Response
    {
        $classified->load(['regions', 'payment']);

        return Inertia::render('day-news/classifieds/confirmation', [
            'classified' => [
                'id' => $classified->id,
                'title' => $classified->title,
                'regions' => $classified->regions->map(fn ($r) => [
                    'id' => $r->id,
                    'name' => $r->name,
                ]),
                'payment' => $classified->payment ? [
                    'amount' => $classified->payment->amount,
                    'total_days' => $classified->payment->total_days,
                ] : null,
            ],
        ]);
    }
}

```

### app/Http/Controllers/DayNews/PublicPostController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Models\ArticleComment;
use App\Models\DayNewsPost;
use App\Models\Region;
use App\Services\AdvertisementService;
use App\Services\LocationService;
use App\Services\SeoService;
use Inertia\Inertia;
use Inertia\Response;

final class PublicPostController extends Controller
{
    public function __construct(
        private readonly AdvertisementService $advertisementService,
        private readonly LocationService $locationService
    ) {}
    public function show(string $slug): Response
    {
        $post = DayNewsPost::where('slug', $slug)
            ->published()
            ->with(['author', 'writerAgent', 'regions', 'workspace', 'comments.user'])
            ->withCount(['comments' => function ($q) {
                $q->where('is_active', true);
            }])
            ->firstOrFail();

        $post->incrementViewCount();

        // Get comments (top level only, replies loaded separately)
        $comments = $post->comments()
            ->where('is_active', true)
            ->whereNull('parent_id')
            ->with(['user', 'replies.user', 'replies.likes'])
            ->withCount(['likes', 'replies'])
            ->orderBy('is_pinned', 'desc')
            ->orderBy('created_at', 'desc')
            ->get()
            ->map(function ($comment) use ($post) {
                return [
                    'id' => $comment->id,
                    'content' => $comment->content,
                    'user' => [
                        'id' => $comment->user->id,
                        'name' => $comment->user->name,
                        'avatar' => $comment->user->profile_photo_url ?? null,
                    ],
                    'created_at' => $comment->created_at->toISOString(),
                    'time_ago' => $comment->created_at->diffForHumans(),
                    'likes_count' => $comment->likes_count,
                    'replies_count' => $comment->replies_count,
                    'is_liked_by_user' => false, // Will be set on frontend if user is logged in
                    'is_pinned' => $comment->is_pinned,
                    'replies' => $comment->replies->map(function ($reply) {
                        return [
                            'id' => $reply->id,
                            'content' => $reply->content,
                            'user' => [
                                'id' => $reply->user->id,
                                'name' => $reply->user->name,
                                'avatar' => $reply->user->profile_photo_url ?? null,
                            ],
                            'created_at' => $reply->created_at->toISOString(),
                            'time_ago' => $reply->created_at->diffForHumans(),
                            'likes_count' => $reply->likes()->count(),
                            'is_liked_by_user' => false,
                        ];
                    }),
                ];
            });

        // Get related posts from the same region(s) and category
        $regionIds = $post->regions->pluck('id')->toArray();
        $relatedPosts = DayNewsPost::published()
            ->where('id', '!=', $post->id)
            ->where(function ($q) use ($regionIds, $post) {
                $q->whereHas('regions', function ($regionQuery) use ($regionIds) {
                    $regionQuery->whereIn('regions.id', $regionIds);
                })
                ->when($post->category, function ($categoryQuery) use ($post) {
                    $categoryQuery->orWhere('category', $post->category);
                });
            })
            ->with(['author', 'writerAgent', 'regions', 'workspace'])
            ->orderBy('published_at', 'desc')
            ->limit(5)
            ->get();

        // Get previous and next articles
        $previousPost = DayNewsPost::published()
            ->where('id', '<', $post->id)
            ->whereHas('regions', function ($q) use ($regionIds) {
                $q->whereIn('regions.id', $regionIds);
            })
            ->orderBy('id', 'desc')
            ->first();

        $nextPost = DayNewsPost::published()
            ->where('id', '>', $post->id)
            ->whereHas('regions', function ($q) use ($regionIds) {
                $q->whereIn('regions.id', $regionIds);
            })
            ->orderBy('id', 'asc')
            ->first();

        // Build SEO JSON-LD data
        $plainTextContent = strip_tags($post->content);
        $seoData = [
            'title' => $post->title,
            'description' => $post->excerpt,
            'image' => $post->featured_image,
            'url' => "/posts/{$post->slug}",
            'publishedAt' => $post->published_at?->toISOString(),
            'author' => $post->display_author,
            'section' => $post->category,
            'articleBody' => $plainTextContent,
        ];

        // Get current region for ad targeting
        $region = $post->regions->first();

        // Get advertisements for different placements
        $bannerAds = $this->advertisementService->getActiveAds('day_news', $region, 'banner')->take(1);
        $sidebarAds = $this->advertisementService->getActiveAds('day_news', $region, 'sidebar')->take(3);
        $inlineAds = $this->advertisementService->getActiveAds('day_news', $region, 'inline')->take(3);

        return Inertia::render('day-news/posts/show', [
            'seo' => [
                'jsonLd' => SeoService::buildJsonLd('article', $seoData, 'day-news'),
            ],
            'post' => [
                'id' => $post->id,
                'type' => $post->type,
                'category' => $post->category,
                'title' => $post->title,
                'slug' => $post->slug,
                'content' => $post->content,
                'excerpt' => $post->excerpt,
                'featured_image' => $post->featured_image,
                'metadata' => $post->metadata,
                'view_count' => $post->view_count,
                'published_at' => $post->published_at?->toISOString(),
                'author' => $post->author ? [
                    'id' => $post->author->id,
                    'name' => $post->author->name,
                ] : null,
                'writer_agent' => $post->writerAgent ? [
                    'id' => $post->writerAgent->id,
                    'name' => $post->writerAgent->name,
                    'avatar' => $post->writerAgent->avatar_url,
                    'bio' => $post->writerAgent->bio,
                ] : null,
                'workspace' => $post->workspace ? [
                    'id' => $post->workspace->id,
                    'name' => $post->workspace->name,
                ] : null,
                'regions' => $post->regions->map(fn ($r) => [
                    'id' => $r->id,
                    'name' => $r->name,
                ]),
            ],
            'comments' => $comments,
            'commentsCount' => $post->comments_count,
            'previousPost' => $previousPost ? [
                'id' => $previousPost->id,
                'title' => $previousPost->title,
                'slug' => $previousPost->slug,
            ] : null,
            'nextPost' => $nextPost ? [
                'id' => $nextPost->id,
                'title' => $nextPost->title,
                'slug' => $nextPost->slug,
            ] : null,
            'relatedPosts' => $relatedPosts->map(fn ($relatedPost) => [
                'id' => $relatedPost->id,
                'type' => $relatedPost->type,
                'category' => $relatedPost->category,
                'title' => $relatedPost->title,
                'slug' => $relatedPost->slug,
                'excerpt' => $relatedPost->excerpt,
                'featured_image' => $relatedPost->featured_image,
                'published_at' => $relatedPost->published_at?->toISOString(),
                'view_count' => $relatedPost->view_count,
                'author' => $relatedPost->author ? [
                    'id' => $relatedPost->author->id,
                    'name' => $relatedPost->author->name,
                ] : null,
                'writer_agent' => $relatedPost->writerAgent ? [
                    'id' => $relatedPost->writerAgent->id,
                    'name' => $relatedPost->writerAgent->name,
                    'avatar' => $relatedPost->writerAgent->avatar_url,
                ] : null,
                'workspace' => $relatedPost->workspace ? [
                    'id' => $relatedPost->workspace->id,
                    'name' => $relatedPost->workspace->name,
                ] : null,
                'regions' => $relatedPost->regions->map(fn ($r) => [
                    'id' => $r->id,
                    'name' => $r->name,
                ]),
            ]),
            'advertisements' => [
                'banner' => $bannerAds->map(fn ($ad) => [
                    'id' => $ad->id,
                    'placement' => $ad->placement,
                    'advertable' => [
                        'id' => $ad->advertable->id,
                        'title' => $ad->advertable->title,
                        'excerpt' => $ad->advertable->excerpt,
                        'featured_image' => $ad->advertable->featured_image,
                        'slug' => $ad->advertable->slug,
                    ],
                    'expires_at' => $ad->expires_at->toISOString(),
                ]),
                'sidebar' => $sidebarAds->map(fn ($ad) => [
                    'id' => $ad->id,
                    'placement' => $ad->placement,
                    'advertable' => [
                        'id' => $ad->advertable->id,
                        'title' => $ad->advertable->title,
                        'excerpt' => $ad->advertable->excerpt,
                        'featured_image' => $ad->advertable->featured_image,
                        'slug' => $ad->advertable->slug,
                    ],
                    'expires_at' => $ad->expires_at->toISOString(),
                ]),
                'inline' => $inlineAds->map(fn ($ad) => [
                    'id' => $ad->id,
                    'placement' => $ad->placement,
                    'advertable' => [
                        'id' => $ad->advertable->id,
                        'title' => $ad->advertable->title,
                        'excerpt' => $ad->advertable->excerpt,
                        'featured_image' => $ad->advertable->featured_image,
                        'slug' => $ad->advertable->slug,
                    ],
                    'expires_at' => $ad->expires_at->toISOString(),
                ]),
            ],
        ]);
    }
}
```

### app/Http/Controllers/DayNews/TagController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Models\DayNewsPost;
use App\Models\Follow;
use App\Models\Tag;
use App\Services\DayNews\TagService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class TagController extends Controller
{
    public function __construct(
        private readonly TagService $tagService
    ) {}

    /**
     * Display tag page
     */
    public function show(Request $request, string $slug): Response
    {
        $tag = Tag::where('slug', $slug)->firstOrFail();

        // Get content tagged with this tag
        $content = DayNewsPost::published()
            ->whereHas('tags', function ($q) use ($tag) {
                $q->where('tags.id', $tag->id);
            })
            ->with(['author', 'regions'])
            ->orderBy('published_at', 'desc')
            ->limit(20)
            ->get()
            ->map(function ($post) {
                return [
                    'id' => (string) $post->id,
                    'type' => 'article',
                    'title' => $post->title,
                    'excerpt' => $post->excerpt,
                    'image' => $post->featured_image,
                    'published_at' => $post->published_at?->toISOString(),
                    'author' => $post->author ? [
                        'name' => $post->author->name,
                        'avatar' => $post->author->profile_photo_url ?? null,
                    ] : null,
                    'slug' => $post->slug,
                    'engagement' => [
                        'likes' => 0, // TODO: Add likes count
                        'comments' => $post->comments()->count(),
                    ],
                    'tags' => $post->tags->pluck('slug')->toArray(),
                ];
            });

        // Get related tags using TagService
        $relatedTags = $this->tagService->getRelatedTags($tag, 10);

        // Get top contributors (users who wrote articles with this tag)
        $topContributors = \App\Models\User::whereHas('posts', function ($q) use ($tag) {
            $q->whereHas('tags', function ($tagQuery) use ($tag) {
                $tagQuery->where('tags.id', $tag->id);
            });
        })
            ->withCount(['posts' => function ($q) use ($tag) {
                $q->whereHas('tags', function ($tagQuery) use ($tag) {
                    $tagQuery->where('tags.id', $tag->id);
                });
            }])
            ->orderBy('posts_count', 'desc')
            ->limit(5)
            ->get()
            ->map(fn ($user) => [
                'id' => $user->id,
                'name' => $user->name,
                'avatar' => $user->profile_photo_url ?? null,
                'articles' => $user->posts_count,
                'followers' => 0, // TODO: Add follower count
            ]);

        // Check if user is following this tag
        $isFollowing = false;
        if ($request->user()) {
            $isFollowing = Follow::where('user_id', $request->user()->id)
                ->where('followable_type', Tag::class)
                ->where('followable_id', $tag->id)
                ->exists();
        }

        // Get tag analytics
        $analytics = $this->tagService->getTagAnalytics($tag, 30);

        return Inertia::render('day-news/tags/show', [
            'tag' => [
                'id' => $tag->id,
                'name' => $tag->name,
                'slug' => $tag->slug,
                'description' => $tag->description ?? '',
                'article_count' => $tag->posts()->count(),
                'followers' => $tag->followers()->count(),
                'is_trending' => $tag->is_trending ?? false,
                'trending_score' => $tag->trending_score ?? 0,
                'created_at' => $tag->created_at->toISOString(),
                'related_tags' => $relatedTags,
                'top_contributors' => $topContributors,
                'analytics' => $analytics,
            ],
            'content' => $content,
            'isFollowing' => $isFollowing,
        ]);
    }
}

```

### app/Http/Controllers/DayNews/AnnouncementController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Http\Requests\DayNews\StoreAnnouncementRequest;
use App\Http\Requests\DayNews\UpdateAnnouncementRequest;
use App\Models\Announcement;
use App\Models\Region;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class AnnouncementController extends Controller
{
    /**
     * Display announcements listing
     */
    public function index(Request $request): Response
    {
        $currentRegion = $request->attributes->get('detected_region');
        $type = $request->get('type', 'all');
        $search = $request->get('search', '');

        $query = Announcement::published()
            ->with(['user', 'regions'])
            ->orderBy('published_at', 'desc');

        // Filter by region
        if ($currentRegion) {
            $query->forRegion($currentRegion->id);
        }

        // Filter by type
        if ($type !== 'all') {
            $query->byType($type);
        }

        // Search
        if ($search) {
            $query->where(function ($q) use ($search) {
                $q->where('title', 'like', "%{$search}%")
                    ->orWhere('content', 'like', "%{$search}%");
            });
        }

        $announcements = $query->paginate(20)->withQueryString();

        // Get featured announcement (most reactions)
        $featured = Announcement::published()
            ->when($currentRegion, function ($q) use ($currentRegion) {
                $q->forRegion($currentRegion->id);
            })
            ->orderBy('reactions_count', 'desc')
            ->with(['user', 'regions'])
            ->first();

        return Inertia::render('day-news/announcements/index', [
            'announcements' => $announcements,
            'featured' => $featured,
            'filters' => [
                'type' => $type,
                'search' => $search,
            ],
            'currentRegion' => $currentRegion,
        ]);
    }

    /**
     * Show announcement creation form
     */
    public function create(): Response
    {
        return Inertia::render('day-news/announcements/create');
    }

    /**
     * Store new announcement
     */
    public function store(StoreAnnouncementRequest $request): \Illuminate\Http\RedirectResponse
    {
        $validated = $request->validated();

        $announcement = Announcement::create([
            'user_id' => $request->user()->id,
            'workspace_id' => $request->user()->currentWorkspace?->id,
            'type' => $validated['type'],
            'title' => $validated['title'],
            'content' => $validated['content'],
            'location' => $validated['location'] ?? null,
            'event_date' => $validated['event_date'] ?? null,
            'status' => 'published', // Announcements are free to publish
            'published_at' => now(),
        ]);

        // Handle image upload
        if ($request->hasFile('image')) {
            $path = $request->file('image')->store('announcements', 'public');
            $announcement->update(['image' => $path]);
        }

        // Attach regions
        if (!empty($validated['region_ids'])) {
            $announcement->regions()->attach($validated['region_ids']);
        } elseif ($currentRegion = $request->attributes->get('detected_region')) {
            $announcement->regions()->attach($currentRegion->id);
        }

        return redirect()
            ->route('day-news.announcements.show', $announcement->id)
            ->with('success', 'Announcement published successfully!');
    }

    /**
     * Display single announcement
     */
    public function show(Request $request, Announcement $announcement): Response
    {
        $announcement->load(['user', 'regions', 'ratings', 'reviews']);
        $announcement->incrementViewsCount();

        // Get related announcements
        $related = Announcement::published()
            ->where('id', '!=', $announcement->id)
            ->where('type', $announcement->type)
            ->whereHas('regions', function ($q) use ($announcement) {
                $q->whereIn('region_id', $announcement->regions->pluck('id'));
            })
            ->with(['user', 'regions'])
            ->limit(6)
            ->get();

        return Inertia::render('day-news/announcements/show', [
            'announcement' => [
                'id' => $announcement->id,
                'type' => $announcement->type,
                'title' => $announcement->title,
                'content' => $announcement->content,
                'image' => $announcement->image,
                'location' => $announcement->location,
                'event_date' => $announcement->event_date?->toDateString(),
                'published_at' => $announcement->published_at?->toISOString(),
                'views_count' => $announcement->views_count,
                'reactions_count' => $announcement->reactions_count,
                'comments_count' => $announcement->comments_count,
                'user' => [
                    'id' => $announcement->user->id,
                    'name' => $announcement->user->name,
                    'avatar' => $announcement->user->profile_photo_url ?? null,
                ],
                'regions' => $announcement->regions->map(fn ($r) => [
                    'id' => $r->id,
                    'name' => $r->name,
                ]),
            ],
            'related' => $related->map(fn ($item) => [
                'id' => $item->id,
                'title' => $item->title,
                'content' => $item->content,
                'image' => $item->image,
            ]),
        ]);
    }

    /**
     * Show edit form
     */
    public function edit(Announcement $announcement): Response
    {
        $this->authorize('update', $announcement);

        $announcement->load(['regions']);

        return Inertia::render('day-news/announcements/edit', [
            'announcement' => $announcement,
        ]);
    }

    /**
     * Update announcement
     */
    public function update(UpdateAnnouncementRequest $request, Announcement $announcement): \Illuminate\Http\RedirectResponse
    {
        $validated = $request->validated();

        $announcement->update($validated);

        // Handle image upload
        if ($request->hasFile('image')) {
            $path = $request->file('image')->store('announcements', 'public');
            $announcement->update(['image' => $path]);
        }

        // Update regions
        if (isset($validated['region_ids'])) {
            $announcement->regions()->sync($validated['region_ids']);
        }

        return redirect()
            ->route('day-news.announcements.show', $announcement->id)
            ->with('success', 'Announcement updated successfully!');
    }

    /**
     * Delete announcement
     */
    public function destroy(Announcement $announcement): \Illuminate\Http\RedirectResponse
    {
        $this->authorize('delete', $announcement);

        $announcement->delete();

        return redirect()
            ->route('day-news.announcements.index')
            ->with('success', 'Announcement deleted successfully!');
    }
}

```

### app/Http/Controllers/DayNews/ArticleCommentController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Models\ArticleComment;
use App\Models\ArticleCommentLike;
use App\Models\CommentReport;
use App\Models\DayNewsPost;
use App\Models\SocialActivity;
use App\Notifications\DayNews\ArticleCommented;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;

final class ArticleCommentController extends Controller
{
    /**
     * Get comments for an article
     */
    public function index(Request $request, DayNewsPost $post): JsonResponse
    {
        $sortBy = $request->get('sort', 'best'); // best, newest, oldest
        $includeReplies = $request->boolean('include_replies', true);

        $query = ArticleComment::where('article_id', $post->id)
            ->active()
            ->topLevel()
            ->with(['user'])
            ->withCount(['likes', 'replies']);

        // Apply sorting
        match ($sortBy) {
            'best' => $query->best(),
            'newest' => $query->newest(),
            'oldest' => $query->oldest(),
            default => $query->best(),
        };

        // Load replies if requested
        if ($includeReplies) {
            $query->with(['replies' => function ($q) {
                $q->active()->with(['user'])->withCount('likes')->orderBy('created_at', 'asc');
            }]);
        }

        $comments = $query->get()->map(function ($comment) use ($request) {
            return [
                'id' => $comment->id,
                'content' => $comment->content,
                'user' => [
                    'id' => $comment->user->id,
                    'name' => $comment->user->name,
                    'avatar' => $comment->user->profile_photo_url ?? null,
                ],
                'created_at' => $comment->created_at->toISOString(),
                'time_ago' => $comment->created_at->diffForHumans(),
                'likes_count' => $comment->likes_count,
                'replies_count' => $comment->replies_count,
                'is_liked_by_user' => $request->user() ? $comment->isLikedBy($request->user()) : false,
                'is_pinned' => $comment->is_pinned,
                'replies' => $comment->replies->map(function ($reply) use ($request) {
                    return [
                        'id' => $reply->id,
                        'content' => $reply->content,
                        'user' => [
                            'id' => $reply->user->id,
                            'name' => $reply->user->name,
                            'avatar' => $reply->user->profile_photo_url ?? null,
                        ],
                        'created_at' => $reply->created_at->toISOString(),
                        'time_ago' => $reply->created_at->diffForHumans(),
                        'likes_count' => $reply->likes()->count(),
                        'is_liked_by_user' => $request->user() ? $reply->isLikedBy($request->user()) : false,
                    ];
                }),
            ];
        });

        return response()->json([
            'comments' => $comments,
            'total' => ArticleComment::where('article_id', $post->id)->active()->count(),
        ]);
    }

    /**
     * Store a new comment
     */
    public function store(Request $request, DayNewsPost $post): JsonResponse
    {
        $validated = $request->validate([
            'content' => 'required|string|max:5000',
            'parent_id' => 'nullable|uuid|exists:article_comments,id',
        ]);

        $comment = ArticleComment::create([
            'article_id' => $post->id,
            'user_id' => $request->user()->id,
            'parent_id' => $validated['parent_id'] ?? null,
            'content' => $validated['content'],
        ]);

        $comment->load(['user', 'replies']);

        // Create activity
        SocialActivity::create([
            'user_id' => $post->author_id ?? $post->workspace_id, // Notify article author
            'actor_id' => $request->user()->id,
            'type' => 'article_comment',
            'subject_type' => ArticleComment::class,
            'subject_id' => $comment->id,
            'data' => [
                'article_id' => $post->id,
                'article_title' => $post->title,
            ],
        ]);

        // Send notification to article author
        if ($post->author) {
            $post->author->notify(new ArticleCommented($post, $request->user()));
        }

        return response()->json([
            'comment' => [
                'id' => $comment->id,
                'content' => $comment->content,
                'user' => [
                    'id' => $comment->user->id,
                    'name' => $comment->user->name,
                    'avatar' => $comment->user->profile_photo_url ?? null,
                ],
                'created_at' => $comment->created_at->toISOString(),
                'time_ago' => $comment->created_at->diffForHumans(),
                'likes_count' => 0,
                'replies_count' => 0,
                'is_liked_by_user' => false,
            ],
        ], 201);
    }

    /**
     * Update a comment
     */
    public function update(Request $request, ArticleComment $comment): JsonResponse
    {
        $this->authorize('update', $comment);

        $validated = $request->validate([
            'content' => 'required|string|max:5000',
        ]);

        $comment->update($validated);

        return response()->json([
            'comment' => $comment->fresh(['user']),
        ]);
    }

    /**
     * Delete a comment
     */
    public function destroy(ArticleComment $comment): JsonResponse
    {
        $this->authorize('delete', $comment);

        $comment->delete();

        return response()->json(['message' => 'Comment deleted successfully']);
    }

    /**
     * Like/unlike a comment
     */
    public function toggleLike(Request $request, ArticleComment $comment): JsonResponse
    {
        $like = ArticleCommentLike::where('comment_id', $comment->id)
            ->where('user_id', $request->user()->id)
            ->first();

        if ($like) {
            $like->delete();
            $liked = false;
        } else {
            ArticleCommentLike::create([
                'comment_id' => $comment->id,
                'user_id' => $request->user()->id,
            ]);
            $liked = true;
        }

        return response()->json([
            'liked' => $liked,
            'likes_count' => $comment->likes()->count(),
        ]);
    }

    /**
     * Report a comment
     */
    public function report(Request $request, ArticleComment $comment): JsonResponse
    {
        $validated = $request->validate([
            'reason' => 'required|string|in:spam,harassment,inappropriate,other',
            'details' => 'nullable|string|max:1000',
        ]);

        // Check if user already reported this comment
        $existingReport = CommentReport::where('comment_id', $comment->id)
            ->where('user_id', $request->user()->id)
            ->first();

        if ($existingReport) {
            return response()->json(['message' => 'You have already reported this comment'], 422);
        }

        // Create report
        CommentReport::create([
            'comment_id' => $comment->id,
            'user_id' => $request->user()->id,
            'reason' => $validated['reason'],
            'details' => $validated['details'] ?? null,
            'status' => 'pending',
        ]);

        $comment->increment('reports_count');

        // If reports exceed threshold, auto-hide comment
        if ($comment->fresh()->reports_count >= 5) {
            $comment->update(['is_active' => false]);
            
            // Notify admins
            // TODO: Send notification to admin users
        }

        return response()->json(['message' => 'Comment reported successfully']);
    }

    /**
     * Pin/unpin a comment (admin only)
     */
    public function togglePin(Request $request, ArticleComment $comment): JsonResponse
    {
        $request->user()->can('moderate', ArticleComment::class) || abort(403);

        $comment->update(['is_pinned' => !$comment->is_pinned]);

        return response()->json([
            'pinned' => $comment->is_pinned,
            'message' => $comment->is_pinned ? 'Comment pinned' : 'Comment unpinned',
        ]);
    }

    /**
     * Moderate comment (admin only)
     */
    public function moderate(Request $request, ArticleComment $comment): JsonResponse
    {
        $request->user()->can('moderate', ArticleComment::class) || abort(403);

        $validated = $request->validate([
            'action' => 'required|string|in:hide,show,delete',
        ]);

        match ($validated['action']) {
            'hide' => $comment->update(['is_active' => false]),
            'show' => $comment->update(['is_active' => true]),
            'delete' => $comment->delete(),
        };

        // Update report statuses
        if ($validated['action'] !== 'delete') {
            CommentReport::where('comment_id', $comment->id)
                ->update(['status' => 'resolved']);
        }

        return response()->json(['message' => 'Comment moderated successfully']);
    }
}

```

### app/Http/Controllers/DayNews/MemorialController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Models\Memorial;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class MemorialController extends Controller
{
    /**
     * Display memorials listing
     */
    public function index(Request $request): Response
    {
        $currentRegion = $request->attributes->get('detected_region');
        $search = $request->get('search', '');
        $dateFilter = $request->get('date_filter', 'all');

        $query = Memorial::published()
            ->with(['user', 'regions'])
            ->orderBy('date_of_passing', 'desc');

        // Filter by region
        if ($currentRegion) {
            $query->forRegion($currentRegion->id);
        }

        // Date filter
        if ($dateFilter !== 'all') {
            match ($dateFilter) {
                'week' => $query->where('date_of_passing', '>=', now()->subWeek()),
                'month' => $query->where('date_of_passing', '>=', now()->subMonth()),
                'year' => $query->where('date_of_passing', '>=', now()->subYear()),
                default => null,
            };
        }

        // Search
        if ($search) {
            $query->where(function ($q) use ($search) {
                $q->where('name', 'like', "%{$search}%")
                    ->orWhere('obituary', 'like', "%{$search}%");
            });
        }

        $memorials = $query->paginate(20)->withQueryString();

        // Get featured memorial
        $featured = Memorial::published()
            ->featured()
            ->when($currentRegion, function ($q) use ($currentRegion) {
                $q->forRegion($currentRegion->id);
            })
            ->with(['user', 'regions'])
            ->orderBy('date_of_passing', 'desc')
            ->first();

        return Inertia::render('day-news/memorials/index', [
            'memorials' => $memorials,
            'featured' => $featured,
            'filters' => [
                'search' => $search,
                'date_filter' => $dateFilter,
            ],
            'currentRegion' => $currentRegion,
        ]);
    }

    /**
     * Show memorial creation form
     */
    public function create(): Response
    {
        return Inertia::render('day-news/memorials/create');
    }

    /**
     * Store new memorial
     */
    public function store(\App\Http\Requests\DayNews\StoreMemorialRequest $request): \Illuminate\Http\RedirectResponse
    {
        $validated = $request->validated();

        $memorial = Memorial::create([
            'user_id' => $request->user()->id,
            'workspace_id' => $request->user()->currentWorkspace?->id,
            'name' => $validated['name'],
            'years' => $validated['years'],
            'date_of_passing' => $validated['date_of_passing'],
            'obituary' => $validated['obituary'],
            'location' => $validated['location'] ?? null,
            'service_date' => $validated['service_date'] ?? null,
            'service_location' => $validated['service_location'] ?? null,
            'service_details' => $validated['service_details'] ?? null,
            'status' => 'published',
            'published_at' => now(),
        ]);

        // Handle image upload
        if ($request->hasFile('image')) {
            $path = $request->file('image')->store('memorials', 'public');
            $memorial->update(['image' => $path]);
        }

        // Attach regions
        if (!empty($validated['region_ids'])) {
            $memorial->regions()->attach($validated['region_ids']);
        } else {
            $currentRegion = $request->attributes->get('detected_region');
            if ($currentRegion) {
                $memorial->regions()->attach($currentRegion->id);
            }
        }

        return redirect()
            ->route('day-news.memorials.show', $memorial->id)
            ->with('success', 'Memorial published successfully!');
    }

    /**
     * Display single memorial
     */
    public function show(Request $request, Memorial $memorial): Response
    {
        $memorial->load(['user', 'regions']);
        $memorial->incrementViewsCount();

        return Inertia::render('day-news/memorials/show', [
            'memorial' => $memorial,
        ]);
    }
}

```

### app/Http/Controllers/DayNews/BusinessController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\DayNews;

use App\Http\Controllers\Controller;
use App\Models\Business;
use App\Models\DayNewsPost;
use App\Services\BusinessService;
use App\Services\NewsService;
use App\Services\OrganizationService;
use App\Services\ReviewService;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class BusinessController extends Controller
{
    public function __construct(
        private readonly BusinessService $businessService,
        private readonly NewsService $newsService,
        private readonly ReviewService $reviewService,
        private readonly OrganizationService $organizationService
    ) {}

    /**
     * Display business directory for Day News
     * Unique positioning: "Local Business News & Community Directory"
     */
    public function index(Request $request): Response
    {
        $currentRegion = $request->attributes->get('detected_region');

        // Use shared BusinessService with DayNews-specific filters
        $filters = [
            'region_id' => $currentRegion?->id,
            'category' => $request->input('category'),
            'status' => 'active',
            'is_verified' => $request->boolean('verified_only') ? true : null,
            'sort_by' => $request->get('sort', 'name'),
            'sort_order' => $request->get('direction', 'asc'),
        ];

        $businesses = $this->businessService->search(
            $request->input('search'),
            $filters,
            20,
            (int) $request->input('page', 1)
        );

        // Get featured businesses with recent news
        $featuredBusinesses = $this->businessService->getFeatured(6);
        $featuredWithNews = $featuredBusinesses->map(function ($business) {
            $recentArticles = DayNewsPost::published()
                ->whereHas('organizationRelationships', function ($q) use ($business) {
                    $q->where('organization_id', $business->id);
                })
                ->orWhereHas('regions', function ($q) use ($business) {
                    $q->whereIn('regions.id', $business->regions->pluck('id'));
                })
                ->orderBy('published_at', 'desc')
                ->limit(3)
                ->get();

            return [
                'business' => $business,
                'recent_articles_count' => $recentArticles->count(),
                'latest_article' => $recentArticles->first(),
            ];
        });

        return Inertia::render('day-news/businesses/index', [
            'businesses' => $businesses,
            'featuredBusinesses' => $featuredWithNews,
            'filters' => $request->only(['search', 'category', 'verified_only']),
            'sort' => ['sort' => $filters['sort_by'], 'direction' => $filters['sort_order']],
            'currentRegion' => $currentRegion,
            'platform' => 'daynews', // For theme differentiation
        ]);
    }

    /**
     * Display a single business with DayNews-specific context
     */
    public function show(Request $request, Business $business): Response
    {
        $business = $this->businessService->find($business->id);
        
        if (!$business) {
            abort(404);
        }

        // Get news articles related to this business
        $relatedArticles = $this->newsService->getPublished([
            'region_id' => $business->regions->first()?->id,
        ], 6)->items();

        // Get articles directly related via organization relationships
        $organizationArticles = DayNewsPost::published()
            ->whereHas('organizationRelationships', function ($q) use ($business) {
                $q->where('organization_id', $business->id)
                  ->where('relatable_type', DayNewsPost::class);
            })
            ->with(['author', 'regions'])
            ->orderBy('published_at', 'desc')
            ->limit(10)
            ->get();

        // Get reviews
        $reviews = $this->reviewService->getForModel($business, ['status' => 'approved'], 10);
        $averageRating = $this->reviewService->getAverageRating($business);

        // Get organization relationships
        $organizationContent = $this->organizationService->getOrganizationContent($business, [
            'App\Models\DayNewsPost',
            'App\Models\Event',
            'App\Models\Coupon',
        ]);

        // Get related businesses (same region, similar category)
        $relatedBusinesses = $this->businessService->getByRegion(
            $business->regions->first(),
            6
        )->filter(fn ($b) => $b->id !== $business->id);

        return Inertia::render('day-news/businesses/show', [
            'business' => $business,
            'relatedArticles' => $organizationArticles->merge($relatedArticles),
            'reviews' => $reviews,
            'averageRating' => $averageRating,
            'organizationContent' => $organizationContent,
            'relatedBusinesses' => $relatedBusinesses,
            'platform' => 'daynews', // For theme differentiation
        ]);
    }
}

```

### app/Http/Controllers/Email/TrackingController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers\Email;

use App\Http\Controllers\Controller;
use App\Models\EmailSend;
use App\Models\EmailSubscriber;
use App\Services\EmailDeliveryService;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class TrackingController extends Controller
{
    public function __construct(
        private readonly EmailDeliveryService $emailService
    ) {}

    /**
     * Track email open
     */
    public function trackOpen(EmailSend $send): \Illuminate\Http\Response
    {
        $this->emailService->trackOpen($send);

        // Return 1x1 transparent pixel
        $pixel = base64_decode('R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7');

        return response($pixel, 200)
            ->header('Content-Type', 'image/gif')
            ->header('Cache-Control', 'no-cache, no-store, must-revalidate')
            ->header('Pragma', 'no-cache')
            ->header('Expires', '0');
    }

    /**
     * Track email click
     */
    public function trackClick(Request $request, EmailSend $send): RedirectResponse
    {
        $url = $request->query('url');
        if (!$url) {
            return redirect('/');
        }

        $destinationUrl = $this->emailService->trackClick($send, $url);

        return redirect($destinationUrl);
    }

    /**
     * Unsubscribe page
     */
    public function unsubscribe(EmailSubscriber $subscriber): Response
    {
        return Inertia::render('Email/Unsubscribe', [
            'subscriber' => $subscriber,
        ]);
    }

    /**
     * Process unsubscribe
     */
    public function processUnsubscribe(Request $request, EmailSubscriber $subscriber): RedirectResponse
    {
        $validated = $request->validate([
            'reason' => 'nullable|string|max:255',
        ]);

        $subscriber->update([
            'status' => 'unsubscribed',
            'unsubscribed_at' => now(),
            'unsubscribe_reason' => $validated['reason'] ?? null,
        ]);

        return redirect()->route('email.unsubscribe', $subscriber)
            ->with('success', 'You have been unsubscribed successfully.');
    }

    /**
     * Email preferences page
     */
    public function preferences(EmailSubscriber $subscriber): Response
    {
        return Inertia::render('Email/Preferences', [
            'subscriber' => $subscriber,
        ]);
    }

    /**
     * Update email preferences
     */
    public function updatePreferences(Request $request, EmailSubscriber $subscriber): RedirectResponse
    {
        $validated = $request->validate([
            'preferences' => 'required|array',
            'preferences.daily_digest' => 'boolean',
            'preferences.breaking_news' => 'boolean',
            'preferences.weekly_newsletter' => 'boolean',
        ]);

        $subscriber->update([
            'preferences' => $validated['preferences'],
        ]);

        return redirect()->route('email.preferences', $subscriber)
            ->with('success', 'Preferences updated successfully.');
    }
}
```

### app/Http/Controllers/HubBuilderController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\Hub;
use App\Models\HubSection;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class HubBuilderController extends Controller
{
    public function show(Hub $hub): Response
    {
        $this->authorize('update', $hub);

        $hub->load(['sections', 'members.user', 'roles']);

        return Inertia::render('event-city/hubs/builder', [
            'hub' => $hub,
        ]);
    }

    public function updateDesign(Hub $hub, Request $request): RedirectResponse
    {
        $this->authorize('update', $hub);

        $validated = $request->validate([
            'design_settings' => 'required|array',
            'design_settings.theme' => 'nullable|string',
            'design_settings.colors' => 'nullable|array',
            'design_settings.layout' => 'nullable|string',
            'design_settings.fonts' => 'nullable|array',
        ]);

        $hub->update([
            'design_settings' => array_merge($hub->design_settings ?? [], $validated['design_settings']),
        ]);

        return redirect()->back()->with('success', 'Design settings updated.');
    }

    public function updateSections(Hub $hub, Request $request): RedirectResponse
    {
        $this->authorize('update', $hub);

        $validated = $request->validate([
            'sections' => 'required|array',
            'sections.*.id' => 'nullable|uuid|exists:hub_sections,id',
            'sections.*.type' => 'required|string|in:'.implode(',', HubSection::TYPES),
            'sections.*.title' => 'required|string|max:255',
            'sections.*.description' => 'nullable|string',
            'sections.*.content' => 'nullable|array',
            'sections.*.settings' => 'nullable|array',
            'sections.*.is_visible' => 'boolean',
            'sections.*.sort_order' => 'integer',
        ]);

        foreach ($validated['sections'] as $index => $sectionData) {
            if (isset($sectionData['id'])) {
                $section = HubSection::where('hub_id', $hub->id)
                    ->where('id', $sectionData['id'])
                    ->first();

                if ($section) {
                    $section->update([
                        'type' => $sectionData['type'],
                        'title' => $sectionData['title'],
                        'description' => $sectionData['description'] ?? null,
                        'content' => $sectionData['content'] ?? null,
                        'settings' => $sectionData['settings'] ?? null,
                        'is_visible' => $sectionData['is_visible'] ?? true,
                        'sort_order' => $sectionData['sort_order'] ?? $index,
                    ]);
                }
            } else {
                HubSection::create([
                    'hub_id' => $hub->id,
                    'type' => $sectionData['type'],
                    'title' => $sectionData['title'],
                    'description' => $sectionData['description'] ?? null,
                    'content' => $sectionData['content'] ?? null,
                    'settings' => $sectionData['settings'] ?? null,
                    'is_visible' => $sectionData['is_visible'] ?? true,
                    'sort_order' => $sectionData['sort_order'] ?? $index,
                ]);
            }
        }

        return redirect()->back()->with('success', 'Sections updated.');
    }

    public function deleteSection(Hub $hub, HubSection $section): RedirectResponse
    {
        $this->authorize('update', $hub);

        if ($section->hub_id !== $hub->id) {
            abort(404);
        }

        $section->delete();

        return redirect()->back()->with('success', 'Section deleted.');
    }

    public function preview(Hub $hub): Response
    {
        $this->authorize('update', $hub);

        $hub->load(['sections', 'workspace', 'createdBy']);

        return Inertia::render('event-city/hubs/preview', [
            'hub' => $hub,
        ]);
    }

    public function publish(Hub $hub): RedirectResponse
    {
        $this->authorize('update', $hub);

        $hub->update([
            'published_at' => now(),
            'is_active' => true,
        ]);

        return redirect()->route('hubs.show', $hub->slug)
            ->with('success', 'Hub published successfully.');
    }
}
```

### app/Http/Controllers/HomePageController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\Event;
use App\Models\Performer;
use App\Models\Region;
use App\Models\Venue;
use App\Services\AdvertisementService;
use App\Services\LocationService;
use App\Services\SeoService;
use Illuminate\Http\Request;
use Inertia\Inertia;

final class HomePageController extends Controller
{
    public function __construct(
        private readonly AdvertisementService $advertisementService,
        private readonly LocationService $locationService
    ) {}

    public function index(Request $request)
    {
        // Get featured events from the database
        $featuredEvents = Event::published()
            ->upcoming()
            ->with(['venue', 'performer'])
            ->take(4)
            ->get()
            ->map(function ($event) {
                return [
                    'id' => $event->id,
                    'title' => $event->title,
                    'date' => $event->event_date->format('F j, Y'),
                    'venue' => $event->venue?->name ?? 'TBA',
                    'price' => $event->is_free ? 'Free' : '$'.number_format((float) ($event->price_min ?? 0)),
                    'category' => $event->category,
                    'image' => $event->image,
                ];
            })
            ->toArray();

        // Get featured venues from the database
        $featuredVenues = Venue::active()
            ->orderBy('average_rating', 'desc')
            ->take(4)
            ->get()
            ->map(function ($venue) {
                return [
                    'id' => $venue->id,
                    'name' => $venue->name,
                    'location' => $venue->address,
                    'capacity' => number_format($venue->capacity),
                    'venueType' => $venue->venue_type,
                    'rating' => round((float) ($venue->average_rating ?? 0), 1),
                    'reviewCount' => (string) $venue->total_reviews,
                    'image' => is_array($venue->images) && count($venue->images) > 0
                        ? $venue->images[0]
                        : 'https://images.unsplash.com/photo-1493225457124-a3eb161ffa5f?w=400&h=300&fit=crop',
                ];
            })
            ->toArray();

        // Get featured performers from the database
        $featuredPerformers = Performer::active()
            ->verified()
            ->with('upcomingShows')
            ->orderBy('average_rating', 'desc')
            ->take(4)
            ->get()
            ->map(function ($performer) {
                $upcomingShow = $performer->upcomingShows->first();

                return [
                    'id' => $performer->id,
                    'name' => $performer->name,
                    'homeCity' => $performer->home_city,
                    'genres' => is_array($performer->genres) ? $performer->genres : [$performer->genres],
                    'rating' => round((float) ($performer->average_rating ?? 0), 1),
                    'reviewCount' => (string) $performer->total_reviews,
                    'image' => $performer->profile_image ?? 'https://images.unsplash.com/photo-1493225457124-a3eb161ffa5f?w=400&h=300&fit=crop',
                    'upcomingShow' => $upcomingShow ? [
                        'date' => $upcomingShow->date->format('F j, Y'),
                        'venue' => $upcomingShow->venue,
                    ] : null,
                ];
            })
            ->toArray();

        // Get upcoming events from the database (next 7 days)
        $upcomingEvents = Event::published()
            ->upcoming()
            ->with(['venue', 'performer'])
            ->whereBetween('event_date', [now(), now()->addDays(7)])
            ->orderBy('event_date')
            ->orderBy('time')
            ->get()
            ->map(function ($event) {
                $eventDateTime = $event->event_date->copy();
                if ($event->time) {
                    $timeParts = explode(':', $event->time);
                    $eventDateTime->setTime((int) $timeParts[0], (int) $timeParts[1]);
                }

                return [
                    'id' => $event->id,
                    'title' => $event->title,
                    'date' => $eventDateTime->format('Y-m-d\TH:i:s.000\Z'),
                    'venue' => $event->venue?->name ?? 'TBA',
                    'price' => $event->is_free ? 'Free' : '$'.number_format((float) ($event->price_min ?? 0)),
                    'category' => $event->category,
                    'image' => $event->image ?? 'https://images.unsplash.com/photo-1514525253161-7a46d19cd819?w=400&h=300&fit=crop',
                ];
            })
            ->toArray();

        // Get current region for ad targeting
        $region = $request->attributes->get('detected_region');

        // Get advertisements for different placements
        $bannerAds = $this->advertisementService->getActiveAds('event_city', $region, 'banner')->take(1);
        $featuredAds = $this->advertisementService->getActiveAds('event_city', $region, 'featured')->take(1);
        $sidebarAds = $this->advertisementService->getActiveAds('event_city', $region, 'sidebar')->take(3);

        // Build SEO JSON-LD for homepage
        $seoData = [
            'title' => 'Home',
            'description' => 'Discover local events, venues, and performers. Find concerts, shows, and entertainment near you.',
            'url' => '/',
        ];

        return Inertia::render('event-city/welcome', [
            'seo' => [
                'jsonLd' => SeoService::buildJsonLd('website', $seoData, 'event-city'),
            ],
            'featuredEvents' => $featuredEvents,
            'featuredVenues' => $featuredVenues,
            'featuredPerformers' => $featuredPerformers,
            'upcomingEvents' => $upcomingEvents,
            'advertisements' => [
                'banner' => $bannerAds->map(fn ($ad) => [
                    'id' => $ad->id,
                    'placement' => $ad->placement,
                    'advertable' => [
                        'id' => $ad->advertable->id,
                        'title' => $ad->advertable->title,
                        'excerpt' => $ad->advertable->excerpt ?? null,
                        'featured_image' => $ad->advertable->featured_image ?? $ad->advertable->image ?? null,
                        'slug' => $ad->advertable->slug ?? null,
                    ],
                    'expires_at' => $ad->expires_at->toISOString(),
                ]),
                'featured' => $featuredAds->map(fn ($ad) => [
                    'id' => $ad->id,
                    'placement' => $ad->placement,
                    'advertable' => [
                        'id' => $ad->advertable->id,
                        'title' => $ad->advertable->title,
                        'excerpt' => $ad->advertable->excerpt ?? null,
                        'featured_image' => $ad->advertable->featured_image ?? $ad->advertable->image ?? null,
                        'slug' => $ad->advertable->slug ?? null,
                    ],
                    'expires_at' => $ad->expires_at->toISOString(),
                ]),
                'sidebar' => $sidebarAds->map(fn ($ad) => [
                    'id' => $ad->id,
                    'placement' => $ad->placement,
                    'advertable' => [
                        'id' => $ad->advertable->id,
                        'title' => $ad->advertable->title,
                        'excerpt' => $ad->advertable->excerpt ?? null,
                        'featured_image' => $ad->advertable->featured_image ?? $ad->advertable->image ?? null,
                        'slug' => $ad->advertable->slug ?? null,
                    ],
                    'expires_at' => $ad->expires_at->toISOString(),
                ]),
            ],
        ]);
    }
}
```

### app/Http/Controllers/CrossDomainAuthController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Services\CrossDomainAuthService;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Log;

final class CrossDomainAuthController extends Controller
{
    public function __construct(
        private readonly CrossDomainAuthService $authService
    ) {}

    /**
     * Sync authentication from another domain
     */
    public function sync(Request $request): RedirectResponse
    {
        $token = $request->query('token');
        $returnUrl = $request->query('return', '/');
        $currentDomain = $request->getHost();

        if (!$token) {
            Log::warning('Cross-domain auth sync attempted without token', [
                'domain' => $currentDomain,
                'ip' => $request->ip(),
            ]);

            return redirect($returnUrl)->with('error', 'Invalid authentication token.');
        }

        // Validate token and get user
        $user = $this->authService->validateAndUseToken($token, $currentDomain);

        if (!$user) {
            Log::warning('Cross-domain auth sync failed - invalid token', [
                'domain' => $currentDomain,
                'ip' => $request->ip(),
            ]);

            return redirect($returnUrl)->with('error', 'Authentication token expired or invalid.');
        }

        // Log the user in
        Auth::login($user);

        // Regenerate session to prevent fixation attacks
        $request->session()->regenerate();

        // Clear cross-domain auth URLs from session after successful sync
        $request->session()->forget('cross_domain_auth_urls');
        $request->session()->forget('cross_domain_auth_token');

        Log::info('Cross-domain auth sync successful', [
            'user_id' => $user->id,
            'domain' => $currentDomain,
        ]);

        // Return a simple success response (for iframe) or redirect (for direct access)
        if ($request->header('X-Requested-With') === 'XMLHttpRequest' || $request->wantsJson()) {
            return response()->json(['success' => true]);
        }

        return redirect($returnUrl)->with('success', 'Successfully logged in.');
    }

    /**
     * Handle logout sync across domains
     */
    public function logoutSync(Request $request): RedirectResponse
    {
        $currentDomain = $request->getHost();
        $returnUrl = $request->query('return', '/');

        // Logout current session
        Auth::guard('web')->logout();
        $request->session()->invalidate();
        $request->session()->regenerateToken();

        // Clear logout URLs from session
        $request->session()->forget('cross_domain_logout_urls');

        Log::info('Cross-domain logout sync', [
            'domain' => $currentDomain,
        ]);

        // Return a simple success response (for iframe) or redirect (for direct access)
        if ($request->header('X-Requested-With') === 'XMLHttpRequest' || $request->wantsJson()) {
            return response()->json(['success' => true]);
        }

        return redirect($returnUrl)->with('success', 'Successfully logged out.');
    }
}
```

### app/Http/Controllers/BookingController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Models\Booking;
use App\Models\Event;
use App\Models\Performer;
use App\Models\User;
use App\Models\Venue;
use App\Notifications\BookingConfirmationNotification;
use App\Services\BookingWorkflowService;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Mail;
use Inertia\Inertia;
use Inertia\Response;

final class BookingController extends Controller
{
    public function index(Request $request): Response
    {
        $currentWorkspace = $request->user()->currentWorkspace;

        if (! $currentWorkspace) {
            abort(403, 'No workspace selected');
        }

        $query = Booking::where('workspace_id', $currentWorkspace->id)
            ->with(['event', 'venue', 'performer', 'createdBy']);

        // Apply filters
        if ($request->filled('status')) {
            $query->byStatus($request->status);
        }

        if ($request->filled('booking_type')) {
            $query->byType($request->booking_type);
        }

        if ($request->filled('search')) {
            $search = $request->search;
            $query->where(function ($q) use ($search) {
                $q->where('booking_number', 'like', "%{$search}%")
                    ->orWhere('contact_name', 'like', "%{$search}%")
                    ->orWhere('contact_email', 'like', "%{$search}%");
            });
        }

        if ($request->filled('date_from')) {
            $query->forDateRange($request->date_from, $request->date_to ?? $request->date_from);
        }

        // Sorting
        $sortBy = $request->get('sort', 'created_at');
        $sortDirection = $request->get('direction', 'desc');

        match ($sortBy) {
            'booking_number' => $query->orderBy('booking_number', $sortDirection),
            'status' => $query->orderBy('status', $sortDirection),
            'event_date' => $query->orderBy('event_date', $sortDirection),
            'total_amount' => $query->orderBy('total_amount', $sortDirection),
            default => $query->orderBy('created_at', $sortDirection),
        };

        $bookings = $query->paginate(15)->withQueryString();

        return Inertia::render('event-city/bookings/Index', [
            'bookings' => $bookings,
            'filters' => $request->only(['status', 'booking_type', 'search', 'date_from', 'date_to']),
            'sort' => ['sort' => $sortBy, 'direction' => $sortDirection],
        ]);
    }

    public function show(Booking $booking): Response
    {
        $booking->load([
            'event.venue',
            'event.performer',
            'venue',
            'performer.upcomingShows',
            'workspace',
            'createdBy',
        ]);

        $currentStep = $this->workflowService->getCurrentStep($booking);
        $progress = $this->workflowService->getProgressPercentage($booking);
        $financialBreakdown = $this->workflowService->getFinancialBreakdown($booking);
        $canProceed = $this->workflowService->canProceedToNextStep($booking);

        return Inertia::render('event-city/bookings/Show', [
            'booking' => $booking,
            'currentStep' => $currentStep,
            'progress' => $progress,
            'financialBreakdown' => $financialBreakdown,
            'canProceed' => $canProceed,
            'steps' => $this->workflowService->getStepsForBookingType($booking->booking_type),
        ]);
    }

    public function create(Request $request): Response
    {
        $currentWorkspace = $request->user()->currentWorkspace;

        if (! $currentWorkspace) {
            abort(403, 'No workspace selected');
        }

        $events = Event::where('workspace_id', $currentWorkspace->id)
            ->where('status', 'published')
            ->where('event_date', '>=', now())
            ->with(['venue', 'performer'])
            ->get(['id', 'title', 'event_date', 'venue_id', 'performer_id']);

        $venues = Venue::where('workspace_id', $currentWorkspace->id)
            ->where('status', 'active')
            ->get(['id', 'name', 'address', 'capacity', 'price_per_hour', 'price_per_event', 'price_per_day']);

        $performers = Performer::where('workspace_id', $currentWorkspace->id)
            ->where('status', 'active')
            ->where('available_for_booking', true)
            ->get(['id', 'name', 'genres', 'base_price', 'minimum_booking_hours']);

        $bookingType = $request->get('type', 'event');
        $steps = $this->workflowService->getStepsForBookingType($bookingType);

        return Inertia::render('event-city/bookings/Create', [
            'events' => $events,
            'venues' => $venues,
            'performers' => $performers,
            'bookingType' => $bookingType,
            'steps' => $steps,
            'currentStep' => $steps[0] ?? BookingWorkflowService::STEP_INITIAL_REQUEST,
        ]);
    }

    public function store(Request $request)
    {
        $currentWorkspace = $request->user()->currentWorkspace;

        if (! $currentWorkspace) {
            abort(403, 'No workspace selected');
        }

        $validated = $request->validate([
            'booking_type' => 'required|in:event,venue,performer',
            'event_id' => 'required_if:booking_type,event|nullable|exists:events,id',
            'venue_id' => 'required_if:booking_type,venue|nullable|exists:venues,id',
            'performer_id' => 'required_if:booking_type,performer|nullable|exists:performers,id',

            // Contact information
            'contact_name' => 'required|string|max:255',
            'contact_email' => 'required|email',
            'contact_phone' => 'nullable|string',
            'contact_company' => 'nullable|string',

            // Event details
            'event_date' => 'required|date|after:now',
            'start_time' => 'required|date_format:H:i',
            'end_time' => 'required|date_format:H:i|after:start_time',
            'event_type' => 'required|in:private,public,corporate',
            'expected_guests' => 'nullable|integer|min:1',
            'expected_audience' => 'nullable|integer|min:1',

            // Event booking specific
            'ticket_quantity' => 'required_if:booking_type,event|nullable|integer|min:1',
            'ticket_type' => 'required_if:booking_type,event|nullable|string',
            'price_per_ticket' => 'required_if:booking_type,event|nullable|numeric|min:0',

            // Payment
            'total_amount' => 'required|numeric|min:0',
            'currency' => 'required|string|size:3',

            // Additional information
            'notes' => 'nullable|string',
            'special_requests' => 'nullable|array',
            'setup_requirements' => 'nullable|array',
            'catering_requirements' => 'nullable|array',
            'performance_requirements' => 'nullable|array',
            'sound_requirements' => 'nullable|array',
        ]);

        // Use workflow service to create booking draft
        $booking = $this->workflowService->createBookingDraft([
            ...$validated,
            'workspace_id' => $currentWorkspace->id,
            'created_by' => $request->user()->id,
            'status' => 'pending',
            'payment_status' => 'pending',
        ]);

        // Calculate and update quote
        $booking = $this->workflowService->updateQuote($booking);

        // Send booking confirmation email to contact email
        if ($booking->contact_email) {
            $user = User::where('email', $booking->contact_email)->first();
            if ($user) {
                $user->notify(new BookingConfirmationNotification($booking));
            } else {
                // Send via Mail facade if user doesn't exist
                Mail::to($booking->contact_email)->send(new \App\Mail\BookingConfirmationMail($booking));
            }
        }

        return redirect()->route('bookings.show', $booking)
            ->with('success', 'Booking created successfully! Booking number: '.$booking->booking_number);
    }

    public function edit(Booking $booking): Response
    {
        $this->authorize('update', $booking);

        $events = Event::where('workspace_id', $booking->workspace_id)
            ->where('status', 'published')
            ->with(['venue', 'performer'])
            ->get(['id', 'title', 'event_date', 'venue_id', 'performer_id']);

        $venues = Venue::where('workspace_id', $booking->workspace_id)
            ->where('status', 'active')
            ->get(['id', 'name', 'address', 'capacity', 'price_per_hour', 'price_per_event', 'price_per_day']);

        $performers = Performer::where('workspace_id', $booking->workspace_id)
            ->where('status', 'active')
            ->where('available_for_booking', true)
            ->get(['id', 'name', 'genres', 'base_price', 'minimum_booking_hours']);

        return Inertia::render('event-city/bookings/Edit', [
            'booking' => $booking,
            'events' => $events,
            'venues' => $venues,
            'performers' => $performers,
        ]);
    }

    public function update(Request $request, Booking $booking)
    {
        $this->authorize('update', $booking);

        $validated = $request->validate([
            'booking_type' => 'required|in:event,venue,performer',
            'event_id' => 'required_if:booking_type,event|nullable|exists:events,id',
            'venue_id' => 'required_if:booking_type,venue|nullable|exists:venues,id',
            'performer_id' => 'required_if:booking_type,performer|nullable|exists:performers,id',

            // Contact information
            'contact_name' => 'required|string|max:255',
            'contact_email' => 'required|email',
            'contact_phone' => 'nullable|string',
            'contact_company' => 'nullable|string',

            // Event details
            'event_date' => 'required|date',
            'start_time' => 'required|date_format:H:i',
            'end_time' => 'required|date_format:H:i|after:start_time',
            'event_type' => 'required|in:private,public,corporate',
            'expected_guests' => 'nullable|integer|min:1',
            'expected_audience' => 'nullable|integer|min:1',

            // Event booking specific
            'ticket_quantity' => 'required_if:booking_type,event|nullable|integer|min:1',
            'ticket_type' => 'required_if:booking_type,event|nullable|string',
            'price_per_ticket' => 'required_if:booking_type,event|nullable|numeric|min:0',

            // Payment
            'total_amount' => 'required|numeric|min:0',
            'currency' => 'required|string|size:3',
            'status' => 'required|in:pending,confirmed,cancelled,completed,rejected,refunded',
            'payment_status' => 'required|in:pending,paid,partially_paid,failed,refunded,cancelled',

            // Additional information
            'notes' => 'nullable|string',
            'special_requests' => 'nullable|array',
            'setup_requirements' => 'nullable|array',
            'catering_requirements' => 'nullable|array',
            'performance_requirements' => 'nullable|array',
            'sound_requirements' => 'nullable|array',
        ]);

        $booking->update($validated);

        return redirect()->route('bookings.show', $booking)
            ->with('success', 'Booking updated successfully!');
    }

    public function confirm(Booking $booking)
    {
        $this->authorize('update', $booking);

        $wasPending = $booking->status === 'pending';
        $booking->markAsConfirmed();

        // Send confirmation email when booking is confirmed
        if ($wasPending && $booking->contact_email) {
            $user = User::where('email', $booking->contact_email)->first();
            if ($user) {
                $user->notify(new BookingConfirmationNotification($booking));
            } else {
                // Send via Mail facade if user doesn't exist
                Mail::to($booking->contact_email)->send(new \App\Mail\BookingConfirmationMail($booking));
            }
        }

        return redirect()->route('bookings.show', $booking)
            ->with('success', 'Booking confirmed successfully!');
    }

    public function cancel(Request $request, Booking $booking)
    {
        $this->authorize('update', $booking);

        $validated = $request->validate([
            'cancellation_reason' => 'required|string|max:500',
        ]);

        $booking->markAsCancelled($validated['cancellation_reason']);

        return redirect()->route('bookings.show', $booking)
            ->with('success', 'Booking cancelled successfully.');
    }

    public function destroy(Booking $booking)
    {
        $this->authorize('delete', $booking);

        $booking->delete();

        return redirect()->route('bookings.index')
            ->with('success', 'Booking deleted successfully!');
    }
}
```

### app/Http/Controllers/WorkspaceController.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Controllers;

use App\Dto\Workspace\InvitationAcceptanceResult;
use App\Models\User;
use App\Models\Workspace;
use App\Models\WorkspaceInvitation;
use App\Models\WorkspaceMembership;
use App\Services\Workspace\WorkspaceInvitationService;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Str;
use Inertia\Inertia;
use Inertia\Response;

final class WorkspaceController extends Controller
{
    public function store(Request $request)
    {
        if (! config('makerkit.workspaces.can_create_workspaces') || ! config('makerkit.workspaces.enabled')) {
            abort(404, 'Workspaces are not enabled');
        }

        $request->validate([
            'name' => 'required|string|max:255',
        ]);

        $workspace = Workspace::create([
            'name' => $request->name,
            'owner_id' => $request->user()->id,
            'slug' => Str::slug($request->name.'Workspace').Str::random(5),
        ]);

        WorkspaceMembership::create([
            'workspace_id' => $workspace->id,
            'user_id' => $request->user()->id,
            'role' => 'owner',
        ]);

        $request->user()->current_workspace_id = $workspace->id;
        $request->user()->save();

        return redirect()->route('dashboard')->with('success', 'Workspace created successfully');
    }

    /**
     * Switch the user's current workspace
     */
    public function switch(Request $request): RedirectResponse
    {
        if (! config('makerkit.workspaces.enabled')) {
            abort(404, 'Workspaces are not enabled');
        }

        $request->validate([
            'workspace_id' => 'required|string',
        ]);

        /** @var User $user */
        $user = Auth::user();

        if (! $user) {
            return back()->withErrors(['error' => 'User not authenticated']);
        }

        $workspaceId = $request->input('workspace_id');

        // Verify user belongs to this workspace
        $membership = $user->workspaceMemberships()
            ->where('workspace_memberships.workspace_id', $workspaceId)
            ->first();

        if (! $membership) {
            return back()->withErrors(['error' => 'You do not have access to this workspace']);
        }

        // Update user's current workspace
        $user->current_workspace_id = $workspaceId;
        $user->save();

        return back()->with('success', 'Workspace switched successfully');
    }

    /**
     * Show the invitation acceptance page
     */
    public function showInvitation(string $token): Response|RedirectResponse
    {
        if (! config('makerkit.workspaces.enabled')) {
            abort(404, 'Workspaces are not enabled');
        }

        $invitation = WorkspaceInvitation::where('token', $token)->first();

        if (! $invitation) {
            return redirect()->route('home')->withErrors(['error' => 'Invalid invitation link']);
        }

        if (! $invitation->isValid()) {
            $message = $invitation->isExpired() ? 'This invitation has expired' : 'This invitation has already been accepted';

            return redirect()->route('home')->withErrors(['error' => $message]);
        }

        // Check if user is already logged in
        if (Auth::check()) {
            return $this->acceptInvitationForLoggedInUser($invitation);
        }

        // Check if user exists but is not logged in
        $existingUser = User::where('email', $invitation->email)->first();

        return Inertia::render('event-city/auth/workspace-invitation', [
            'invitation' => [
                'token' => $invitation->token,
                'email' => $invitation->email,
                'workspace_name' => $invitation->workspace->name,
                'role' => $invitation->role,
                'inviter_name' => $invitation->inviter->name,
                'expires_at' => $invitation->expires_at,
            ],
            'userExists' => (bool) $existingUser,
            'loginUrl' => route('login', ['invitation' => $invitation->token]),
            'registerUrl' => route('register', ['invitation' => $invitation->token]),
        ]);
    }

    /**
     * Accept invitation for logged-in user
     */
    public function acceptInvitationForLoggedInUser(WorkspaceInvitation $invitation): RedirectResponse
    {
        if (! config('makerkit.workspaces.enabled')) {
            abort(404, 'Workspaces are not enabled');
        }

        /** @var User $user */
        $user = Auth::user();

        $invitationService = app(WorkspaceInvitationService::class);
        $result = $invitationService->acceptInvitationForAuthenticatedUser($invitation, $user);

        if ($result->wasSuccessful()) {
            return redirect()->route('dashboard')->with('success', $result->getMessage());
        }

        if ($result->getFlashType() === 'warning') {
            return redirect()->route('dashboard')->with('warning', $result->getMessage());
        }

        return redirect()->route('home')->withErrors(['error' => $result->getMessage()]);
    }

    /**
     * Accept invitation by token (called from auth controllers)
     */
    public function acceptInvitationByToken(string $token, User $user): InvitationAcceptanceResult
    {
        if (! config('makerkit.workspaces.enabled')) {
            return new InvitationAcceptanceResult(
                success: false,
                message: 'Workspaces are not enabled',
                type: 'error'
            );
        }

        $invitationService = app(WorkspaceInvitationService::class);

        return $invitationService->acceptInvitationByToken($token, $user);
    }
}
```

---
## Services

### AIContentService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\Community;
use App\Services\AIService;
use Illuminate\Support\Facades\Log;

final class AIContentService
{
    public function __construct(
        private readonly AIService $aiService
    ) {}

    /**
     * Generate digest content using AI
     */
    public function generateDigestContent(Community $community, array $content): array
    {
        $prompt = $this->buildDigestPrompt($community, $content);

        try {
            $response = $this->aiService->generateWithAnthropic($prompt, [
                'model' => 'claude-3-opus-20240229',
                'max_tokens' => 2000,
            ]);

            return $this->parseDigestResponse($response, $content);
        } catch (\Exception $e) {
            Log::error('AI digest generation failed', [
                'community_id' => $community->id,
                'error' => $e->getMessage(),
            ]);

            // Fallback to basic content
            return [
                'subject' => "Daily Digest - {$community->name} - " . now()->format('M j, Y'),
                'preview' => 'Your daily roundup of local news and events.',
                'intro' => "Here's what's happening in {$community->name} today.",
                'stories' => array_map(fn($story) => [
                    'title' => $story->title ?? 'Untitled',
                    'summary' => substr($story->excerpt ?? $story->content ?? '', 0, 150),
                ], $content['top_stories'] ?? []),
            ];
        }
    }

    /**
     * Generate newsletter content using AI
     */
    public function generateNewsletterContent(Community $community, array $content): array
    {
        $prompt = $this->buildNewsletterPrompt($community, $content);

        try {
            $response = $this->aiService->generateWithAnthropic($prompt, [
                'model' => 'claude-3-opus-20240229',
                'max_tokens' => 3000,
            ]);

            return $this->parseNewsletterResponse($response, $content);
        } catch (\Exception $e) {
            Log::error('AI newsletter generation failed', [
                'community_id' => $community->id,
                'error' => $e->getMessage(),
            ]);

            // Fallback
            return [
                'subject' => "Weekly Newsletter - {$community->name}",
                'preview' => 'Your weekly roundup of local news and events.',
                'editorial' => "Here's what happened in {$community->name} this week.",
            ];
        }
    }

    /**
     * Generate subject lines (for A/B testing)
     */
    public function generateSubjectLines(string $baseSubject, int $count = 3): array
    {
        $prompt = "Generate {$count} variations of this email subject line, each with a different angle or tone: {$baseSubject}";

        try {
            $response = $this->aiService->generateWithAnthropic($prompt, [
                'model' => 'claude-3-opus-20240229',
                'max_tokens' => 200,
            ]);

            // Parse response (assuming line-separated or JSON)
            $lines = array_filter(array_map('trim', explode("\n", $response)));
            return array_slice($lines, 0, $count);
        } catch (\Exception $e) {
            Log::error('AI subject line generation failed', ['error' => $e->getMessage()]);
            return [$baseSubject];
        }
    }

    /**
     * Build digest prompt
     */
    protected function buildDigestPrompt(Community $community, array $content): string
    {
        $stories = array_map(fn($s) => [
            'title' => $s->title ?? 'Untitled',
            'excerpt' => $s->excerpt ?? substr($s->content ?? '', 0, 200),
        ], $content['top_stories'] ?? []);

        return "Write a daily digest email for {$community->name}. Include:
- A compelling subject line (max 60 chars)
- Preview text (max 150 chars)
- Brief intro paragraph
- Summaries of top stories: " . json_encode($stories) . "
- Upcoming events: " . json_encode($content['upcoming_events'] ?? []) . "

Return JSON with: subject, preview, intro, stories (array with title and summary).";
    }

    /**
     * Parse digest response
     */
    protected function parseDigestResponse(string $response, array $content): array
    {
        // Try to parse as JSON first
        $decoded = json_decode($response, true);
        if ($decoded && isset($decoded['subject'])) {
            return $decoded;
        }

        // Fallback parsing
        return [
            'subject' => "Daily Digest - " . now()->format('M j, Y'),
            'preview' => substr($response, 0, 150),
            'intro' => substr($response, 0, 300),
            'stories' => array_map(fn($s) => [
                'title' => $s->title ?? 'Untitled',
                'summary' => substr($s->excerpt ?? '', 0, 150),
            ], $content['top_stories'] ?? []),
        ];
    }

    /**
     * Build newsletter prompt
     */
    protected function buildNewsletterPrompt(Community $community, array $content): string
    {
        return "Write a weekly newsletter email for {$community->name}. Include:
- A compelling subject line
- Preview text
- Editorial introduction
- Summary of week's top stories
- Upcoming events

Return JSON with: subject, preview, editorial, stories.";
    }

    /**
     * Parse newsletter response
     */
    protected function parseNewsletterResponse(string $response, array $content): array
    {
        $decoded = json_decode($response, true);
        if ($decoded && isset($decoded['subject'])) {
            return $decoded;
        }

        return [
            'subject' => "Weekly Newsletter - {$community->name}",
            'preview' => substr($response, 0, 150),
            'editorial' => substr($response, 0, 500),
        ];
    }
}

```

### AIService.php
```php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;

class AIService
{
    private const OPENAI_API_URL = 'https://api.openai.com/v1/chat/completions';
    private const ANTHROPIC_API_URL = 'https://api.anthropic.com/v1/messages';
    
    public function __construct(
        private readonly CacheService $cacheService
    ) {}

    /**
     * Generate content using OpenAI
     */
    public function generateWithOpenAI(string $prompt, array $options = []): string
    {
        $cacheKey = 'ai:openai:' . md5($prompt . serialize($options));
        
        return $this->cacheService->remember($cacheKey, 3600, function () use ($prompt, $options) {
            try {
                $response = Http::withHeaders([
                    'Authorization' => 'Bearer ' . config('services.openai.api_key'),
                    'Content-Type' => 'application/json',
                ])->post(self::OPENAI_API_URL, [
                    'model' => $options['model'] ?? 'gpt-4',
                    'messages' => [
                        ['role' => 'system', 'content' => $options['system'] ?? 'You are a helpful assistant.'],
                        ['role' => 'user', 'content' => $prompt],
                    ],
                    'temperature' => $options['temperature'] ?? 0.7,
                    'max_tokens' => $options['max_tokens'] ?? 1000,
                ]);

                if ($response->successful()) {
                    return $response->json()['choices'][0]['message']['content'] ?? '';
                }

                Log::error('OpenAI API error', ['response' => $response->body()]);
                return '';
            } catch (\Exception $e) {
                Log::error('OpenAI API exception', ['error' => $e->getMessage()]);
                return '';
            }
        });
    }

    /**
     * Generate content using Anthropic Claude
     */
    public function generateWithAnthropic(string $prompt, array $options = []): string
    {
        $cacheKey = 'ai:anthropic:' . md5($prompt . serialize($options));
        
        return $this->cacheService->remember($cacheKey, 3600, function () use ($prompt, $options) {
            try {
                $response = Http::withHeaders([
                    'x-api-key' => config('services.anthropic.api_key'),
                    'anthropic-version' => '2023-06-01',
                    'Content-Type' => 'application/json',
                ])->post(self::ANTHROPIC_API_URL, [
                    'model' => $options['model'] ?? 'claude-3-opus-20240229',
                    'max_tokens' => $options['max_tokens'] ?? 1000,
                    'messages' => [
                        ['role' => 'user', 'content' => $prompt],
                    ],
                ]);

                if ($response->successful()) {
                    return $response->json()['content'][0]['text'] ?? '';
                }

                Log::error('Anthropic API error', ['response' => $response->body()]);
                return '';
            } catch (\Exception $e) {
                Log::error('Anthropic API exception', ['error' => $e->getMessage()]);
                return '';
            }
        });
    }

    /**
     * Generate business page content
     */
    public function generateBusinessContent(\App\Models\Business $business, string $contentType = 'description'): string
    {
        $prompt = match ($contentType) {
            'description' => $this->buildBusinessDescriptionPrompt($business),
            'about' => $this->buildBusinessAboutPrompt($business),
            'services' => $this->buildBusinessServicesPrompt($business),
            'seo' => $this->buildBusinessSeoPrompt($business),
            default => $this->buildBusinessDescriptionPrompt($business),
        };

        // Use OpenAI by default, fallback to Anthropic if needed
        $content = $this->generateWithOpenAI($prompt, [
            'model' => 'gpt-4',
            'max_tokens' => 500,
        ]);

        if (empty($content)) {
            $content = $this->generateWithAnthropic($prompt, [
                'model' => 'claude-3-opus-20240229',
                'max_tokens' => 500,
            ]);
        }

        return $content;
    }

    /**
     * Generate FAQ answers
     */
    public function generateFaqAnswer(\App\Models\Business $business, string $question): string
    {
        $prompt = "As a representative of {$business->name}, located at {$business->address}, please provide a helpful and accurate answer to the following question: {$question}";
        
        return $this->generateWithOpenAI($prompt, [
            'model' => 'gpt-4',
            'max_tokens' => 300,
        ]);
    }

    /**
     * Analyze customer interaction sentiment
     */
    public function analyzeSentiment(string $text): array
    {
        $prompt = "Analyze the sentiment of the following text and return a JSON object with 'sentiment' (positive/negative/neutral), 'score' (0-1), and 'key_points' (array): {$text}";
        
        $response = $this->generateWithOpenAI($prompt, [
            'model' => 'gpt-4',
            'max_tokens' => 200,
        ]);

        $decoded = json_decode($response, true);
        return $decoded ?: ['sentiment' => 'neutral', 'score' => 0.5, 'key_points' => []];
    }

    /**
     * Generate customer insights
     */
    public function generateCustomerInsights(\App\Models\SMBCrmCustomer $customer): array
    {
        $prompt = "Based on the customer data for {$customer->first_name} {$customer->last_name}, generate insights including health score, lifetime value prediction, and churn risk. Return JSON.";
        
        $response = $this->generateWithOpenAI($prompt, [
            'model' => 'gpt-4',
            'max_tokens' => 300,
        ]);

        $decoded = json_decode($response, true);
        return $decoded ?: [
            'health_score' => 75,
            'lifetime_value' => 0,
            'churn_risk' => 0.3,
        ];
    }

    /**
     * Build business description prompt
     */
    private function buildBusinessDescriptionPrompt(\App\Models\Business $business): string
    {
        return "Write a compelling, SEO-friendly description for {$business->name}, a business located at {$business->address}. " .
               "Include information about their services, what makes them unique, and why customers should visit. " .
               "Keep it concise (2-3 paragraphs) and engaging.";
    }

    /**
     * Build business about prompt
     */
    private function buildBusinessAboutPrompt(\App\Models\Business $business): string
    {
        return "Write an 'About Us' section for {$business->name}. Include their history, mission, values, and what sets them apart. " .
               "Make it personal and engaging (3-4 paragraphs).";
    }

    /**
     * Build business services prompt
     */
    private function buildBusinessServicesPrompt(\App\Models\Business $business): string
    {
        return "List and describe the services offered by {$business->name}. Format as a clear, organized list with brief descriptions for each service.";
    }

    /**
     * Build business SEO prompt
     */
    private function buildBusinessSeoPrompt(\App\Models\Business $business): string
    {
        return "Generate SEO-optimized meta title and description for {$business->name}, located at {$business->address}. " .
               "Include relevant keywords naturally. Return as JSON with 'title' and 'description' fields.";
    }
}

```

### AdServerService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\AdCampaign;
use App\Models\AdCreative;
use App\Models\AdPlacement;
use App\Models\AdImpression;
use App\Models\AdClick;
use App\Models\AdInventory;
use App\Models\Community;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\DB;

final class AdServerService
{
    /**
     * Get an ad to display for a given placement and community
     */
    public function getAd(string $platform, string $slot, ?int $communityId = null, ?string $sessionId = null): ?array
    {
        $placement = $this->getPlacement($platform, $slot);
        if (!$placement || !$placement->is_active) {
            return null;
        }

        // Get eligible campaigns targeting this community/platform
        $creative = $this->selectCreative($placement, $communityId, $sessionId);
        if (!$creative) {
            return null;
        }

        // Record impression
        $impression = $this->recordImpression($creative, $placement, $communityId, $sessionId);

        return [
            'creative_id' => $creative->uuid,
            'impression_id' => $impression->id,
            'format' => $creative->format,
            'headline' => $creative->headline,
            'body' => $creative->body,
            'image_url' => $creative->image_url,
            'video_url' => $creative->video_url,
            'audio_url' => $creative->audio_url,
            'click_url' => route('ads.click', ['impression' => $impression->id]),
            'cta_text' => $creative->cta_text,
            'width' => $placement->width,
            'height' => $placement->height,
        ];
    }

    /**
     * Select best creative based on targeting, budget, and rotation
     */
    protected function selectCreative(AdPlacement $placement, ?int $communityId, ?string $sessionId): ?AdCreative
    {
        $cacheKey = "ad_eligible_{$placement->id}_" . ($communityId ?? 'all');

        $eligibleCreatives = Cache::remember($cacheKey, 60, function () use ($placement, $communityId) {
            return AdCreative::query()
                ->where('status', 'active')
                ->where('format', $placement->format)
                ->whereHas('campaign', function ($query) use ($communityId, $placement) {
                    $query->where('status', 'active')
                        ->where('start_date', '<=', now())
                        ->where('end_date', '>=', now())
                        ->whereRaw('spent < budget')
                        ->where(function ($q) use ($communityId) {
                            if ($communityId) {
                                $q->whereNull('targeting')
                                    ->orWhereJsonContains('targeting->communities', $communityId);
                            } else {
                                $q->whereNull('targeting');
                            }
                        })
                        ->where(function ($q) use ($placement) {
                            $q->whereNull('platforms')
                                ->orWhereJsonContains('platforms', $placement->platform);
                        });
                })
                ->with('campaign')
                ->get();
        });

        if ($eligibleCreatives->isEmpty()) {
            return null;
        }

        // Apply frequency capping if session provided
        if ($sessionId) {
            $recentImpressions = AdImpression::where('session_id', $sessionId)
                ->where('impressed_at', '>', now()->subHour())
                ->pluck('creative_id')
                ->toArray();

            $eligibleCreatives = $eligibleCreatives->filter(function ($creative) use ($recentImpressions) {
                // Allow max 3 impressions per hour per session
                return collect($recentImpressions)
                    ->filter(fn($id) => $id === $creative->id)
                    ->count() < 3;
            });
        }

        if ($eligibleCreatives->isEmpty()) {
            return null;
        }

        // Weighted random selection based on remaining budget
        $totalWeight = $eligibleCreatives->sum(fn($c) => $c->campaign->remaining_budget);
        if ($totalWeight <= 0) {
            return $eligibleCreatives->first();
        }

        $random = mt_rand(0, (int)($totalWeight * 100)) / 100;
        $cumulative = 0;
        foreach ($eligibleCreatives as $creative) {
            $cumulative += $creative->campaign->remaining_budget;
            if ($random <= $cumulative) {
                return $creative;
            }
        }

        return $eligibleCreatives->first();
    }

    /**
     * Record an impression
     */
    protected function recordImpression(
        AdCreative $creative,
        AdPlacement $placement,
        ?int $communityId,
        ?string $sessionId
    ): AdImpression {
        // Calculate cost based on campaign type
        $cost = 0;
        if ($creative->campaign->type === 'cpm') {
            $cost = (float) $placement->base_cpm / 1000;
        }

        $impression = AdImpression::create([
            'creative_id' => $creative->id,
            'placement_id' => $placement->id,
            'community_id' => $communityId,
            'session_id' => $sessionId,
            'ip_hash' => request()->ip() ? hash('sha256', request()->ip()) : null,
            'user_agent' => request()->userAgent(),
            'referrer' => request()->header('referer'),
            'cost' => $cost,
            'impressed_at' => now(),
        ]);

        // Update campaign spent (async via queue for performance)
        if ($cost > 0) {
            DB::table('ad_campaigns')
                ->where('id', $creative->campaign_id)
                ->increment('spent', $cost);
        }

        // Update inventory stats
        if ($communityId) {
            AdInventory::updateOrCreate(
                [
                    'placement_id' => $placement->id,
                    'community_id' => $communityId,
                    'date' => now()->toDateString(),
                ],
                []
            )->increment('delivered_impressions');
        }

        return $impression;
    }

    /**
     * Record a click
     */
    public function recordClick(int $impressionId): ?string
    {
        $impression = AdImpression::with('creative.campaign', 'placement')->find($impressionId);
        if (!$impression) {
            return null;
        }

        // Check for click fraud (same IP clicking multiple times)
        $existingClick = AdClick::where('impression_id', $impressionId)->exists();
        if ($existingClick) {
            return $impression->creative->click_url;
        }

        // Calculate click cost
        $cost = 0;
        if ($impression->creative->campaign->type === 'cpc') {
            $cost = (float) ($impression->placement->base_cpc ?? 0);
        }

        AdClick::create([
            'impression_id' => $impressionId,
            'creative_id' => $impression->creative_id,
            'ip_hash' => request()->ip() ? hash('sha256', request()->ip()) : null,
            'cost' => $cost,
            'clicked_at' => now(),
        ]);

        // Update campaign spent for CPC
        if ($cost > 0) {
            DB::table('ad_campaigns')
                ->where('id', $impression->creative->campaign_id)
                ->increment('spent', $cost);
        }

        return $impression->creative->click_url;
    }

    /**
     * Get placement by platform and slot
     */
    protected function getPlacement(string $platform, string $slot): ?AdPlacement
    {
        return Cache::remember(
            "placement_{$platform}_{$slot}",
            3600,
            fn() => AdPlacement::where('platform', $platform)
                ->where('slot', $slot)
                ->where('is_active', true)
                ->first()
        );
    }

    /**
     * Get campaign performance stats
     */
    public function getCampaignStats(AdCampaign $campaign): array
    {
        $impressions = AdImpression::whereIn('creative_id', $campaign->creatives->pluck('id'))
            ->count();
        $clicks = AdClick::whereIn('creative_id', $campaign->creatives->pluck('id'))
            ->count();

        return [
            'impressions' => $impressions,
            'clicks' => $clicks,
            'ctr' => $impressions > 0 ? round(($clicks / $impressions) * 100, 2) : 0,
            'spent' => (float) $campaign->spent,
            'remaining' => (float) $campaign->remaining_budget,
            'budget_utilization' => (float) $campaign->budget > 0
                ? round(((float) $campaign->spent / (float) $campaign->budget) * 100, 1)
                : 0,
        ];
    }

    /**
     * Get ads for email campaigns
     */
    public function getEmailAds(int $communityId, string $type = 'daily_digest', int $limit = 2): array
    {
        // Get sidebar ads for email
        $placement = $this->getPlacement('email', 'sidebar');
        if (!$placement) {
            return [];
        }

        $ads = [];
        for ($i = 0; $i < $limit; $i++) {
            $ad = $this->getAd('email', 'sidebar', $communityId);
            if ($ad) {
                $ads[] = $ad;
            }
        }

        return $ads;
    }
}

```

### AdvertisementService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\Advertisement;
use App\Models\Region;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Collection;

final class AdvertisementService
{
    public function createAdvertisement(Model $advertable, string $platform, array $config): Advertisement
    {
        return Advertisement::create([
            'advertable_type' => get_class($advertable),
            'advertable_id' => $advertable->id,
            'platform' => $platform,
            'placement' => $config['placement'] ?? 'sidebar',
            'regions' => $config['regions'] ?? [],
            'starts_at' => $config['starts_at'] ?? now(),
            'expires_at' => $config['expires_at'],
            'is_active' => true,
        ]);
    }

    public function getActiveAds(string $platform, ?Region $region = null, string $placement = 'sidebar'): Collection
    {
        $query = Advertisement::active()
            ->forPlatform($platform)
            ->forPlacement($placement)
            ->with('advertable');

        if ($region) {
            $query->forRegion($region->id);
        }

        return $query->inRandomOrder()->get();
    }

    public function trackImpression(Advertisement $ad): void
    {
        $ad->incrementImpressions();
    }

    public function trackClick(Advertisement $ad): void
    {
        $ad->incrementClicks();
    }

    public function expireExpiredAds(): int
    {
        return Advertisement::where('is_active', true)
            ->where('expires_at', '<=', now())
            ->update(['is_active' => false]);
    }

    public function deactivateAd(Advertisement $ad): void
    {
        $ad->markAsInactive();
    }
}
```

### BookingWorkflowService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\Booking;
use App\Models\Event;
use App\Models\Performer;
use App\Models\Venue;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

final class BookingWorkflowService
{
    /**
     * Booking workflow steps
     */
    public const STEP_INITIAL_REQUEST = 'initial_request';
    public const STEP_QUOTE = 'quote';
    public const STEP_REVIEW = 'review';
    public const STEP_PAYMENT = 'payment';
    public const STEP_CONFIRMATION = 'confirmation';
    public const STEP_COMPLETED = 'completed';

    /**
     * Create a booking draft
     */
    public function createBookingDraft(array $data): Booking
    {
        return Booking::create([
            ...$data,
            'status' => 'draft',
        ]);
    }

    /**
     * Get available steps for a booking type
     */
    public function getStepsForBookingType(string $bookingType): array
    {
        return match ($bookingType) {
            'event' => [
                self::STEP_INITIAL_REQUEST,
                self::STEP_QUOTE,
                self::STEP_REVIEW,
                self::STEP_PAYMENT,
                self::STEP_CONFIRMATION,
                self::STEP_COMPLETED,
            ],
            'venue' => [
                self::STEP_INITIAL_REQUEST,
                self::STEP_QUOTE,
                self::STEP_REVIEW,
                self::STEP_PAYMENT,
                self::STEP_CONFIRMATION,
                self::STEP_COMPLETED,
            ],
            'performer' => [
                self::STEP_INITIAL_REQUEST,
                self::STEP_QUOTE,
                self::STEP_REVIEW,
                self::STEP_PAYMENT,
                self::STEP_CONFIRMATION,
                self::STEP_COMPLETED,
            ],
            default => [],
        };
    }

    /**
     * Get current step for a booking
     */
    public function getCurrentStep(Booking $booking): string
    {
        if ($booking->status === 'completed') {
            return self::STEP_COMPLETED;
        }

        if ($booking->status === 'confirmed' && $booking->payment_status === 'paid') {
            return self::STEP_CONFIRMATION;
        }

        if ($booking->payment_status === 'paid' || $booking->payment_status === 'partially_paid') {
            return self::STEP_PAYMENT;
        }

        if ($booking->status === 'confirmed') {
            return self::STEP_REVIEW;
        }

        if ($booking->total_amount > 0) {
            return self::STEP_QUOTE;
        }

        return self::STEP_INITIAL_REQUEST;
    }

    /**
     * Get progress percentage for a booking
     */
    public function getProgressPercentage(Booking $booking): int
    {
        $steps = $this->getStepsForBookingType($booking->booking_type);
        $currentStep = $this->getCurrentStep($booking);
        $currentIndex = array_search($currentStep, $steps, true);

        if ($currentIndex === false) {
            return 0;
        }

        return (int) (($currentIndex + 1) / count($steps) * 100);
    }

    /**
     * Calculate quote for a booking
     */
    public function calculateQuote(Booking $booking): array
    {
        $basePrice = 0;
        $fees = [];
        $total = 0;

        if ($booking->isEventBooking() && $booking->event) {
            $event = $booking->event;
            $basePrice = $event->price_min ?? 0;
            
            // Calculate based on ticket quantity
            if ($booking->ticket_quantity && $booking->price_per_ticket) {
                $basePrice = $booking->ticket_quantity * $booking->price_per_ticket;
            }
        } elseif ($booking->isVenueBooking() && $booking->venue) {
            $venue = $booking->venue;
            
            // Calculate based on venue pricing
            if ($booking->start_time && $booking->end_time) {
                $start = \Carbon\Carbon::parse($booking->start_time);
                $end = \Carbon\Carbon::parse($booking->end_time);
                $hours = $start->diffInHours($end);
                
                if ($venue->price_per_hour) {
                    $basePrice = $hours * $venue->price_per_hour;
                } elseif ($venue->price_per_event) {
                    $basePrice = $venue->price_per_event;
                } elseif ($venue->price_per_day) {
                    $basePrice = $venue->price_per_day;
                }
            }
        } elseif ($booking->isPerformerBooking() && $booking->performer) {
            $performer = $booking->performer;
            $basePrice = $performer->base_price ?? 0;
            
            // Calculate based on booking hours
            if ($booking->start_time && $booking->end_time) {
                $start = \Carbon\Carbon::parse($booking->start_time);
                $end = \Carbon\Carbon::parse($booking->end_time);
                $hours = max($performer->minimum_booking_hours ?? 1, $start->diffInHours($end));
                
                $basePrice = $hours * ($performer->base_price ?? 0);
            }
        }

        // Add service fees
        $serviceFee = $basePrice * 0.1; // 10% service fee
        $fees[] = [
            'name' => 'Service Fee',
            'amount' => $serviceFee,
            'type' => 'percentage',
            'value' => 10,
        ];

        // Add processing fees if applicable
        $processingFee = 2.50; // Fixed processing fee
        $fees[] = [
            'name' => 'Processing Fee',
            'amount' => $processingFee,
            'type' => 'fixed',
            'value' => $processingFee,
        ];

        $total = $basePrice + $serviceFee + $processingFee;

        return [
            'base_price' => round($basePrice, 2),
            'fees' => $fees,
            'subtotal' => round($basePrice, 2),
            'total_fees' => round($serviceFee + $processingFee, 2),
            'total' => round($total, 2),
            'currency' => $booking->currency ?? 'USD',
        ];
    }

    /**
     * Update booking with quote
     */
    public function updateQuote(Booking $booking): Booking
    {
        $quote = $this->calculateQuote($booking);

        $booking->update([
            'total_amount' => $quote['total'],
            'currency' => $quote['currency'],
            'metadata' => array_merge($booking->metadata ?? [], [
                'quote' => $quote,
                'quote_generated_at' => now()->toISOString(),
            ]),
        ]);

        return $booking->fresh();
    }

    /**
     * Advance booking to next step
     */
    public function advanceToNextStep(Booking $booking): Booking
    {
        $currentStep = $this->getCurrentStep($booking);
        $steps = $this->getStepsForBookingType($booking->booking_type);
        $currentIndex = array_search($currentStep, $steps, true);

        if ($currentIndex === false || $currentIndex >= count($steps) - 1) {
            return $booking;
        }

        $nextStep = $steps[$currentIndex + 1];

        return match ($nextStep) {
            self::STEP_QUOTE => $this->advanceToQuote($booking),
            self::STEP_REVIEW => $this->advanceToReview($booking),
            self::STEP_PAYMENT => $this->advanceToPayment($booking),
            self::STEP_CONFIRMATION => $this->advanceToConfirmation($booking),
            self::STEP_COMPLETED => $this->advanceToCompleted($booking),
            default => $booking,
        };
    }

    /**
     * Advance booking to quote step
     */
    private function advanceToQuote(Booking $booking): Booking
    {
        return $this->updateQuote($booking);
    }

    /**
     * Advance booking to review step
     */
    private function advanceToReview(Booking $booking): Booking
    {
        $booking->update([
            'status' => 'confirmed',
            'metadata' => array_merge($booking->metadata ?? [], [
                'reviewed_at' => now()->toISOString(),
            ]),
        ]);

        return $booking->fresh();
    }

    /**
     * Advance booking to payment step
     */
    private function advanceToPayment(Booking $booking): Booking
    {
        // Payment step is handled by payment processing
        return $booking;
    }

    /**
     * Advance booking to confirmation step
     */
    private function advanceToConfirmation(Booking $booking): Booking
    {
        if ($booking->payment_status === 'paid' || $booking->payment_status === 'partially_paid') {
            $booking->update([
                'status' => 'confirmed',
                'confirmed_at' => now(),
                'metadata' => array_merge($booking->metadata ?? [], [
                    'confirmed_at' => now()->toISOString(),
                ]),
            ]);
        }

        return $booking->fresh();
    }

    /**
     * Advance booking to completed step
     */
    private function advanceToCompleted(Booking $booking): Booking
    {
        $booking->update([
            'status' => 'completed',
            'metadata' => array_merge($booking->metadata ?? [], [
                'completed_at' => now()->toISOString(),
            ]),
        ]);

        return $booking->fresh();
    }

    /**
     * Get financial breakdown for a booking
     */
    public function getFinancialBreakdown(Booking $booking): array
    {
        $quote = $booking->metadata['quote'] ?? $this->calculateQuote($booking);

        return [
            'base_price' => $quote['base_price'] ?? $booking->total_amount,
            'fees' => $quote['fees'] ?? [],
            'subtotal' => $quote['subtotal'] ?? $booking->total_amount,
            'total_fees' => $quote['total_fees'] ?? 0,
            'discount' => $booking->metadata['discount'] ?? 0,
            'total' => $quote['total'] ?? $booking->total_amount,
            'paid' => $booking->paid_amount ?? 0,
            'remaining' => ($quote['total'] ?? $booking->total_amount) - ($booking->paid_amount ?? 0),
            'currency' => $booking->currency ?? 'USD',
        ];
    }

    /**
     * Validate booking can proceed to next step
     */
    public function canProceedToNextStep(Booking $booking): array
    {
        $currentStep = $this->getCurrentStep($booking);
        $canProceed = false;
        $reason = '';

        return match ($currentStep) {
            self::STEP_INITIAL_REQUEST => [
                'can_proceed' => true,
                'reason' => '',
            ],
            self::STEP_QUOTE => [
                'can_proceed' => $booking->total_amount > 0,
                'reason' => $booking->total_amount > 0 ? '' : 'Quote not generated',
            ],
            self::STEP_REVIEW => [
                'can_proceed' => $booking->status === 'confirmed',
                'reason' => $booking->status === 'confirmed' ? '' : 'Booking not confirmed',
            ],
            self::STEP_PAYMENT => [
                'can_proceed' => $booking->payment_status === 'paid' || $booking->payment_status === 'partially_paid',
                'reason' => ($booking->payment_status === 'paid' || $booking->payment_status === 'partially_paid') ? '' : 'Payment not completed',
            ],
            self::STEP_CONFIRMATION => [
                'can_proceed' => $booking->status === 'confirmed' && ($booking->payment_status === 'paid' || $booking->payment_status === 'partially_paid'),
                'reason' => ($booking->status === 'confirmed' && ($booking->payment_status === 'paid' || $booking->payment_status === 'partially_paid')) ? '' : 'Not ready for confirmation',
            ],
            default => [
                'can_proceed' => false,
                'reason' => 'Already completed',
            ],
        };
    }
}
```

### BusinessService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\Business;
use App\Models\Region;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Pagination\LengthAwarePaginator;

final class BusinessService
{
    public function __construct(
        private readonly GeocodingService $geocodingService,
        private readonly CacheService $cacheService
    ) {}

    /**
     * Create a new business
     */
    public function create(array $data): Business
    {
        // Geocode address if provided
        if (isset($data['address']) && !isset($data['latitude'], $data['longitude'])) {
            $geocoded = $this->geocodingService->geocodeAddress(
                $data['address'],
                $data['city'] ?? null,
                $data['state'] ?? null,
                $data['postal_code'] ?? null,
                $data['country'] ?? null
            );

            if ($geocoded) {
                $data['latitude'] = $geocoded['latitude'];
                $data['longitude'] = $geocoded['longitude'];
                $data['google_place_id'] = $geocoded['place_id'] ?? null;
            }
        }

        $business = Business::create($data);

        // Attach regions if provided
        if (isset($data['regions']) && is_array($data['regions'])) {
            $business->regions()->sync($data['regions']);
        }

        // Clear cache
        $this->clearBusinessCache($business);

        return $business->fresh(['regions']);
    }

    /**
     * Update an existing business
     */
    public function update(Business $business, array $data): Business
    {
        // Geocode address if changed
        $addressChanged = isset($data['address']) || isset($data['city']) || isset($data['state']) || isset($data['postal_code']);
        
        if ($addressChanged && !isset($data['latitude'], $data['longitude'])) {
            $geocoded = $this->geocodingService->geocodeAddress(
                $data['address'] ?? $business->address,
                $data['city'] ?? $business->city,
                $data['state'] ?? $business->state,
                $data['postal_code'] ?? $business->postal_code,
                $data['country'] ?? $business->country
            );

            if ($geocoded) {
                $data['latitude'] = $geocoded['latitude'];
                $data['longitude'] = $geocoded['longitude'];
                $data['google_place_id'] = $geocoded['place_id'] ?? null;
            }
        }

        $business->update($data);

        // Update regions if provided
        if (isset($data['regions']) && is_array($data['regions'])) {
            $business->regions()->sync($data['regions']);
        }

        // Clear cache
        $this->clearBusinessCache($business);

        return $business->fresh(['regions']);
    }

    /**
     * Find a business by ID
     */
    public function find(string $id): ?Business
    {
        $cacheKey = "business:{$id}";
        
        return $this->cacheService->remember($cacheKey, now()->addHours(1), function () use ($id) {
            return Business::with(['regions', 'workspace'])->find($id);
        });
    }

    /**
     * Find a business by slug
     */
    public function findBySlug(string $slug): ?Business
    {
        $cacheKey = "business:slug:{$slug}";
        
        return $this->cacheService->remember($cacheKey, CacheService::DURATION_LONG, function () use ($slug) {
            return Business::with(['regions', 'workspace'])->where('slug', $slug)->first();
        });
    }

    /**
     * Search businesses
     */
    public function search(
        string $query = null,
        array $filters = [],
        int $perPage = 20,
        int $page = 1
    ): LengthAwarePaginator {
        $cacheKey = 'business:search:'.md5(serialize([$query, $filters, $perPage, $page]));
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(5), function () use ($query, $filters, $perPage, $page) {
            $searchQuery = Business::query();

            // Search query
            if ($query) {
                $searchQuery->where(function ($q) use ($query) {
                    $q->where('name', 'like', "%{$query}%")
                      ->orWhere('description', 'like', "%{$query}%")
                      ->orWhere('address', 'like', "%{$query}%")
                      ->orWhere('city', 'like', "%{$query}%");
                });
            }

            // Filters
            if (isset($filters['region_id'])) {
                $searchQuery->whereHas('regions', function ($q) use ($filters) {
                    $q->where('regions.id', $filters['region_id']);
                });
            }

            if (isset($filters['category'])) {
                $searchQuery->byCategory($filters['category']);
            }

            if (isset($filters['status'])) {
                $searchQuery->where('status', $filters['status']);
            }

            if (isset($filters['is_verified'])) {
                $searchQuery->where('is_verified', $filters['is_verified']);
            }

            if (isset($filters['is_organization'])) {
                $searchQuery->where('is_organization', $filters['is_organization']);
            }

            if (isset($filters['organization_type'])) {
                $searchQuery->where('organization_type', $filters['organization_type']);
            }

            if (isset($filters['organization_level'])) {
                $searchQuery->where('organization_level', $filters['organization_level']);
            }

            // Location filter
            if (isset($filters['latitude'], $filters['longitude'], $filters['radius'])) {
                $searchQuery->withinRadius(
                    (float) $filters['latitude'],
                    (float) $filters['longitude'],
                    (float) $filters['radius']
                );
            }

            // Sorting
            $sortBy = $filters['sort_by'] ?? 'name';
            $sortOrder = $filters['sort_order'] ?? 'asc';
            
            if ($sortBy === 'rating') {
                $searchQuery->orderBy('rating', $sortOrder);
            } elseif ($sortBy === 'reviews_count') {
                $searchQuery->orderBy('reviews_count', $sortOrder);
            } elseif ($sortBy === 'distance' && isset($filters['latitude'], $filters['longitude'])) {
                $searchQuery->orderBy('distance', $sortOrder);
            } else {
                $searchQuery->orderBy($sortBy, $sortOrder);
            }

            return $searchQuery->with(['regions', 'workspace'])
                ->paginate($perPage, ['*'], 'page', $page);
        });
    }

    /**
     * Get businesses by region
     */
    public function getByRegion(Region|string $region, int $limit = 50): Collection
    {
        $regionId = $region instanceof Region ? $region->id : $region;
        $cacheKey = "businesses:region:{$regionId}:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($regionId, $limit) {
            return Business::whereHas('regions', function ($q) use ($regionId) {
                $q->where('regions.id', $regionId);
            })
            ->active()
            ->with(['regions'])
            ->limit($limit)
            ->get();
        });
    }

    /**
     * Get businesses by category
     */
    public function getByCategory(string $category, int $limit = 50): Collection
    {
        $cacheKey = "businesses:category:{$category}:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($category, $limit) {
            return Business::byCategory($category)
                ->active()
                ->with(['regions'])
                ->limit($limit)
                ->get();
        });
    }

    /**
     * Get featured businesses
     */
    public function getFeatured(int $limit = 10): Collection
    {
        $cacheKey = "businesses:featured:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(30), function () use ($limit) {
            return Business::where('featured', true)
                ->active()
                ->verified()
                ->with(['regions'])
                ->orderBy('rating', 'desc')
                ->limit($limit)
                ->get();
        });
    }

    /**
     * Get businesses within radius
     */
    public function getWithinRadius(float $latitude, float $longitude, float $radiusKm, int $limit = 50): Collection
    {
        $cacheKey = "businesses:radius:{$latitude}:{$longitude}:{$radiusKm}:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(5), function () use ($latitude, $longitude, $radiusKm, $limit) {
            return Business::withinRadius($latitude, $longitude, $radiusKm)
                ->active()
                ->with(['regions'])
                ->orderBy('distance', 'asc')
                ->limit($limit)
                ->get();
        });
    }

    /**
     * Delete a business
     */
    public function delete(Business $business): bool
    {
        $id = $business->id;
        $result = $business->delete();
        
        // Clear cache
        $this->clearBusinessCache($business);
        
        return $result;
    }

    /**
     * Clear business-related cache
     */
    private function clearBusinessCache(Business $business): void
    {
        $this->cacheService->forget("business:{$business->id}");
        $this->cacheService->forget("business:slug:{$business->slug}");
        
        // Clear region caches
        foreach ($business->regions as $region) {
            $this->cacheService->forget("businesses:region:{$region->id}:limit:*");
        }
        
        // Clear category caches
        if ($business->categories) {
            foreach ($business->categories as $category) {
                $this->cacheService->forget("businesses:category:{$category}:limit:*");
            }
        }
        
        // Clear search caches (pattern matching would be ideal, but Cache doesn't support it)
        // In production, consider using Redis with pattern matching or cache tags
    }

    /**
     * Get business by slug or subdomain for AlphaSite page
     */
    public function getBusinessForAlphaSite(string $slugOrSubdomain): ?Business
    {
        $cacheKey = "alphasite:business:{$slugOrSubdomain}";
        
        return $this->cacheService->remember($cacheKey, now()->addHours(1), function () use ($slugOrSubdomain) {
            return Business::with([
                'industry',
                'template',
                'subscription',
                'achievements' => fn($q) => $q->orderBy('display_order'),
                'reviews' => fn($q) => $q->latest()->limit(10),
                'faqs' => fn($q) => $q->where('is_active', true),
            ])
            ->where('slug', $slugOrSubdomain)
            ->orWhere('alphasite_subdomain', $slugOrSubdomain)
            ->first();
        });
    }

    /**
     * Get businesses by industry for directory
     */
    public function getByIndustry(
        string $industrySlug,
        ?string $city = null,
        ?string $state = null,
        int $perPage = 24
    ): LengthAwarePaginator {
        $query = Business::query()
            ->with(['industry', 'subscription'])
            ->whereHas('industry', fn($q) => $q->where('slug', $industrySlug))
            ->where('status', 'active');
        
        if ($city) {
            $query->where('city', $city);
        }
        
        if ($state) {
            $query->where('state', $state);
        }
        
        return $query
            ->orderByDesc('featured')
            ->orderByDesc('rating')
            ->paginate($perPage);
    }

    /**
     * Get related businesses (same industry, nearby)
     */
    public function getRelatedBusinesses(Business $business, int $limit = 6): Collection
    {
        return Business::query()
            ->with(['industry'])
            ->where('id', '!=', $business->id)
            ->where('industry_id', $business->industry_id)
            ->where('city', $business->city)
            ->where('status', 'active')
            ->orderByDesc('rating')
            ->limit($limit)
            ->get();
    }
}

```

### CacheService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use Illuminate\Support\Facades\Cache;

final class CacheService
{
    /**
     * Cache duration constants (in seconds)
     */
    public const DURATION_SHORT = 300; // 5 minutes
    public const DURATION_MEDIUM = 1800; // 30 minutes
    public const DURATION_LONG = 3600; // 1 hour
    public const DURATION_DAY = 86400; // 24 hours

    /**
     * Cache key prefixes
     */
    public const PREFIX_EVENT = 'event:';
    public const PREFIX_VENUE = 'venue:';
    public const PREFIX_PERFORMER = 'performer:';
    public const PREFIX_HUB = 'hub:';
    public const PREFIX_WEATHER = 'weather:';
    public const PREFIX_FEATURED = 'featured:';
    public const PREFIX_TRENDING = 'trending:';

    /**
     * Get cached value or execute callback and cache result
     */
    public function remember(string $key, int $duration, callable $callback): mixed
    {
        return Cache::remember($key, $duration, $callback);
    }

    /**
     * Cache event data
     */
    public function cacheEvent(string $eventId, callable $callback, int $duration = self::DURATION_MEDIUM): mixed
    {
        return $this->remember(self::PREFIX_EVENT.$eventId, $duration, $callback);
    }

    /**
     * Cache venue data
     */
    public function cacheVenue(string $venueId, callable $callback, int $duration = self::DURATION_MEDIUM): mixed
    {
        return $this->remember(self::PREFIX_VENUE.$venueId, $duration, $callback);
    }

    /**
     * Cache performer data
     */
    public function cachePerformer(string $performerId, callable $callback, int $duration = self::DURATION_MEDIUM): mixed
    {
        return $this->remember(self::PREFIX_PERFORMER.$performerId, $duration, $callback);
    }

    /**
     * Cache hub data
     */
    public function cacheHub(string $hubId, callable $callback, int $duration = self::DURATION_MEDIUM): mixed
    {
        return $this->remember(self::PREFIX_HUB.$hubId, $duration, $callback);
    }

    /**
     * Cache weather data
     */
    public function cacheWeather(string $locationKey, callable $callback, int $duration = self::DURATION_SHORT): mixed
    {
        return $this->remember(self::PREFIX_WEATHER.$locationKey, $duration, $callback);
    }

    /**
     * Cache featured content
     */
    public function cacheFeatured(string $type, callable $callback, int $duration = self::DURATION_MEDIUM): mixed
    {
        return $this->remember(self::PREFIX_FEATURED.$type, $duration, $callback);
    }

    /**
     * Cache trending content
     */
    public function cacheTrending(string $type, callable $callback, int $duration = self::DURATION_SHORT): mixed
    {
        return $this->remember(self::PREFIX_TRENDING.$type, $duration, $callback);
    }

    /**
     * Clear cache for specific key
     */
    public function forget(string $key): bool
    {
        return Cache::forget($key);
    }

    /**
     * Clear cache for event
     */
    public function forgetEvent(string $eventId): bool
    {
        return $this->forget(self::PREFIX_EVENT.$eventId);
    }

    /**
     * Clear cache for venue
     */
    public function forgetVenue(string $venueId): bool
    {
        return $this->forget(self::PREFIX_VENUE.$venueId);
    }

    /**
     * Clear cache for performer
     */
    public function forgetPerformer(string $performerId): bool
    {
        return $this->forget(self::PREFIX_PERFORMER.$performerId);
    }

    /**
     * Clear cache for hub
     */
    public function forgetHub(string $hubId): bool
    {
        return $this->forget(self::PREFIX_HUB.$hubId);
    }

    /**
     * Clear featured cache
     */
    public function forgetFeatured(string $type): bool
    {
        return $this->forget(self::PREFIX_FEATURED.$type);
    }

    /**
     * Clear trending cache
     */
    public function forgetTrending(string $type): bool
    {
        return $this->forget(self::PREFIX_TRENDING.$type);
    }

    /**
     * Clear all cache with prefix
     */
    public function forgetByPrefix(string $prefix): void
    {
        // Implementation depends on cache driver
        // For Redis: use SCAN and delete matching keys
        // For file: clear specific tags if using tag-based caching
    }
}

```

### CalendarService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\Calendar;
use App\Models\Event;
use App\Models\User;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Pagination\LengthAwarePaginator;

final class CalendarService
{
    public function __construct(
        private readonly CacheService $cacheService
    ) {}

    /**
     * Get calendars
     */
    public function getCalendars(array $filters = [], int $perPage = 20): LengthAwarePaginator
    {
        $cacheKey = 'calendars:'.md5(serialize([$filters, $perPage]));
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($filters, $perPage) {
            $query = Calendar::with(['user', 'events']);

            // Filters
            if (isset($filters['user_id'])) {
                $query->where('user_id', $filters['user_id']);
            }

            if (isset($filters['is_private'])) {
                $query->where('is_private', $filters['is_private']);
            } else {
                // Default to public calendars
                $query->public();
            }

            if (isset($filters['category'])) {
                $query->where('category', $filters['category']);
            }

            if (isset($filters['is_verified'])) {
                $query->where('is_verified', $filters['is_verified']);
            }

            // Sorting
            $sortBy = $filters['sort_by'] ?? 'created_at';
            $sortOrder = $filters['sort_order'] ?? 'desc';
            $query->orderBy($sortBy, $sortOrder);

            return $query->paginate($perPage);
        });
    }

    /**
     * Get public calendars
     */
    public function getPublicCalendars(int $limit = 20): Collection
    {
        $cacheKey = "calendars:public:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(30), function () use ($limit) {
            return Calendar::public()
                ->verified()
                ->with(['user'])
                ->orderBy('followers_count', 'desc')
                ->limit($limit)
                ->get();
        });
    }

    /**
     * Get calendar events
     */
    public function getEvents(Calendar|string $calendar, array $filters = []): Collection
    {
        $calendarId = $calendar instanceof Calendar ? $calendar->id : $calendar;
        $cacheKey = "calendar:events:{$calendarId}:".md5(serialize($filters));
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($calendarId, $filters) {
            $calendar = Calendar::with('events')->findOrFail($calendarId);
            $events = $calendar->events;

            // Apply filters
            if (isset($filters['date_from'])) {
                $events = $events->filter(function ($event) use ($filters) {
                    return $event->event_date >= $filters['date_from'];
                });
            }

            if (isset($filters['date_to'])) {
                $events = $events->filter(function ($event) use ($filters) {
                    return $event->event_date <= $filters['date_to'];
                });
            }

            if (isset($filters['category'])) {
                $events = $events->filter(function ($event) use ($filters) {
                    return $event->category === $filters['category'];
                });
            }

            return $events->values();
        });
    }

    /**
     * Add event to calendar
     */
    public function addEvent(Calendar $calendar, Event $event, ?User $addedBy = null): void
    {
        // Check if event already in calendar
        if ($calendar->events()->where('event_id', $event->id)->exists()) {
            return;
        }

        // Get current max position
        $maxPosition = $calendar->events()->max('calendar_events.position') ?? 0;

        $calendar->events()->attach($event->id, [
            'added_by' => $addedBy?->id,
            'position' => $maxPosition + 1,
        ]);

        // Update events count
        $calendar->increment('events_count');

        // Clear cache
        $this->clearCalendarCache($calendar);
    }

    /**
     * Remove event from calendar
     */
    public function removeEvent(Calendar $calendar, Event $event): void
    {
        $calendar->events()->detach($event->id);

        // Update events count
        $calendar->decrement('events_count');

        // Clear cache
        $this->clearCalendarCache($calendar);
    }

    /**
     * Reorder calendar events
     */
    public function reorderEvents(Calendar $calendar, array $eventIds): void
    {
        foreach ($eventIds as $position => $eventId) {
            $calendar->events()->updateExistingPivot($eventId, [
                'position' => $position + 1,
            ]);
        }

        // Clear cache
        $this->clearCalendarCache($calendar);
    }

    /**
     * Follow calendar
     */
    public function followCalendar(Calendar $calendar, User $user): void
    {
        if (!$calendar->followers()->where('user_id', $user->id)->exists()) {
            $calendar->followers()->attach($user->id);
            $calendar->increment('followers_count');
            $this->clearCalendarCache($calendar);
        }
    }

    /**
     * Unfollow calendar
     */
    public function unfollowCalendar(Calendar $calendar, User $user): void
    {
        if ($calendar->followers()->where('user_id', $user->id)->exists()) {
            $calendar->followers()->detach($user->id);
            $calendar->decrement('followers_count');
            $this->clearCalendarCache($calendar);
        }
    }

    /**
     * Get user calendars
     */
    public function getUserCalendars(User|string $user): Collection
    {
        $userId = $user instanceof User ? $user->id : $user;
        $cacheKey = "calendars:user:{$userId}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($userId) {
            return Calendar::where('user_id', $userId)
                ->with(['events', 'followers'])
                ->orderBy('created_at', 'desc')
                ->get();
        });
    }

    /**
     * Clear calendar-related cache
     */
    private function clearCalendarCache(Calendar $calendar): void
    {
        $this->cacheService->forget('calendars:*');
        $this->cacheService->forget("calendar:events:{$calendar->id}:*");
        $this->cacheService->forget("calendars:user:{$calendar->user_id}");
    }
}

```

### CheckInService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\CheckIn;
use App\Models\Event;
use App\Models\User;

final class CheckInService
{
    public function checkIn(User $user, Event $event, array $data = []): CheckIn
    {
        // Check if already checked in
        $existingCheckIn = CheckIn::where('event_id', $event->id)
            ->where('user_id', $user->id)
            ->first();

        if ($existingCheckIn) {
            return $existingCheckIn;
        }

        $checkIn = CheckIn::create([
            'event_id' => $event->id,
            'user_id' => $user->id,
            'checked_in_at' => now(),
            'location' => $data['location'] ?? null,
            'latitude' => $data['latitude'] ?? null,
            'longitude' => $data['longitude'] ?? null,
            'notes' => $data['notes'] ?? null,
            'is_public' => $data['is_public'] ?? true,
        ]);

        // Update event attendance
        $event->increment('member_attendance');

        return $checkIn;
    }

    public function removeCheckIn(CheckIn $checkIn): bool
    {
        $event = $checkIn->event;
        $deleted = $checkIn->delete();

        if ($deleted && $event) {
            $event->decrement('member_attendance');
        }

        return $deleted;
    }

    public function getEventCheckIns(Event $event, bool $publicOnly = true): \Illuminate\Database\Eloquent\Collection
    {
        $query = CheckIn::where('event_id', $event->id)
            ->with('user')
            ->recent(24)
            ->latest('checked_in_at');

        if ($publicOnly) {
            $query->public();
        }

        return $query->get();
    }

    public function getUserCheckIns(User $user, int $limit = 20): \Illuminate\Database\Eloquent\Collection
    {
        return CheckIn::where('user_id', $user->id)
            ->with(['event.venue'])
            ->latest('checked_in_at')
            ->limit($limit)
            ->get();
    }
}

```

### CouponService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\Coupon;
use App\Models\CouponUsage;
use App\Models\Business;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Support\Facades\DB;

final class CouponService
{
    public function __construct(
        private readonly CacheService $cacheService
    ) {}

    /**
     * Create a new coupon
     */
    public function create(array $data, int $userId): Coupon
    {
        $coupon = Coupon::create([
            'user_id' => $userId,
            'business_id' => $data['business_id'] ?? null,
            'title' => $data['title'],
            'description' => $data['description'] ?? null,
            'discount_type' => $data['discount_type'],
            'discount_value' => $data['discount_value'],
            'terms' => $data['terms'] ?? null,
            'code' => $data['code'] ?? $this->generateUniqueCode(),
            'image' => $data['image'] ?? null,
            'business_name' => $data['business_name'] ?? null,
            'business_location' => $data['business_location'] ?? null,
            'start_date' => $data['start_date'] ?? now(),
            'end_date' => $data['end_date'] ?? null,
            'usage_limit' => $data['usage_limit'] ?? null,
            'used_count' => 0,
            'status' => $data['status'] ?? 'active',
        ]);

        // Attach regions if provided
        if (isset($data['regions']) && is_array($data['regions'])) {
            $coupon->regions()->sync($data['regions']);
        }

        // Clear cache
        $this->clearCouponCache($coupon);

        return $coupon->fresh(['regions', 'business']);
    }

    /**
     * Update an existing coupon
     */
    public function update(Coupon $coupon, array $data): Coupon
    {
        $coupon->update($data);

        // Update regions if provided
        if (isset($data['regions']) && is_array($data['regions'])) {
            $coupon->regions()->sync($data['regions']);
        }

        // Clear cache
        $this->clearCouponCache($coupon);

        return $coupon->fresh(['regions', 'business']);
    }

    /**
     * Validate a coupon code
     */
    public function validate(string $code, ?int $userId = null): array
    {
        $coupon = Coupon::where('code', $code)->first();

        if (!$coupon) {
            return [
                'valid' => false,
                'error' => 'Coupon code not found',
            ];
        }

        // Check status
        if ($coupon->status !== 'active') {
            return [
                'valid' => false,
                'error' => 'Coupon is not active',
            ];
        }

        // Check dates
        if ($coupon->start_date && $coupon->start_date->isFuture()) {
            return [
                'valid' => false,
                'error' => 'Coupon has not started yet',
            ];
        }

        if ($coupon->end_date && $coupon->end_date->isPast()) {
            return [
                'valid' => false,
                'error' => 'Coupon has expired',
            ];
        }

        // Check usage limit
        if ($coupon->usage_limit && $coupon->used_count >= $coupon->usage_limit) {
            return [
                'valid' => false,
                'error' => 'Coupon usage limit reached',
            ];
        }

        // Check if user already used this coupon (if userId provided)
        if ($userId && $this->hasUserUsedCoupon($coupon, $userId)) {
            return [
                'valid' => false,
                'error' => 'You have already used this coupon',
            ];
        }

        return [
            'valid' => true,
            'coupon' => $coupon,
            'discount_type' => $coupon->discount_type,
            'discount_value' => $coupon->discount_value,
        ];
    }

    /**
     * Apply a coupon (record usage)
     */
    public function apply(Coupon $coupon, int $userId, ?float $orderAmount = null): CouponUsage
    {
        DB::beginTransaction();
        
        try {
            // Validate before applying
            $validation = $this->validate($coupon->code, $userId);
            
            if (!$validation['valid']) {
                throw new \Exception($validation['error']);
            }

            // Create usage record
            $usage = CouponUsage::create([
                'coupon_id' => $coupon->id,
                'user_id' => $userId,
                'order_amount' => $orderAmount,
                'discount_amount' => $this->calculateDiscount($coupon, $orderAmount),
                'used_at' => now(),
            ]);

            // Update coupon usage count
            $coupon->increment('used_count');

            // Increment clicks count
            $coupon->increment('clicks_count');

            DB::commit();

            // Clear cache
            $this->clearCouponCache($coupon);

            return $usage;
        } catch (\Exception $e) {
            DB::rollBack();
            throw $e;
        }
    }

    /**
     * Track coupon view (for analytics)
     */
    public function trackView(Coupon $coupon): void
    {
        $coupon->increment('views_count');
        $this->clearCouponCache($coupon);
    }

    /**
     * Track coupon click (for analytics)
     */
    public function trackClick(Coupon $coupon): void
    {
        $coupon->increment('clicks_count');
        $this->clearCouponCache($coupon);
    }

    /**
     * Get active coupons
     */
    public function getActiveCoupons(array $filters = [], int $limit = 50): Collection
    {
        $cacheKey = 'coupons:active:'.md5(serialize([$filters, $limit]));
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($filters, $limit) {
            $query = Coupon::where('status', 'active')
                ->where(function ($q) {
                    $q->whereNull('start_date')
                      ->orWhere('start_date', '<=', now());
                })
                ->where(function ($q) {
                    $q->whereNull('end_date')
                      ->orWhere('end_date', '>=', now());
                })
                ->where(function ($q) {
                    $q->whereNull('usage_limit')
                      ->orWhereColumn('used_count', '<', 'usage_limit');
                });

            // Filters
            if (isset($filters['business_id'])) {
                $query->where('business_id', $filters['business_id']);
            }

            if (isset($filters['region_id'])) {
                $query->whereHas('regions', function ($q) use ($filters) {
                    $q->where('regions.id', $filters['region_id']);
                });
            }

            if (isset($filters['category'])) {
                // Assuming coupons have categories or are linked via business
                // Adjust based on your schema
            }

            // Sorting
            $sortBy = $filters['sort_by'] ?? 'created_at';
            $sortOrder = $filters['sort_order'] ?? 'desc';
            $query->orderBy($sortBy, $sortOrder);

            return $query->with(['business', 'regions'])
                ->limit($limit)
                ->get();
        });
    }

    /**
     * Get coupons for a business
     */
    public function getCouponsForBusiness(Business|string $business, bool $activeOnly = true): Collection
    {
        $businessId = $business instanceof Business ? $business->id : $business;
        $cacheKey = "coupons:business:{$businessId}:".($activeOnly ? 'active' : 'all');
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($businessId, $activeOnly) {
            $query = Coupon::where('business_id', $businessId);

            if ($activeOnly) {
                $query->where('status', 'active')
                    ->where(function ($q) {
                        $q->whereNull('start_date')
                          ->orWhere('start_date', '<=', now());
                    })
                    ->where(function ($q) {
                        $q->whereNull('end_date')
                          ->orWhere('end_date', '>=', now());
                    });
            }

            return $query->with(['regions'])
                ->orderBy('created_at', 'desc')
                ->get();
        });
    }

    /**
     * Check if user has used a coupon
     */
    public function hasUserUsedCoupon(Coupon $coupon, int $userId): bool
    {
        return CouponUsage::where('coupon_id', $coupon->id)
            ->where('user_id', $userId)
            ->exists();
    }

    /**
     * Calculate discount amount
     */
    public function calculateDiscount(Coupon $coupon, ?float $orderAmount = null): float
    {
        if ($coupon->discount_type === 'percentage') {
            if (!$orderAmount) {
                return 0.0;
            }
            return round($orderAmount * ($coupon->discount_value / 100), 2);
        }

        // Fixed amount
        return (float) $coupon->discount_value;
    }

    /**
     * Generate unique coupon code
     */
    private function generateUniqueCode(int $length = 8): string
    {
        do {
            $code = strtoupper(substr(md5(uniqid((string) mt_rand(), true)), 0, $length));
        } while (Coupon::where('code', $code)->exists());

        return $code;
    }

    /**
     * Clear coupon-related cache
     */
    private function clearCouponCache(Coupon $coupon): void
    {
        $this->cacheService->forget('coupons:active:*');
        
        if ($coupon->business_id) {
            $this->cacheService->forget("coupons:business:{$coupon->business_id}:*");
        }
    }
}

```

### CrossDomainAuthService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\CrossDomainAuthToken;
use App\Models\User;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;

final class CrossDomainAuthService
{
    /**
     * Generate a cross-domain authentication token for a user
     * Returns the token record and plain token
     */
    public function generateToken(User $user, string $sourceDomain): array
    {
        // Get all configured domains except the source domain
        $allDomains = $this->getAllDomains();
        $targetDomains = array_filter($allDomains, fn($domain) => $domain !== $sourceDomain);

        // Generate secure token (store plain token temporarily)
        $plainToken = Str::random(64);

        // Create token record (expires in 24 hours for testing, configurable)
        // Store plain token in token field (we'll hash it when validating)
        $expirationMinutes = (int) config('auth.cross_domain_token_expiration', 1440); // Default 24 hours
        $tokenRecord = CrossDomainAuthToken::create([
            'user_id' => $user->id,
            'token' => $plainToken, // Store plain token, hash on validation
            'source_domain' => $sourceDomain,
            'target_domains' => array_values($targetDomains),
            'expires_at' => now()->addMinutes($expirationMinutes),
            'used' => false,
        ]);

        return [
            'token_record' => $tokenRecord,
            'plain_token' => $plainToken,
        ];
    }

    /**
     * Validate and use a cross-domain auth token
     */
    public function validateAndUseToken(string $token, string $currentDomain): ?User
    {
        // Find unused, non-expired tokens
        $tokenRecord = CrossDomainAuthToken::where('used', false)
            ->where('expires_at', '>', now())
            ->where('token', $token) // Direct comparison since we store plain token
            ->first();

        if (!$tokenRecord) {
            return null;
        }

        // Check if current domain is in target domains
        $targetDomains = $tokenRecord->target_domains ?? [];
        if (!in_array($currentDomain, $targetDomains)) {
            return null;
        }

        // Mark as used
        $tokenRecord->markAsUsed();

        // Return the user
        return $tokenRecord->user;
    }

    /**
     * Get all configured domains from config
     */
    public function getAllDomains(): array
    {
        $domains = config('domains', []);
        
        return array_filter([
            $domains['event-city'] ?? null,
            $domains['day-news'] ?? null,
            $domains['downtown-guide'] ?? null,
            $domains['local-voices'] ?? null,
        ]);
    }

    /**
     * Get URLs for cross-domain auth redirects
     */
    public function getAuthUrls(string $plainToken, string $sourceDomain, ?string $returnUrl = null): array
    {
        $targetDomains = $this->getAllDomains();
        $urls = [];

        foreach ($targetDomains as $domain) {
            if ($domain !== $sourceDomain) {
                $protocol = config('app.env') === 'local' ? 'http' : 'https';
                $url = "{$protocol}://{$domain}/cross-domain-auth/sync?token=" . urlencode($plainToken);
                
                if ($returnUrl) {
                    $url .= "&return=" . urlencode($returnUrl);
                }

                $urls[] = $url;
            }
        }

        return $urls;
    }

    /**
     * Clean up expired tokens (should be run via scheduled task)
     */
    public function cleanupExpiredTokens(): int
    {
        return CrossDomainAuthToken::where('expires_at', '<', now())
            ->orWhere('used', true)
            ->delete();
    }
}

```

### DayNewsPaymentService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\Classified;
use App\Models\ClassifiedPayment;
use App\Models\DayNewsPost;
use App\Models\DayNewsPostPayment;
use App\Models\Workspace;
use Exception;
use Stripe\Checkout\Session;
use Stripe\Stripe;
use Stripe\StripeClient;

final class DayNewsPaymentService
{
    private StripeClient $stripe;

    public function __construct(
        private readonly DayNewsPostService $postService
    ) {
        Stripe::setApiKey(config('services.stripe.secret'));
        $this->stripe = new StripeClient(config('services.stripe.secret'));
    }

    public function createCheckoutSession(DayNewsPost $post, Workspace $workspace, string $successUrl, string $cancelUrl): Session
    {
        $amount = $this->postService->calculateCost($post->type, $post->metadata['ad_days'] ?? null);

        $payment = DayNewsPostPayment::create([
            'post_id' => $post->id,
            'workspace_id' => $workspace->id,
            'amount' => $amount,
            'currency' => 'usd',
            'status' => 'pending',
            'payment_type' => $post->type === 'ad' ? 'ad' : 'post',
            'ad_days' => $post->metadata['ad_days'] ?? null,
        ]);

        $session = $this->stripe->checkout->sessions->create([
            'mode' => 'payment',
            'line_items' => [
                [
                    'price_data' => [
                        'currency' => 'usd',
                        'product_data' => [
                            'name' => $this->getProductName($post),
                            'description' => $this->getProductDescription($post),
                        ],
                        'unit_amount' => $amount,
                    ],
                    'quantity' => 1,
                ],
            ],
            'success_url' => $successUrl,
            'cancel_url' => $cancelUrl,
            'metadata' => [
                'post_id' => $post->id,
                'payment_id' => $payment->id,
                'workspace_id' => $workspace->id,
            ],
        ]);

        $payment->update(['stripe_checkout_session_id' => $session->id]);

        return $session;
    }

    public function handleSuccessfulPayment(string $sessionId): DayNewsPost
    {
        $session = $this->stripe->checkout->sessions->retrieve($sessionId);

        $payment = DayNewsPostPayment::where('stripe_checkout_session_id', $sessionId)->firstOrFail();

        $payment->update([
            'stripe_payment_intent_id' => $session->payment_intent,
            'status' => 'paid',
        ]);

        $post = $payment->post;
        $this->postService->publishPost($post);

        return $post;
    }

    public function handleFailedPayment(string $intentId): void
    {
        $payment = DayNewsPostPayment::where('stripe_payment_intent_id', $intentId)->first();

        if ($payment) {
            $payment->markAsFailed();
        }
    }

    public function refundPayment(DayNewsPostPayment $payment): void
    {
        if (! $payment->isPaid() || ! $payment->stripe_payment_intent_id) {
            throw new Exception('Cannot refund payment that is not paid');
        }

        $this->stripe->refunds->create([
            'payment_intent' => $payment->stripe_payment_intent_id,
        ]);

        $payment->update(['status' => 'refunded']);

        $post = $payment->post;
        if ($post->status === 'published') {
            $post->update(['status' => 'removed']);
        }

        foreach ($post->advertisements as $ad) {
            $ad->markAsInactive();
        }
    }

    private function getProductName(DayNewsPost $post): string
    {
        return match ($post->type) {
            'ad' => 'Day News Advertisement',
            'article' => 'Day News Article',
            'announcement' => 'Day News Announcement',
            'notice' => 'Day News Notice',
            'schedule' => 'Day News Schedule',
            default => 'Day News Post',
        };
    }

    private function getProductDescription(DayNewsPost $post): string
    {
        if ($post->type === 'ad') {
            $days = $post->metadata['ad_days'] ?? 7;

            return "Advertisement for {$days} days: {$post->title}";
        }

        return "Post: {$post->title}";
    }

    /**
     * Create Stripe checkout session for classified
     */
    public function createClassifiedCheckoutSession(Classified $classified, ClassifiedPayment $payment, string $successUrl, string $cancelUrl): Session
    {
        $session = $this->stripe->checkout->sessions->create([
            'mode' => 'payment',
            'line_items' => [
                [
                    'price_data' => [
                        'currency' => 'usd',
                        'product_data' => [
                            'name' => 'Classified Listing',
                            'description' => "Classified: {$classified->title}",
                        ],
                        'unit_amount' => $payment->amount,
                    ],
                    'quantity' => 1,
                ],
            ],
            'success_url' => $successUrl . '?session_id={CHECKOUT_SESSION_ID}',
            'cancel_url' => $cancelUrl,
            'metadata' => [
                'classified_id' => $classified->id,
                'payment_id' => $payment->id,
                'workspace_id' => $payment->workspace_id,
                'type' => 'classified',
            ],
        ]);

        $payment->update(['stripe_checkout_session_id' => $session->id]);

        return $session;
    }

    /**
     * Handle successful classified payment
     */
    public function handleSuccessfulClassifiedPayment(string $sessionId): Classified
    {
        $session = $this->stripe->checkout->sessions->retrieve($sessionId);

        $payment = ClassifiedPayment::where('stripe_checkout_session_id', $sessionId)->firstOrFail();

        $payment->update([
            'stripe_payment_intent_id' => $session->payment_intent,
            'status' => 'paid',
        ]);

        return $payment->classified;
    }
}
```

### DayNewsPostService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\DayNewsPost;
use App\Models\User;
use App\Models\Workspace;
use Illuminate\Support\Facades\DB;

final class DayNewsPostService
{
    public function __construct(
        private readonly AdvertisementService $advertisementService
    ) {}

    public function createPost(User $user, Workspace $workspace, array $data): DayNewsPost
    {
        return DB::transaction(function () use ($user, $workspace, $data) {
            $type = $data['type'];
            $category = $data['category'] ?? null;
            $isFree = $this->isPostFree($workspace, $type, $category);

            $post = DayNewsPost::create([
                'workspace_id' => $workspace->id,
                'author_id' => $user->id,
                'type' => $type,
                'category' => $category,
                'title' => $data['title'],
                'slug' => $data['slug'] ?? null,
                'content' => $data['content'],
                'excerpt' => $data['excerpt'] ?? null,
                'featured_image' => $data['featured_image'] ?? null,
                'metadata' => $data['metadata'] ?? null,
                'status' => $isFree ? 'published' : 'draft',
                'published_at' => $isFree ? now() : null,
            ]);

            if (! empty($data['region_ids'])) {
                $post->regions()->sync($data['region_ids']);
            }

            return $post;
        });
    }

    public function updatePost(DayNewsPost $post, array $data): DayNewsPost
    {
        return DB::transaction(function () use ($post, $data) {
            $post->update([
                'type' => $data['type'] ?? $post->type,
                'category' => $data['category'] ?? $post->category,
                'title' => $data['title'] ?? $post->title,
                'content' => $data['content'] ?? $post->content,
                'excerpt' => $data['excerpt'] ?? $post->excerpt,
                'featured_image' => $data['featured_image'] ?? $post->featured_image,
                'metadata' => $data['metadata'] ?? $post->metadata,
            ]);

            if (isset($data['region_ids'])) {
                $post->regions()->sync($data['region_ids']);
            }

            return $post->fresh();
        });
    }

    public function publishPost(DayNewsPost $post): DayNewsPost
    {
        return DB::transaction(function () use ($post) {
            $post->update([
                'status' => 'published',
                'published_at' => now(),
            ]);

            if ($post->type === 'ad' && $post->payment?->isPaid()) {
                $adDays = $post->payment->ad_days ?? 7;
                $post->update([
                    'expires_at' => now()->addDays($adDays),
                ]);

                $regionIds = $post->regions->pluck('id')->toArray();

                $this->advertisementService->createAdvertisement(
                    advertable: $post,
                    platform: 'day_news',
                    config: [
                        'placement' => $post->metadata['ad_placement'] ?? 'sidebar',
                        'regions' => $regionIds,
                        'starts_at' => now(),
                        'expires_at' => now()->addDays($adDays),
                    ]
                );
            }

            return $post->fresh();
        });
    }

    public function isPostFree(Workspace $workspace, string $type, ?string $category): bool
    {
        if ($category && in_array($category, config('services.day_news.free_categories', []))) {
            return true;
        }

        if ($type === 'ad') {
            return false;
        }

        $publishedPostsCount = DayNewsPost::forWorkspace($workspace->id)
            ->where('status', 'published')
            ->whereNotNull('published_at')
            ->count();

        return $publishedPostsCount === 0;
    }

    public function calculateCost(string $type, ?int $adDays = null): int
    {
        if ($type === 'ad') {
            $days = $adDays ?? 7;

            return config('services.day_news.ad_price_per_day') * $days;
        }

        return config('services.day_news.post_price');
    }

    public function expireAds(): int
    {
        $expiredPosts = DayNewsPost::where('type', 'ad')
            ->where('status', 'published')
            ->whereNotNull('expires_at')
            ->where('expires_at', '<=', now())
            ->get();

        foreach ($expiredPosts as $post) {
            $post->update(['status' => 'expired']);

            foreach ($post->advertisements as $ad) {
                $ad->markAsInactive();
            }
        }

        return $expiredPosts->count();
    }

    public function deletePost(DayNewsPost $post): bool
    {
        return DB::transaction(function () use ($post) {
            foreach ($post->advertisements as $ad) {
                $ad->markAsInactive();
            }

            return $post->delete();
        });
    }
}
```

### EmailDeliveryService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\EmailCampaign;
use App\Models\EmailSend;
use App\Models\EmailSubscriber;
use App\Models\EmergencyAlert;
use Illuminate\Support\Facades\Mail;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\View;

final class EmailDeliveryService
{
    /**
     * Send an email campaign send
     */
    public function sendCampaignEmail(EmailSend $send): void
    {
        $campaign = $send->campaign;
        $subscriber = $send->subscriber;

        try {
            // Track opens/clicks with pixel and link tracking
            $trackingPixel = route('email.track.open', ['send' => $send->id]);
            $htmlWithTracking = str_replace('</body>', "<img src=\"{$trackingPixel}\" width=\"1\" height=\"1\" style=\"display:none;\"></body>", $campaign->html_content ?? '');

            // Replace links with tracking URLs
            $htmlWithTracking = preg_replace_callback(
                '/href="([^"]+)"/',
                fn($matches) => 'href="' . route('email.track.click', ['send' => $send->id, 'url' => base64_encode($matches[1])]) . '"',
                $htmlWithTracking
            );

            Mail::send([], [], function ($message) use ($campaign, $subscriber, $htmlWithTracking) {
                $message->to($subscriber->email, $subscriber->full_name)
                    ->subject($campaign->subject)
                    ->html($htmlWithTracking)
                    ->text($campaign->text_content ?? strip_tags($htmlWithTracking));
            });

            $send->update([
                'status' => 'sent',
                'sent_at' => now(),
                'message_id' => 'ses-' . uniqid(), // SES message ID
            ]);

            $campaign->increment('sent_count');
        } catch (\Exception $e) {
            Log::error('Email send failed', [
                'send_id' => $send->id,
                'error' => $e->getMessage(),
            ]);

            $send->update([
                'status' => 'failed',
                'error_message' => $e->getMessage(),
            ]);

            throw $e;
        }
    }

    /**
     * Send emergency alert email
     */
    public function sendEmergencyAlert(EmailSubscriber $subscriber, EmergencyAlert $alert): string
    {
        try {
            $html = $this->renderEmergencyEmailHtml($alert);
            $text = $this->renderEmergencyEmailText($alert);
            $priority = strtoupper($alert->priority);

            Mail::send([], [], function ($message) use ($subscriber, $alert, $priority, $html, $text) {
                $message->to($subscriber->email, $subscriber->full_name)
                    ->subject("[{$priority}] {$alert->title}")
                    ->html($html)
                    ->text($text);
            });

            return 'ses-' . uniqid();
        } catch (\Exception $e) {
            Log::error('Emergency email send failed', [
                'subscriber_id' => $subscriber->id,
                'alert_id' => $alert->id,
                'error' => $e->getMessage(),
            ]);

            throw $e;
        }
    }

    /**
     * Track email open
     */
    public function trackOpen(EmailSend $send): void
    {
        if (!$send->opened_at) {
            $send->update([
                'opened_at' => now(),
                'open_count' => 1,
            ]);

            $send->campaign->increment('opened_count');
        } else {
            $send->increment('open_count');
        }
    }

    /**
     * Track email click
     */
    public function trackClick(EmailSend $send, string $url): string
    {
        if (!$send->clicked_at) {
            $send->update([
                'clicked_at' => now(),
                'click_count' => 1,
            ]);

            $send->campaign->increment('clicked_count');
        } else {
            $send->increment('click_count');
        }

        return base64_decode($url);
    }

    /**
     * Handle bounce
     */
    public function handleBounce(EmailSend $send, string $bounceType, ?string $message = null): void
    {
        $send->update([
            'status' => 'bounced',
            'bounce_type' => $bounceType,
            'error_message' => $message,
        ]);

        $send->campaign->increment('bounced_count');

        // Mark subscriber as bounced if hard bounce
        if ($bounceType === 'hard') {
            $send->subscriber->update(['status' => 'bounced']);
        }
    }

    /**
     * Handle complaint
     */
    public function handleComplaint(EmailSend $send): void
    {
        $send->update(['status' => 'complained']);
        $send->campaign->increment('complained_count');
        $send->subscriber->update(['status' => 'complained']);
    }

    /**
     * Render emergency email HTML
     */
    protected function renderEmergencyEmailHtml(EmergencyAlert $alert): string
    {
        $color = match($alert->priority) {
            'critical' => '#dc2626',
            'urgent' => '#ea580c',
            'advisory' => '#ca8a04',
            'info' => '#2563eb',
            default => '#6b7280',
        };

        // Simple HTML template if view doesn't exist yet
        if (!View::exists('emails.emergency-alert')) {
            return "<!DOCTYPE html><html><body style='font-family: Arial, sans-serif; padding: 20px;'><h2 style='color: {$color};'>{$alert->title}</h2><p>{$alert->message}</p>" . ($alert->instructions ? "<p><strong>Instructions:</strong> {$alert->instructions}</p>" : '') . ($alert->source_url ? "<p><a href='{$alert->source_url}'>More information</a></p>" : '') . "</body></html>";
        }

        return view('emails.emergency-alert', [
            'alert' => $alert,
            'color' => $color,
        ])->render();
    }

    /**
     * Render emergency email text
     */
    protected function renderEmergencyEmailText(EmergencyAlert $alert): string
    {
        return "{$alert->title}\n\n{$alert->message}\n\n" . ($alert->instructions ? "Instructions: {$alert->instructions}\n\n" : '') . ($alert->source_url ? "More info: {$alert->source_url}" : '');
    }
}

```

### EmailGeneratorService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\Community;
use App\Models\EmailCampaign;
use App\Models\EmailSubscriber;
use App\Models\EmailTemplate;
use App\Models\EmailSend;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Collection;

final class EmailGeneratorService
{
    public function __construct(
        private readonly AIContentService $aiService,
        private readonly EmailDeliveryService $deliveryService
    ) {}

    /**
     * Generate daily digest for a community
     */
    public function generateDailyDigest(Community $community): EmailCampaign
    {
        // Gather content for digest
        $content = $this->gatherDigestContent($community);

        // Generate AI-written summaries
        $aiContent = $this->aiService->generateDigestContent($community, $content);

        // Get template
        $template = EmailTemplate::where('slug', 'daily-digest')
            ->where('is_active', true)
            ->first();

        // Create campaign
        $campaign = EmailCampaign::create([
            'community_id' => $community->id,
            'template_id' => $template?->id,
            'name' => "Daily Digest - {$community->name} - " . now()->format('M j, Y'),
            'type' => 'daily_digest',
            'status' => 'scheduled',
            'subject' => $aiContent['subject'] ?? "Daily Digest - {$community->name}",
            'preview_text' => $aiContent['preview'] ?? 'Your daily roundup of local news and events.',
            'html_content' => $this->renderDigestHtml($community, $content, $aiContent, $template),
            'text_content' => $this->renderDigestText($community, $content, $aiContent),
            'segment' => ['type' => 'reader', 'preferences.daily_digest' => true],
            'scheduled_at' => $this->getOptimalSendTime($community, 'daily_digest'),
        ]);

        // Queue recipients
        $this->queueRecipients($campaign);

        return $campaign;
    }

    /**
     * Generate weekly newsletter for a community
     */
    public function generateWeeklyNewsletter(Community $community): EmailCampaign
    {
        // Gather week's content
        $content = $this->gatherWeeklyContent($community);

        // Generate AI editorial
        $aiContent = $this->aiService->generateNewsletterContent($community, $content);

        $template = EmailTemplate::where('slug', 'weekly-newsletter')
            ->where('is_active', true)
            ->first();

        $campaign = EmailCampaign::create([
            'community_id' => $community->id,
            'template_id' => $template?->id,
            'name' => "Weekly Newsletter - {$community->name} - Week of " . now()->format('M j'),
            'type' => 'weekly_newsletter',
            'status' => 'scheduled',
            'subject' => $aiContent['subject'] ?? "Weekly Newsletter - {$community->name}",
            'preview_text' => $aiContent['preview'] ?? 'Your weekly roundup of local news and events.',
            'html_content' => $this->renderNewsletterHtml($community, $content, $aiContent, $template),
            'text_content' => $this->renderNewsletterText($community, $content, $aiContent),
            'segment' => ['preferences.weekly_newsletter' => true],
            'scheduled_at' => $this->getOptimalSendTime($community, 'weekly_newsletter'),
        ]);

        $this->queueRecipients($campaign);

        return $campaign;
    }

    /**
     * Generate breaking news alert
     */
    public function generateBreakingNews(Community $community, array $newsData): EmailCampaign
    {
        $campaign = EmailCampaign::create([
            'community_id' => $community->id,
            'name' => "Breaking: {$newsData['headline']}",
            'type' => 'breaking_news',
            'status' => 'sending', // Send immediately
            'subject' => "Breaking: {$newsData['headline']}",
            'preview_text' => substr($newsData['summary'] ?? '', 0, 150),
            'html_content' => $this->renderBreakingNewsHtml($community, $newsData),
            'text_content' => $this->renderBreakingNewsText($community, $newsData),
            'segment' => ['type' => 'reader', 'preferences.breaking_news' => true],
            'started_at' => now(),
        ]);

        $this->queueRecipients($campaign, true); // Priority queue

        return $campaign;
    }

    /**
     * Generate SMB performance report
     */
    public function generateSmbReport(Community $community): EmailCampaign
    {
        $template = EmailTemplate::where('slug', 'smb-weekly-report')
            ->where('is_active', true)
            ->first();

        $campaign = EmailCampaign::create([
            'community_id' => $community->id,
            'template_id' => $template?->id,
            'name' => "SMB Weekly Report - {$community->name} - " . now()->format('M j'),
            'type' => 'smb_report',
            'status' => 'scheduled',
            'subject' => "Your Weekly Performance Report - " . now()->format('M j'),
            'preview_text' => "See how your business performed this week",
            'segment' => ['type' => 'smb'],
            'scheduled_at' => now()->next('Monday')->setTime(7, 0),
        ]);

        // SMB reports are personalized per business, handled differently
        $this->queueSmbReportRecipients($campaign);

        return $campaign;
    }

    /**
     * Gather content for daily digest
     */
    protected function gatherDigestContent(Community $community): array
    {
        return [
            'top_stories' => DB::table('day_news_posts')
                ->where('community_id', $community->id)
                ->where('published_at', '>=', now()->subDay())
                ->where('status', 'published')
                ->orderByDesc('view_count')
                ->limit(5)
                ->get(),
            'upcoming_events' => DB::table('events')
                ->where('community_id', $community->id)
                ->where('start_date', '>=', now())
                ->where('start_date', '<=', now()->addDays(7))
                ->where('status', 'published')
                ->orderBy('start_date')
                ->limit(5)
                ->get(),
            'featured_businesses' => DB::table('businesses')
                ->where('community_id', $community->id)
                ->where('is_featured', true)
                ->inRandomOrder()
                ->limit(3)
                ->get(),
        ];
    }

    /**
     * Gather content for weekly newsletter
     */
    protected function gatherWeeklyContent(Community $community): array
    {
        return [
            'top_stories' => DB::table('day_news_posts')
                ->where('community_id', $community->id)
                ->where('published_at', '>=', now()->subWeek())
                ->where('status', 'published')
                ->orderByDesc('view_count')
                ->limit(10)
                ->get(),
            'events' => DB::table('events')
                ->where('community_id', $community->id)
                ->where('start_date', '>=', now())
                ->where('start_date', '<=', now()->addWeek())
                ->where('status', 'published')
                ->orderBy('start_date')
                ->limit(10)
                ->get(),
        ];
    }

    /**
     * Get optimal send time for community based on timezone and type
     */
    protected function getOptimalSendTime(Community $community, string $type): \Carbon\Carbon
    {
        $timezone = $community->timezone ?? 'America/New_York';
        $times = [
            'daily_digest' => '06:00',
            'weekly_newsletter' => '08:00',
            'smb_report' => '07:00',
        ];
        $time = $times[$type] ?? '09:00';

        return now($timezone)->setTimeFromTimeString($time)->setTimezone('UTC');
    }

    /**
     * Queue recipients for campaign
     */
    protected function queueRecipients(EmailCampaign $campaign, bool $priority = false): void
    {
        $query = EmailSubscriber::where('community_id', $campaign->community_id)
            ->where('status', 'active');

        // Apply segment filters
        if ($segment = $campaign->segment) {
            foreach ($segment as $key => $value) {
                if (str_starts_with($key, 'preferences.')) {
                    $prefKey = str_replace('preferences.', '', $key);
                    $query->whereJsonContains("preferences->{$prefKey}", $value);
                } else {
                    $query->where($key, $value);
                }
            }
        }

        $subscribers = $query->get();
        $campaign->update(['total_recipients' => $subscribers->count()]);

        foreach ($subscribers->chunk(100) as $chunk) {
            $sends = $chunk->map(fn($sub) => [
                'campaign_id' => $campaign->id,
                'subscriber_id' => $sub->id,
                'status' => 'queued',
                'created_at' => now(),
                'updated_at' => now(),
            ])->toArray();

            EmailSend::insert($sends);
        }
    }

    /**
     * Queue SMB report recipients (personalized per business)
     */
    protected function queueSmbReportRecipients(EmailCampaign $campaign): void
    {
        $subscribers = EmailSubscriber::where('community_id', $campaign->community_id)
            ->where('type', 'smb')
            ->where('status', 'active')
            ->whereNotNull('business_id')
            ->get();

        $campaign->update(['total_recipients' => $subscribers->count()]);

        foreach ($subscribers as $subscriber) {
            EmailSend::create([
                'campaign_id' => $campaign->id,
                'subscriber_id' => $subscriber->id,
                'status' => 'queued',
            ]);
        }
    }

    /**
     * Render digest HTML
     */
    protected function renderDigestHtml(Community $community, array $content, array $aiContent, ?EmailTemplate $template): string
    {
        // Get ads for email
        $ads = app(AdServerService::class)->getEmailAds($community->id, 'daily_digest', 2);

        return view('emails.digest', [
            'community' => $community,
            'content' => $content,
            'aiContent' => $aiContent,
            'ads' => $ads,
        ])->render();
    }

    /**
     * Render digest text
     */
    protected function renderDigestText(Community $community, array $content, array $aiContent): string
    {
        $text = ($aiContent['intro'] ?? '') . "\n\n";
        foreach ($content['top_stories'] ?? [] as $story) {
            $text .= ($story->title ?? 'Untitled') . "\n";
            $text .= substr($story->excerpt ?? $story->content ?? '', 0, 200) . "\n\n";
        }
        return $text;
    }

    /**
     * Render newsletter HTML
     */
    protected function renderNewsletterHtml(Community $community, array $content, array $aiContent, ?EmailTemplate $template): string
    {
        return view('emails.newsletter', [
            'community' => $community,
            'content' => $content,
            'aiContent' => $aiContent,
        ])->render();
    }

    /**
     * Render newsletter text
     */
    protected function renderNewsletterText(Community $community, array $content, array $aiContent): string
    {
        return ($aiContent['editorial'] ?? '') . "\n\n" . "Top Stories:\n" . collect($content['top_stories'] ?? [])->map(fn($s) => ($s->title ?? 'Untitled') . "\n" . substr($s->excerpt ?? '', 0, 200))->join("\n\n");
    }

    /**
     * Render breaking news HTML
     */
    protected function renderBreakingNewsHtml(Community $community, array $newsData): string
    {
        return view('emails.breaking-news', [
            'community' => $community,
            'newsData' => $newsData,
        ])->render();
    }

    /**
     * Render breaking news text
     */
    protected function renderBreakingNewsText(Community $community, array $newsData): string
    {
        return ($newsData['headline'] ?? 'Breaking News') . "\n\n" . ($newsData['summary'] ?? '') . "\n\n" . ($newsData['url'] ?? '');
    }
}

```

### EmergencyBroadcastService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\EmergencyAlert;
use App\Models\EmergencySubscription;
use App\Models\EmergencyDelivery;
use App\Models\EmergencyAuditLog;
use App\Jobs\SendEmergencyEmail;
use App\Jobs\SendEmergencySms;
use Illuminate\Support\Facades\Log;

final class EmergencyBroadcastService
{
    public function __construct(
        private readonly EmailDeliveryService $emailService,
        private readonly SmsService $smsService
    ) {}

    /**
     * Create and optionally publish an emergency alert
     */
    public function createAlert(array $data, ?int $userId = null, ?int $municipalPartnerId = null): EmergencyAlert
    {
        $alert = EmergencyAlert::create([
            'community_id' => $data['community_id'],
            'created_by' => $userId,
            'municipal_partner_id' => $municipalPartnerId,
            'priority' => $data['priority'],
            'category' => $data['category'],
            'title' => $data['title'],
            'message' => $data['message'],
            'instructions' => $data['instructions'] ?? null,
            'source' => $data['source'] ?? null,
            'source_url' => $data['source_url'] ?? null,
            'status' => ($data['publish_immediately'] ?? false) ? 'active' : 'draft',
            'published_at' => ($data['publish_immediately'] ?? false) ? now() : null,
            'expires_at' => $data['expires_at'] ?? null,
            'delivery_channels' => $data['channels'] ?? ['email'],
        ]);

        $this->logAction($alert, 'created', $userId, $municipalPartnerId);

        if ($alert->status === 'active') {
            $this->broadcast($alert);
        }

        return $alert;
    }

    /**
     * Publish a draft alert
     */
    public function publishAlert(EmergencyAlert $alert, ?int $userId = null): EmergencyAlert
    {
        $alert->update([
            'status' => 'active',
            'published_at' => now(),
        ]);

        $this->logAction($alert, 'published', $userId);
        $this->broadcast($alert);

        return $alert;
    }

    /**
     * Broadcast alert to all eligible subscribers
     */
    public function broadcast(EmergencyAlert $alert): void
    {
        $channels = $alert->delivery_channels ?? ['email'];

        // Get eligible subscriptions
        $subscriptions = EmergencySubscription::query()
            ->whereHas('subscriber', function ($query) use ($alert) {
                $query->where('community_id', $alert->community_id)
                    ->where('status', 'active');
            })
            ->with('subscriber')
            ->get()
            ->filter(fn($sub) => $sub->shouldReceiveAlert($alert));

        foreach ($subscriptions as $subscription) {
            // Queue email delivery
            if (in_array('email', $channels) && $subscription->email_enabled) {
                $this->queueEmailDelivery($alert, $subscription);
            }

            // Queue SMS delivery for critical/urgent if enabled
            if (in_array('sms', $channels) && $subscription->canReceiveSms()) {
                if (in_array($alert->priority, ['critical', 'urgent'])) {
                    $this->queueSmsDelivery($alert, $subscription);
                }
            }
        }

        // Update sent counts
        $alert->update([
            'email_sent' => EmergencyDelivery::where('alert_id', $alert->id)
                ->where('channel', 'email')
                ->count(),
            'sms_sent' => EmergencyDelivery::where('alert_id', $alert->id)
                ->where('channel', 'sms')
                ->count(),
        ]);
    }

    /**
     * Queue email delivery
     */
    protected function queueEmailDelivery(EmergencyAlert $alert, EmergencySubscription $subscription): void
    {
        $delivery = EmergencyDelivery::create([
            'alert_id' => $alert->id,
            'subscription_id' => $subscription->id,
            'channel' => 'email',
            'status' => 'queued',
        ]);

        // Use high priority queue for critical alerts
        $queue = $alert->priority === 'critical' ? 'emergency-critical' : 'emergency';
        SendEmergencyEmail::dispatch($delivery)->onQueue($queue);
    }

    /**
     * Queue SMS delivery
     */
    protected function queueSmsDelivery(EmergencyAlert $alert, EmergencySubscription $subscription): void
    {
        $delivery = EmergencyDelivery::create([
            'alert_id' => $alert->id,
            'subscription_id' => $subscription->id,
            'channel' => 'sms',
            'status' => 'queued',
        ]);

        // SMS always uses critical queue
        SendEmergencySms::dispatch($delivery)->onQueue('emergency-critical');
    }

    /**
     * Cancel an active alert
     */
    public function cancelAlert(EmergencyAlert $alert, ?int $userId = null, ?string $reason = null): EmergencyAlert
    {
        $alert->update(['status' => 'cancelled']);

        $this->logAction($alert, 'cancelled', $userId, null, ['reason' => $reason]);

        // Cancel any pending deliveries
        EmergencyDelivery::where('alert_id', $alert->id)
            ->where('status', 'queued')
            ->update(['status' => 'failed', 'error_message' => 'Alert cancelled']);

        return $alert;
    }

    /**
     * Log audit action
     */
    protected function logAction(
        EmergencyAlert $alert,
        string $action,
        ?int $userId = null,
        ?int $municipalPartnerId = null,
        ?array $changes = null
    ): void {
        EmergencyAuditLog::create([
            'alert_id' => $alert->id,
            'user_id' => $userId,
            'municipal_partner_id' => $municipalPartnerId,
            'action' => $action,
            'changes' => $changes,
            'ip_address' => request()->ip(),
            'user_agent' => request()->userAgent(),
        ]);
    }

    /**
     * Get delivery statistics for an alert
     */
    public function getDeliveryStats(EmergencyAlert $alert): array
    {
        return [
            'email' => [
                'queued' => $alert->deliveries()->where('channel', 'email')->where('status', 'queued')->count(),
                'sent' => $alert->deliveries()->where('channel', 'email')->where('status', 'sent')->count(),
                'delivered' => $alert->deliveries()->where('channel', 'email')->where('status', 'delivered')->count(),
                'failed' => $alert->deliveries()->where('channel', 'email')->where('status', 'failed')->count(),
            ],
            'sms' => [
                'queued' => $alert->deliveries()->where('channel', 'sms')->where('status', 'queued')->count(),
                'sent' => $alert->deliveries()->where('channel', 'sms')->where('status', 'sent')->count(),
                'delivered' => $alert->deliveries()->where('channel', 'sms')->where('status', 'delivered')->count(),
                'failed' => $alert->deliveries()->where('channel', 'sms')->where('status', 'failed')->count(),
            ],
        ];
    }
}

```

### EventService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\Event;
use App\Models\Venue;
use App\Models\Performer;
use App\Models\Region;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Pagination\LengthAwarePaginator;

final class EventService
{
    public function __construct(
        private readonly CacheService $cacheService,
        private readonly WeatherService $weatherService
    ) {}

    /**
     * Get upcoming events
     */
    public function getUpcoming(array $filters = [], int $perPage = 20): LengthAwarePaginator
    {
        $cacheKey = 'events:upcoming:'.md5(serialize([$filters, $perPage]));
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(5), function () use ($filters, $perPage) {
            $query = Event::published()
                ->upcoming()
                ->with(['venue', 'performer', 'regions']);

            // Filters
            if (isset($filters['category'])) {
                $query->where('category', $filters['category']);
            }

            if (isset($filters['region_id'])) {
                $query->whereHas('regions', function ($q) use ($filters) {
                    $q->where('regions.id', $filters['region_id']);
                });
            }

            if (isset($filters['venue_id'])) {
                $query->where('venue_id', $filters['venue_id']);
            }

            if (isset($filters['performer_id'])) {
                $query->where('performer_id', $filters['performer_id']);
            }

            if (isset($filters['is_free'])) {
                $query->where('is_free', $filters['is_free']);
            }

            if (isset($filters['date_from'])) {
                $query->where('event_date', '>=', $filters['date_from']);
            }

            if (isset($filters['date_to'])) {
                $query->where('event_date', '<=', $filters['date_to']);
            }

            // Location filter
            if (isset($filters['latitude'], $filters['longitude'], $filters['radius'])) {
                $query->withinRadius(
                    (float) $filters['latitude'],
                    (float) $filters['longitude'],
                    (float) $filters['radius']
                );
            }

            // Sorting
            $sortBy = $filters['sort_by'] ?? 'event_date';
            $sortOrder = $filters['sort_order'] ?? 'asc';
            
            if ($sortBy === 'distance' && isset($filters['latitude'], $filters['longitude'])) {
                $query->orderBy('distance', $sortOrder);
            } else {
                $query->orderBy($sortBy, $sortOrder);
            }

            return $query->paginate($perPage);
        });
    }

    /**
     * Get events by category
     */
    public function getByCategory(string $category, int $limit = 20): Collection
    {
        $cacheKey = "events:category:{$category}:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($category, $limit) {
            return Event::published()
                ->upcoming()
                ->where('category', $category)
                ->with(['venue', 'performer', 'regions'])
                ->orderBy('event_date', 'asc')
                ->limit($limit)
                ->get();
        });
    }

    /**
     * Get events by venue
     */
    public function getByVenue(Venue|string $venue, int $limit = 20): Collection
    {
        $venueId = $venue instanceof Venue ? $venue->id : $venue;
        $cacheKey = "events:venue:{$venueId}:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($venueId, $limit) {
            return Event::published()
                ->upcoming()
                ->where('venue_id', $venueId)
                ->with(['performer', 'regions'])
                ->orderBy('event_date', 'asc')
                ->limit($limit)
                ->get();
        });
    }

    /**
     * Get events by performer
     */
    public function getByPerformer(Performer|string $performer, int $limit = 20): Collection
    {
        $performerId = $performer instanceof Performer ? $performer->id : $performer;
        $cacheKey = "events:performer:{$performerId}:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($performerId, $limit) {
            return Event::published()
                ->upcoming()
                ->where('performer_id', $performerId)
                ->with(['venue', 'regions'])
                ->orderBy('event_date', 'asc')
                ->limit($limit)
                ->get();
        });
    }

    /**
     * Get related events
     */
    public function getRelated(Event $event, int $limit = 6): Collection
    {
        $cacheKey = "events:related:{$event->id}:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(30), function () use ($event, $limit) {
            $query = Event::published()
                ->upcoming()
                ->where('id', '!=', $event->id)
                ->with(['venue', 'performer', 'regions']);

            // Find events with same category
            if ($event->category) {
                $query->where('category', $event->category);
            }

            // Find events in same regions
            if ($event->regions->isNotEmpty()) {
                $regionIds = $event->regions->pluck('id');
                $query->whereHas('regions', function ($q) use ($regionIds) {
                    $q->whereIn('regions.id', $regionIds);
                });
            }

            // Find events at same venue
            if ($event->venue_id) {
                $query->orWhere('venue_id', $event->venue_id);
            }

            return $query->orderBy('event_date', 'asc')
                ->limit($limit)
                ->get();
        });
    }

    /**
     * Get featured events
     */
    public function getFeatured(int $limit = 6): Collection
    {
        $cacheKey = "events:featured:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(30), function () use ($limit) {
            return Event::published()
                ->upcoming()
                ->whereNotNull('image')
                ->with(['venue', 'performer', 'regions'])
                ->orderBy('event_date', 'asc')
                ->limit($limit)
                ->get();
        });
    }

    /**
     * Get events by region
     */
    public function getByRegion(Region|string $region, int $limit = 20): Collection
    {
        $regionId = $region instanceof Region ? $region->id : $region;
        $cacheKey = "events:region:{$regionId}:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($regionId, $limit) {
            return Event::published()
                ->upcoming()
                ->whereHas('regions', function ($q) use ($regionId) {
                    $q->where('regions.id', $regionId);
                })
                ->with(['venue', 'performer'])
                ->orderBy('event_date', 'asc')
                ->limit($limit)
                ->get();
        });
    }

    /**
     * Get event with weather
     */
    public function getEventWithWeather(Event $event): array
    {
        $weather = null;
        
        if ($event->latitude && $event->longitude) {
            $weather = $this->weatherService->getWeatherForEvent($event);
        }

        return [
            'event' => $event->load(['venue', 'performer', 'regions']),
            'weather' => $weather,
        ];
    }

    /**
     * Clear event-related cache
     */
    public function clearCache(?Event $event = null): void
    {
        $this->cacheService->forget('events:*');
        
        if ($event) {
            $this->cacheService->forget("events:related:{$event->id}:*");
            
            if ($event->category) {
                $this->cacheService->forget("events:category:{$event->category}:*");
            }
            
            if ($event->venue_id) {
                $this->cacheService->forget("events:venue:{$event->venue_id}:*");
            }
            
            if ($event->performer_id) {
                $this->cacheService->forget("events:performer:{$event->performer_id}:*");
            }
            
            foreach ($event->regions as $region) {
                $this->cacheService->forget("events:region:{$region->id}:*");
            }
        }
    }
}

```

### GamificationService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\User;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\DB;

final class GamificationService
{
    public function __construct(
        private readonly CacheService $cacheService
    ) {}

    /**
     * Award points to a user
     */
    public function awardPoints(User $user, int $points, string $reason, ?string $sourceType = null, ?string $sourceId = null): void
    {
        DB::beginTransaction();
        
        try {
            // Update user points
            $user->increment('total_points', $points);

            // Calculate new level
            $newLevel = $this->calculateLevel($user->total_points);
            if ($newLevel > ($user->level ?? 1)) {
                $user->update(['level' => $newLevel]);
            }

            // Log points transaction (would need PointsTransaction model)
            // PointsTransaction::create([
            //     'user_id' => $user->id,
            //     'points' => $points,
            //     'reason' => $reason,
            //     'source_type' => $sourceType,
            //     'source_id' => $sourceId,
            // ]);

            DB::commit();

            // Clear cache
            $this->clearUserCache($user);
        } catch (\Exception $e) {
            DB::rollBack();
            throw $e;
        }
    }

    /**
     * Unlock an achievement for a user
     */
    public function unlockAchievement(User $user, string $achievementKey, array $metadata = []): void
    {
        DB::beginTransaction();
        
        try {
            // Check if achievement already unlocked (would need UserAchievement model)
            // $exists = UserAchievement::where('user_id', $user->id)
            //     ->where('achievement_key', $achievementKey)
            //     ->exists();
            //
            // if ($exists) {
            //     return;
            // }

            // Unlock achievement
            // UserAchievement::create([
            //     'user_id' => $user->id,
            //     'achievement_key' => $achievementKey,
            //     'unlocked_at' => now(),
            //     'metadata' => $metadata,
            // ]);

            // Award points for achievement (if configured)
            // $achievement = Achievement::where('key', $achievementKey)->first();
            // if ($achievement && $achievement->points > 0) {
            //     $this->awardPoints($user, $achievement->points, "Achievement: {$achievement->name}", 'achievement', $achievement->id);
            // }

            DB::commit();

            // Clear cache
            $this->clearUserCache($user);
        } catch (\Exception $e) {
            DB::rollBack();
            throw $e;
        }
    }

    /**
     * Get user level
     */
    public function getUserLevel(User $user): int
    {
        return $this->calculateLevel($user->total_points ?? 0);
    }

    /**
     * Calculate level from points
     */
    private function calculateLevel(int $points): int
    {
        // Level calculation: 100 points per level (can be customized)
        return max(1, (int) floor($points / 100) + 1);
    }

    /**
     * Get user achievements
     */
    public function getUserAchievements(User $user): Collection
    {
        $cacheKey = "user:achievements:{$user->id}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($user) {
            // Would query UserAchievement model
            // return UserAchievement::where('user_id', $user->id)
            //     ->with('achievement')
            //     ->orderBy('unlocked_at', 'desc')
            //     ->get();
            
            return collect([]);
        });
    }

    /**
     * Get leaderboard
     */
    public function getLeaderboard(string $type = 'points', string $period = 'all_time', int $limit = 100): Collection
    {
        $cacheKey = "leaderboard:{$type}:{$period}:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(5), function () use ($type, $period, $limit) {
            $query = User::query();

            // Apply period filter if needed (for future implementation)
            // if ($period !== 'all_time') {
            //     $dateFilter = match ($period) {
            //         'daily' => now()->subDay(),
            //         'weekly' => now()->subWeek(),
            //         'monthly' => now()->subMonth(),
            //         default => null,
            //     };
            //     if ($dateFilter) {
            //         // Would filter by activity date
            //     }
            // }

            match ($type) {
                'points' => $query->orderBy('total_points', 'desc'),
                'level' => $query->orderBy('level', 'desc'),
                'achievements' => $query->orderBy('achievements_count', 'desc'),
                'reviews' => $query->withCount('reviews')->orderBy('reviews_count', 'desc'),
                'visits' => $query->orderBy('total_points', 'desc'), // Placeholder
                'referrals' => $query->orderBy('total_points', 'desc'), // Placeholder
                default => $query->orderBy('total_points', 'desc'),
            };

            return $query->limit($limit)->get();
        });
    }

    /**
     * Get all achievements
     */
    public function getAchievements(array $filters = []): Collection
    {
        $cacheKey = 'achievements:'.md5(serialize($filters));
        
        return $this->cacheService->remember($cacheKey, now()->addHours(1), function () use ($filters) {
            // Would query Achievement model
            // $query = Achievement::where('is_active', true);
            //
            // if (isset($filters['category'])) {
            //     $query->where('category', $filters['category']);
            // }
            //
            // if (isset($filters['rarity'])) {
            //     $query->where('rarity', $filters['rarity']);
            // }
            //
            // return $query->orderBy('points', 'desc')->get();
            
            return collect([]);
        });
    }

    /**
     * Get user rank
     */
    public function getUserRank(User $user, string $type = 'points'): int
    {
        $cacheKey = "user:rank:{$user->id}:{$type}";
        
        return (int) $this->cacheService->remember($cacheKey, now()->addMinutes(5), function () use ($user, $type) {
            $query = User::query();

            match ($type) {
                'points' => $query->where('total_points', '>', $user->total_points ?? 0),
                'level' => $query->where('level', '>', $user->level ?? 1),
                default => $query->where('total_points', '>', $user->total_points ?? 0),
            };

            return $query->count() + 1;
        });
    }

    /**
     * Check if user can unlock achievement
     */
    public function checkAchievementProgress(User $user, string $achievementKey): array
    {
        // Would check achievement requirements
        // $achievement = Achievement::where('key', $achievementKey)->first();
        // if (!$achievement) {
        //     return ['unlocked' => false, 'progress' => 0, 'required' => 0];
        // }
        //
        // $progress = $this->calculateAchievementProgress($user, $achievement);
        // $unlocked = $progress >= $achievement->required_value;
        //
        // return [
        //     'unlocked' => $unlocked,
        //     'progress' => $progress,
        //     'required' => $achievement->required_value,
        //     'percentage' => min(100, ($progress / $achievement->required_value) * 100),
        // ];

        return ['unlocked' => false, 'progress' => 0, 'required' => 0, 'percentage' => 0];
    }

    /**
     * Clear user-related cache
     */
    private function clearUserCache(User $user): void
    {
        $this->cacheService->forget("user:achievements:{$user->id}");
        $this->cacheService->forget("user:rank:{$user->id}:*");
        $this->cacheService->forget('leaderboard:*');
    }
}

```

### GeocodingService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Contracts\GeocodingServiceInterface;
use App\Models\Region;
use Exception;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;

final class GeocodingService implements GeocodingServiceInterface
{
    private const GOOGLE_GEOCODE_API_URL = 'https://maps.googleapis.com/maps/api/geocode/json';

    private const SERPAPI_LOCATIONS_URL = 'https://serpapi.com/locations.json';

    private const SERPAPI_SEARCH_URL = 'https://serpapi.com/search';

    private const CACHE_TTL = 60 * 60 * 24 * 30; // 30 days

    public function __construct(
        private readonly ?string $apiKey = null
    ) {}

    /**
     * Geocode an address to coordinates
     *
     * @param  bool  $forceGoogle  Skip free APIs and use Google Maps API directly
     * @return array{latitude: float, longitude: float, postal_code: ?string, google_place_id: ?string}|null
     */
    public function geocodeAddress(string $address, bool $forceGoogle = false): ?array
    {
        $cacheKey = 'geocode:'.md5($address).($forceGoogle ? ':google' : '');

        return Cache::remember($cacheKey, self::CACHE_TTL, function () use ($address, $forceGoogle) {
            // If forcing Google, skip free APIs
            if ($forceGoogle) {
                Log::info('GeocodingService: Force Google enabled, using Google Maps API directly', [
                    'address' => $address,
                ]);

                return $this->geocodeWithGoogle($address);
            }

            // 1. Try free SerpAPI Locations API first (no API key needed, best for cities/regions)
            $result = $this->geocodeWithSerpApiLocations($address);

            // 2. If Locations API fails, try Google Maps API (if configured)
            if ($result === null) {
                Log::info('GeocodingService: SerpAPI Locations failed, trying Google Maps API', [
                    'address' => $address,
                ]);
                $result = $this->geocodeWithGoogle($address);
            }

            // 3. If Google fails, try paid SerpAPI Google Maps engine as last resort
            if ($result === null) {
                Log::info('GeocodingService: Google API failed, trying SerpAPI Google Maps', [
                    'address' => $address,
                ]);
                $result = $this->geocodeWithSerpApiGoogleMaps($address);
            }

            return $result;
        });
    }

    /**
     * Geocode a venue by name and optional address
     *
     * @return array{latitude: float, longitude: float, postal_code: ?string, google_place_id: ?string}|null
     */
    public function geocodeVenue(string $venueName, ?string $address = null, ?string $regionName = null): ?array
    {
        // Build search query from available information
        $parts = array_filter([$venueName, $address, $regionName]);
        $searchQuery = implode(', ', $parts);

        if (empty($searchQuery)) {
            return null;
        }

        // First try with full query
        $result = $this->geocodeAddress($searchQuery);

        // If no result and we have address, try without venue name
        if ($result === null && ! empty($address)) {
            $fallbackQuery = implode(', ', array_filter([$address, $regionName]));
            $result = $this->geocodeAddress($fallbackQuery);
        }

        // If still no result, try just venue name with region
        if ($result === null && ! empty($regionName)) {
            $fallbackQuery = "{$venueName}, {$regionName}";
            $result = $this->geocodeAddress($fallbackQuery);
        }

        return $result;
    }

    /**
     * Clear cached geocoding results for an address
     */
    public function clearCache(string $address): bool
    {
        $cacheKey = 'geocode:'.md5($address);

        return Cache::forget($cacheKey);
    }

    /**
     * Geocode a region and update its coordinates
     *
     * @param  bool  $forceGoogle  Skip free APIs and use Google Maps API directly
     */
    public function geocodeRegion(Region $region, bool $forceGoogle = false): bool
    {
        $query = $this->buildQueryForRegion($region);

        if (! $query) {
            Log::warning('GeocodingService: Cannot build query for region', [
                'region_id' => $region->id,
                'region_name' => $region->name,
                'region_type' => $region->type,
            ]);

            return false;
        }

        $result = $this->geocodeAddress($query, $forceGoogle);

        if (! $result) {
            Log::warning('GeocodingService: No coordinates for region', [
                'region_id' => $region->id,
                'region_name' => $region->name,
                'query' => $query,
                'force_google' => $forceGoogle,
            ]);

            return false;
        }

        $region->update([
            'latitude' => $result['latitude'],
            'longitude' => $result['longitude'],
        ]);

        Log::info('GeocodingService: Region geocoded successfully', [
            'region_id' => $region->id,
            'region_name' => $region->name,
            'latitude' => $result['latitude'],
            'longitude' => $result['longitude'],
            'force_google' => $forceGoogle,
        ]);

        return true;
    }

    /**
     * Geocode a location by city and state
     *
     * Note: County parameter is kept for backwards compatibility but not used
     * since SerpAPI Locations API format is "City,State,United States"
     *
     * @return array{latitude: float, longitude: float, postal_code: ?string, google_place_id: ?string}|null
     */
    public function geocodeLocation(string $city, ?string $county, string $state): ?array
    {
        // SerpAPI Locations format: "City,State,United States" (county not used)
        unset($county);
        $query = "{$city},{$state},United States";

        return $this->geocodeAddress($query);
    }

    /**
     * Geocode using Google Maps API
     *
     * @return array{latitude: float, longitude: float, postal_code: ?string, google_place_id: ?string, formatted_address: ?string}|null
     */
    private function geocodeWithGoogle(string $address): ?array
    {
        $apiKey = $this->apiKey ?? config('services.google.maps_api_key') ?? env('GOOGLE_MAPS_API_KEY');

        if (empty($apiKey)) {
            Log::info('GeocodingService: No Google Maps API key configured, skipping Google geocoding');

            return null;
        }

        try {
            $response = Http::timeout(10)
                ->get(self::GOOGLE_GEOCODE_API_URL, [
                    'address' => $address,
                    'key' => $apiKey,
                ]);

            if (! $response->successful()) {
                Log::warning('GeocodingService: Google API request failed', [
                    'status' => $response->status(),
                    'address' => $address,
                ]);

                return null;
            }

            $data = $response->json();

            if ($data['status'] !== 'OK' || empty($data['results'])) {
                Log::info('GeocodingService: Google API returned no results', [
                    'status' => $data['status'],
                    'address' => $address,
                ]);

                return null;
            }

            $result = $data['results'][0];
            $location = $result['geometry']['location'];

            // Extract postal code from address components
            $postalCode = null;
            foreach ($result['address_components'] ?? [] as $component) {
                if (in_array('postal_code', $component['types'])) {
                    $postalCode = $component['short_name'];
                    break;
                }
            }

            return [
                'latitude' => (float) $location['lat'],
                'longitude' => (float) $location['lng'],
                'postal_code' => $postalCode,
                'google_place_id' => $result['place_id'] ?? null,
                'formatted_address' => $result['formatted_address'] ?? null,
            ];
        } catch (Exception $e) {
            Log::error('GeocodingService: Google API exception', [
                'address' => $address,
                'error' => $e->getMessage(),
            ]);

            return null;
        }
    }

    /**
     * Geocode using SerpAPI Locations API (FREE - no API key required)
     *
     * This API searches SerpApi's database of supported locations and returns GPS coordinates.
     * Best for cities, counties, states, and well-known locations.
     *
     * @see https://serpapi.com/locations-api
     *
     * @return array{latitude: float, longitude: float, postal_code: ?string, google_place_id: ?string, formatted_address: ?string}|null
     */
    private function geocodeWithSerpApiLocations(string $address): ?array
    {
        try {
            $response = Http::timeout(10)->get(self::SERPAPI_LOCATIONS_URL, [
                'q' => $address,
                'limit' => 5,
            ]);

            if (! $response->successful()) {
                Log::warning('GeocodingService: SerpAPI Locations request failed', [
                    'status' => $response->status(),
                    'address' => $address,
                ]);

                return null;
            }

            $locations = $response->json();

            if (empty($locations) || ! is_array($locations)) {
                Log::info('GeocodingService: SerpAPI Locations returned no results', [
                    'address' => $address,
                ]);

                return null;
            }

            // Find the best match - prefer City type, then look for US locations
            $bestMatch = $this->findBestLocationMatch($locations, $address);

            if ($bestMatch && isset($bestMatch['gps']) && is_array($bestMatch['gps']) && count($bestMatch['gps']) >= 2) {
                // SerpAPI returns gps as [longitude, latitude]
                return [
                    'latitude' => (float) $bestMatch['gps'][1],
                    'longitude' => (float) $bestMatch['gps'][0],
                    'postal_code' => null,
                    'google_place_id' => null,
                    'formatted_address' => $bestMatch['canonical_name'] ?? $bestMatch['name'] ?? null,
                ];
            }

            Log::info('GeocodingService: SerpAPI Locations found no matching coordinates', [
                'address' => $address,
                'locations_count' => count($locations),
            ]);

            return null;
        } catch (Exception $e) {
            Log::error('GeocodingService: SerpAPI Locations exception', [
                'address' => $address,
                'error' => $e->getMessage(),
            ]);

            return null;
        }
    }

    /**
     * Find the best matching location from SerpAPI Locations results
     *
     * @param  array<int, array<string, mixed>>  $locations
     * @return array<string, mixed>|null
     */
    private function findBestLocationMatch(array $locations, string $address): ?array
    {
        // Normalize the search address for comparison
        $normalizedAddress = mb_strtolower($address);

        // Prioritize by target_type: City > County > DMA Region > State > others
        $typePriority = [
            'City' => 1,
            'County' => 2,
            'DMA Region' => 3,
            'State' => 4,
            'Neighborhood' => 5,
        ];

        $bestMatch = null;
        $bestScore = PHP_INT_MAX;

        foreach ($locations as $location) {
            // Must have GPS coordinates
            if (! isset($location['gps']) || ! is_array($location['gps']) || count($location['gps']) < 2) {
                continue;
            }

            // Prefer US locations
            $isUS = ($location['country_code'] ?? '') === 'US';

            // Get type priority (lower is better)
            $type = $location['target_type'] ?? 'Other';
            $typePriorityScore = $typePriority[$type] ?? 10;

            // Check if canonical name matches well
            $canonicalName = mb_strtolower($location['canonical_name'] ?? '');
            $name = mb_strtolower($location['name'] ?? '');

            // Simple scoring: US locations get priority, then by type
            $score = ($isUS ? 0 : 100) + $typePriorityScore;

            // Bonus for exact name match at start
            if (str_starts_with($canonicalName, $normalizedAddress) || str_starts_with($name, $normalizedAddress)) {
                $score -= 50;
            }

            if ($score < $bestScore) {
                $bestScore = $score;
                $bestMatch = $location;
            }
        }

        return $bestMatch;
    }

    /**
     * Geocode using SerpAPI Google Maps engine (requires API key)
     *
     * This is a fallback when both Google Maps API and free Locations API fail.
     *
     * @return array{latitude: float, longitude: float, postal_code: ?string, google_place_id: ?string, formatted_address: ?string}|null
     */
    private function geocodeWithSerpApiGoogleMaps(string $address): ?array
    {
        $apiKey = config('news-workflow.apis.serpapi_key') ?? config('services.serpapi.key') ?? env('SERPAPI_KEY');

        if (empty($apiKey)) {
            Log::info('GeocodingService: No SerpAPI key configured, skipping Google Maps fallback');

            return null;
        }

        try {
            $response = Http::timeout(30)->get(self::SERPAPI_SEARCH_URL, [
                'api_key' => $apiKey,
                'engine' => 'google_maps',
                'q' => $address,
                'type' => 'search',
                'hl' => 'en',
            ]);

            if (! $response->successful()) {
                Log::warning('GeocodingService: SerpAPI Google Maps request failed', [
                    'status' => $response->status(),
                    'address' => $address,
                ]);

                return null;
            }

            $data = $response->json();

            // Try to get coordinates from place_results first (single place match)
            if (isset($data['place_results']['gps_coordinates'])) {
                return [
                    'latitude' => (float) $data['place_results']['gps_coordinates']['latitude'],
                    'longitude' => (float) $data['place_results']['gps_coordinates']['longitude'],
                    'postal_code' => null,
                    'google_place_id' => $data['place_results']['place_id'] ?? null,
                    'formatted_address' => $data['place_results']['address'] ?? null,
                ];
            }

            // Fall back to first local result
            $localResults = $data['local_results'] ?? [];
            if (! empty($localResults) && isset($localResults[0]['gps_coordinates'])) {
                return [
                    'latitude' => (float) $localResults[0]['gps_coordinates']['latitude'],
                    'longitude' => (float) $localResults[0]['gps_coordinates']['longitude'],
                    'postal_code' => null,
                    'google_place_id' => $localResults[0]['place_id'] ?? null,
                    'formatted_address' => $localResults[0]['address'] ?? null,
                ];
            }

            // Try search_metadata location if available (parse from URL)
            if (isset($data['search_metadata']['google_maps_url'])) {
                if (preg_match('/@(-?\d+\.\d+),(-?\d+\.\d+)/', $data['search_metadata']['google_maps_url'], $matches)) {
                    return [
                        'latitude' => (float) $matches[1],
                        'longitude' => (float) $matches[2],
                        'postal_code' => null,
                        'google_place_id' => null,
                        'formatted_address' => null,
                    ];
                }
            }

            Log::info('GeocodingService: SerpAPI Google Maps returned no coordinates', [
                'address' => $address,
                'response_keys' => array_keys($data),
            ]);

            return null;
        } catch (Exception $e) {
            Log::error('GeocodingService: SerpAPI Google Maps exception', [
                'address' => $address,
                'error' => $e->getMessage(),
            ]);

            return null;
        }
    }

    /**
     * Build a geocoding query string for a region
     *
     * For SerpAPI Locations API, the format should be: "City,State,United States"
     * Counties should be queried as "County Name,State,United States"
     */
    private function buildQueryForRegion(Region $region): ?string
    {
        // For state-level regions
        if ($region->type === 'state') {
            return "{$region->name},United States";
        }

        // For county-level, include state (format: "County Name,State,United States")
        if ($region->type === 'county') {
            $stateName = $region->parent?->name;

            return $stateName
                ? "{$region->name},{$stateName},United States"
                : "{$region->name},United States";
        }

        // For city/neighborhood, skip county and go directly to state
        // Format: "City,State,United States" (matching SerpAPI canonical format)
        $cityName = $region->name;
        $stateName = null;

        // Walk up the hierarchy to find the state (skip county)
        $parent = $region->parent;
        while ($parent) {
            if ($parent->type === 'state') {
                $stateName = $parent->name;
                break;
            }
            $parent = $parent->parent;
        }

        if ($stateName) {
            return "{$cityName},{$stateName},United States";
        }

        // Fallback if no state found
        return "{$cityName},United States";
    }
}
```

### HubAnalyticsService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\Hub;
use App\Models\HubAnalytics;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\DB;

final class HubAnalyticsService
{
    public function trackPageView(Hub $hub): void
    {
        $today = now()->toDateString();

        HubAnalytics::updateOrCreate(
            [
                'hub_id' => $hub->id,
                'date' => $today,
            ],
            [],
            function ($query) {
                $query->increment('page_views');
            }
        );
    }

    public function trackUniqueVisitor(Hub $hub): void
    {
        $today = now()->toDateString();

        $analytics = HubAnalytics::firstOrCreate(
            [
                'hub_id' => $hub->id,
                'date' => $today,
            ],
            [
                'page_views' => 0,
                'unique_visitors' => 0,
            ]
        );

        $analytics->increment('unique_visitors');
    }

    public function trackEventCreated(Hub $hub): void
    {
        $today = now()->toDateString();

        $analytics = HubAnalytics::firstOrCreate(
            [
                'hub_id' => $hub->id,
                'date' => $today,
            ],
            [
                'events_created' => 0,
            ]
        );

        $analytics->increment('events_created');
    }

    public function trackEventPublished(Hub $hub): void
    {
        $today = now()->toDateString();

        $analytics = HubAnalytics::firstOrCreate(
            [
                'hub_id' => $hub->id,
                'date' => $today,
            ],
            [
                'events_published' => 0,
            ]
        );

        $analytics->increment('events_published');
    }

    public function trackMemberJoined(Hub $hub): void
    {
        $today = now()->toDateString();

        $analytics = HubAnalytics::firstOrCreate(
            [
                'hub_id' => $hub->id,
                'date' => $today,
            ],
            [
                'members_joined' => 0,
            ]
        );

        $analytics->increment('members_joined');
    }

    public function trackFollowerGained(Hub $hub): void
    {
        $today = now()->toDateString();

        $analytics = HubAnalytics::firstOrCreate(
            [
                'hub_id' => $hub->id,
                'date' => $today,
            ],
            [
                'followers_gained' => 0,
            ]
        );

        $analytics->increment('followers_gained');
    }

    public function getAnalytics(Hub $hub, string $startDate, string $endDate): Collection
    {
        return HubAnalytics::where('hub_id', $hub->id)
            ->forDateRange($startDate, $endDate)
            ->orderBy('date', 'desc')
            ->get();
    }

    public function getTotals(Hub $hub, string $startDate, string $endDate): array
    {
        $analytics = $this->getAnalytics($hub, $startDate, $endDate);

        return [
            'page_views' => $analytics->sum('page_views'),
            'unique_visitors' => $analytics->sum('unique_visitors'),
            'events_created' => $analytics->sum('events_created'),
            'events_published' => $analytics->sum('events_published'),
            'articles_created' => $analytics->sum('articles_created'),
            'articles_published' => $analytics->sum('articles_published'),
            'members_joined' => $analytics->sum('members_joined'),
            'followers_gained' => $analytics->sum('followers_gained'),
            'revenue' => $analytics->sum('revenue'),
        ];
    }

    public function calculateEngagementScore(Hub $hub, string $date): float
    {
        $analytics = HubAnalytics::where('hub_id', $hub->id)
            ->where('date', $date)
            ->first();

        if (!$analytics) {
            return 0.0;
        }

        // Simple engagement score calculation
        $score = ($analytics->page_views * 0.1)
            + ($analytics->unique_visitors * 0.5)
            + ($analytics->events_published * 2.0)
            + ($analytics->articles_published * 1.5)
            + ($analytics->members_joined * 3.0)
            + ($analytics->followers_gained * 5.0);

        return round($score, 2);
    }
}

```

### HubBuilderService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\Hub;
use App\Models\HubSection;
use Illuminate\Support\Collection;

final class HubBuilderService
{
    public function updateDesignSettings(Hub $hub, array $settings): Hub
    {
        $hub->update([
            'design_settings' => array_merge($hub->design_settings ?? [], $settings),
        ]);

        return $hub;
    }

    public function updateSections(Hub $hub, array $sectionsData): Collection
    {
        $sections = collect();

        foreach ($sectionsData as $index => $sectionData) {
            if (isset($sectionData['id'])) {
                $section = HubSection::where('hub_id', $hub->id)
                    ->where('id', $sectionData['id'])
                    ->first();

                if ($section) {
                    $section->update([
                        'type' => $sectionData['type'],
                        'title' => $sectionData['title'],
                        'description' => $sectionData['description'] ?? null,
                        'content' => $sectionData['content'] ?? null,
                        'settings' => $sectionData['settings'] ?? null,
                        'is_visible' => $sectionData['is_visible'] ?? true,
                        'sort_order' => $sectionData['sort_order'] ?? $index,
                    ]);
                    $sections->push($section);
                }
            } else {
                $section = HubSection::create([
                    'hub_id' => $hub->id,
                    'type' => $sectionData['type'],
                    'title' => $sectionData['title'],
                    'description' => $sectionData['description'] ?? null,
                    'content' => $sectionData['content'] ?? null,
                    'settings' => $sectionData['settings'] ?? null,
                    'is_visible' => $sectionData['is_visible'] ?? true,
                    'sort_order' => $sectionData['sort_order'] ?? $index,
                ]);
                $sections->push($section);
            }
        }

        return $sections;
    }

    public function deleteSection(Hub $hub, HubSection $section): bool
    {
        if ($section->hub_id !== $hub->id) {
            return false;
        }

        return $section->delete();
    }

    public function updateMonetizationSettings(Hub $hub, array $settings): Hub
    {
        $hub->update([
            'monetization_settings' => array_merge($hub->monetization_settings ?? [], $settings),
        ]);

        return $hub;
    }
}

```

### HubService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\Hub;
use App\Models\HubMember;
use App\Models\User;
use App\Models\Workspace;
use Illuminate\Support\Facades\DB;

final class HubService
{
    public function createHub(User $user, Workspace $workspace, array $data): Hub
    {
        return DB::transaction(function () use ($user, $workspace, $data) {
            $hub = Hub::create([
                ...$data,
                'workspace_id' => $workspace->id,
                'created_by' => $user->id,
                'slug' => Hub::generateUniqueSlug($data['name']),
            ]);

            // Create owner member
            $hub->members()->create([
                'user_id' => $user->id,
                'role' => HubMember::ROLE_OWNER,
                'joined_at' => now(),
                'is_active' => true,
            ]);

            return $hub;
        });
    }

    public function updateHub(Hub $hub, array $data): Hub
    {
        if (isset($data['name']) && $data['name'] !== $hub->name) {
            $data['slug'] = Hub::generateUniqueSlug($data['name']);
        }

        $hub->update($data);

        return $hub;
    }

    public function addMember(Hub $hub, User $user, string $role = HubMember::ROLE_MEMBER): HubMember
    {
        return $hub->members()->create([
            'user_id' => $user->id,
            'role' => $role,
            'joined_at' => now(),
            'is_active' => true,
        ]);
    }

    public function removeMember(Hub $hub, User $user): bool
    {
        return $hub->members()
            ->where('user_id', $user->id)
            ->update(['is_active' => false]);
    }

    public function updateMemberRole(Hub $hub, User $user, string $role): bool
    {
        return $hub->members()
            ->where('user_id', $user->id)
            ->update(['role' => $role]);
    }

    public function publishHub(Hub $hub): Hub
    {
        $hub->update([
            'published_at' => now(),
            'is_active' => true,
        ]);

        return $hub;
    }
}

```

### LocationService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\Region;
use Exception;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Cache;
use Stevebauman\Location\Facades\Location;
use Stevebauman\Location\Position;

final class LocationService
{
    /**
     * Detect location from IP address
     */
    public function detectFromIp(?string $ip = null): ?Position
    {
        if ($ip === null) {
            $ip = request()->ip();
        }

        try {
            $location = Location::get($ip);

            // Location::get() can return false on failure
            return $location instanceof Position ? $location : null;
        } catch (Exception $e) {
            report($e);

            return null;
        }
    }

    /**
     * Find regions by zipcode
     */
    public function findRegionsByZipcode(string $zipcode): Collection
    {
        return Cache::remember(
            "regions:zipcode:{$zipcode}",
            now()->addHours(24),
            fn () => Region::active()
                ->forZipcode($zipcode)
                ->with('parent')
                ->orderBy('type', 'desc')
                ->get()
        );
    }

    /**
     * Find the most specific region for a zipcode (city over county over state)
     */
    public function findPrimaryRegionByZipcode(string $zipcode): ?Region
    {
        $regions = $this->findRegionsByZipcode($zipcode);

        if ($regions->isEmpty()) {
            return null;
        }

        $priorities = ['neighborhood', 'city', 'county', 'state'];

        foreach ($priorities as $type) {
            $region = $regions->firstWhere('type', $type);
            if ($region !== null) {
                return $region;
            }
        }

        return $regions->first();
    }

    /**
     * Find nearest region by coordinates using Haversine formula
     */
    public function findNearestRegion(float $latitude, float $longitude, ?string $type = null): ?Region
    {
        $query = Region::active()
            ->whereNotNull('latitude')
            ->whereNotNull('longitude');

        if ($type !== null) {
            $query->ofType($type);
        }

        $regions = $query->get();

        if ($regions->isEmpty()) {
            return null;
        }

        $nearest = null;
        $minDistance = PHP_FLOAT_MAX;

        foreach ($regions as $region) {
            $distance = $this->calculateDistance(
                $latitude,
                $longitude,
                (float) $region->latitude,
                (float) $region->longitude
            );

            if ($distance < $minDistance) {
                $minDistance = $distance;
                $nearest = $region;
            }
        }

        return $nearest;
    }

    /**
     * Set user's location preference in session and cookie
     */
    public function setUserLocation(string $regionId): void
    {
        session()->put('user_location_region_id', $regionId);
        session()->put('user_location_confirmed', true);
        cookie()->queue('user_location_region_id', $regionId, 60 * 24 * 365);
    }

    /**
     * Get user's stored location from session or cookie
     */
    public function getUserLocation(): ?Region
    {
        $regionId = session('user_location_region_id')
            ?? request()->cookie('user_location_region_id');

        if ($regionId === null) {
            return null;
        }

        return Region::find($regionId);
    }

    /**
     * Clear user's location preference
     */
    public function clearUserLocation(): void
    {
        session()->forget(['user_location_region_id', 'user_location_confirmed']);
        cookie()->queue(cookie()->forget('user_location_region_id'));
    }

    /**
     * Check if user has confirmed their location
     */
    public function hasUserConfirmedLocation(): bool
    {
        return (bool) session('user_location_confirmed', false);
    }

    /**
     * Search regions by name or zipcode
     */
    public function searchRegions(string $query, int $limit = 10): Collection
    {
        return Region::active()
            ->where(function ($q) use ($query) {
                $q->where('name', 'ilike', "%{$query}%")
                    ->orWhere('slug', 'ilike', "%{$query}%")
                    ->orWhereHas('zipcodes', function ($q) use ($query) {
                        $q->where('zipcode', 'like', "{$query}%");
                    });
            })
            ->with('parent')
            ->orderBy('type', 'desc')
            ->orderBy('name')
            ->limit($limit)
            ->get();
    }

    /**
     * Get fallback region (default region when no location detected)
     */
    public function getFallbackRegion(): ?Region
    {
        return Cache::remember(
            'regions:fallback',
            now()->addDay(),
            fn () => Region::active()
                ->topLevel()
                ->orderBy('display_order')
                ->first()
        );
    }

    /**
     * Detect and resolve user's region with full fallback chain
     */
    public function detectUserRegion(?string $ip = null): ?Region
    {
        $ip = $ip ?? request()->ip();

        $storedRegion = $this->getUserLocation();
        if ($storedRegion !== null) {
            return $storedRegion;
        }

        $position = $this->detectFromIp($ip);

        // Use coordinate-based detection (finds nearest region of any type)
        if ($position !== null && $position->latitude !== null && $position->longitude !== null) {
            $region = $this->findNearestRegion((float) $position->latitude, (float) $position->longitude);
            if ($region !== null) {
                return $region;
            }
        }

        return $this->getFallbackRegion();
    }

    /**
     * Calculate distance between two coordinates using Haversine formula (in kilometers)
     */
    private function calculateDistance(float $lat1, float $lon1, float $lat2, float $lon2): float
    {
        $earthRadius = 6371;

        $latDelta = deg2rad($lat2 - $lat1);
        $lonDelta = deg2rad($lon2 - $lon1);

        $a = sin($latDelta / 2) * sin($latDelta / 2) +
            cos(deg2rad($lat1)) * cos(deg2rad($lat2)) *
            sin($lonDelta / 2) * sin($lonDelta / 2);

        $c = 2 * atan2(sqrt($a), sqrt(1 - $a));

        return $earthRadius * $c;
    }
}
```

### LoyaltyService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\User;
use App\Models\Business;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\DB;

final class LoyaltyService
{
    public function __construct(
        private readonly CacheService $cacheService
    ) {}

    /**
     * Enroll user in loyalty program
     */
    public function enroll(User $user, Business|string $business): void
    {
        $businessId = $business instanceof Business ? $business->id : $business;
        
        DB::beginTransaction();
        
        try {
            // Check if already enrolled (would need LoyaltyEnrollment model)
            // $exists = LoyaltyEnrollment::where('user_id', $user->id)
            //     ->where('business_id', $businessId)
            //     ->exists();
            //
            // if ($exists) {
            //     return;
            // }

            // Enroll user
            // LoyaltyEnrollment::create([
            //     'user_id' => $user->id,
            //     'business_id' => $businessId,
            //     'enrolled_at' => now(),
            //     'points' => 0,
            // ]);

            DB::commit();

            // Clear cache
            $this->clearUserCache($user, $businessId);
        } catch (\Exception $e) {
            DB::rollBack();
            throw $e;
        }
    }

    /**
     * Earn points for user
     */
    public function earnPoints(User $user, Business|string $business, int $points, string $reason, ?string $sourceType = null, ?string $sourceId = null): void
    {
        $businessId = $business instanceof Business ? $business->id : $business;
        
        DB::beginTransaction();
        
        try {
            // Get or create enrollment
            // $enrollment = LoyaltyEnrollment::firstOrCreate([
            //     'user_id' => $user->id,
            //     'business_id' => $businessId,
            // ], [
            //     'enrolled_at' => now(),
            //     'points' => 0,
            // ]);

            // Add points
            // $enrollment->increment('points', $points);

            // Log transaction (would need LoyaltyTransaction model)
            // LoyaltyTransaction::create([
            //     'user_id' => $user->id,
            //     'business_id' => $businessId,
            //     'points' => $points,
            //     'type' => 'earned',
            //     'reason' => $reason,
            //     'source_type' => $sourceType,
            //     'source_id' => $sourceId,
            // ]);

            DB::commit();

            // Clear cache
            $this->clearUserCache($user, $businessId);
        } catch (\Exception $e) {
            DB::rollBack();
            throw $e;
        }
    }

    /**
     * Redeem points
     */
    public function redeemPoints(User $user, Business|string $business, int $points, string $reason): void
    {
        $businessId = $business instanceof Business ? $business->id : $business;
        
        DB::beginTransaction();
        
        try {
            // Get enrollment
            // $enrollment = LoyaltyEnrollment::where('user_id', $user->id)
            //     ->where('business_id', $businessId)
            //     ->firstOrFail();

            // Check balance
            // if ($enrollment->points < $points) {
            //     throw new \Exception('Insufficient points');
            // }

            // Deduct points
            // $enrollment->decrement('points', $points);

            // Log transaction
            // LoyaltyTransaction::create([
            //     'user_id' => $user->id,
            //     'business_id' => $businessId,
            //     'points' => -$points,
            //     'type' => 'redeemed',
            //     'reason' => $reason,
            // ]);

            DB::commit();

            // Clear cache
            $this->clearUserCache($user, $businessId);
        } catch (\Exception $e) {
            DB::rollBack();
            throw $e;
        }
    }

    /**
     * Get points balance
     */
    public function getBalance(User $user, Business|string $business): int
    {
        $businessId = $business instanceof Business ? $business->id : $business;
        $cacheKey = "loyalty:balance:{$user->id}:{$businessId}";
        
        return (int) $this->cacheService->remember($cacheKey, now()->addMinutes(5), function () use ($user, $businessId) {
            // Would query LoyaltyEnrollment model
            // $enrollment = LoyaltyEnrollment::where('user_id', $user->id)
            //     ->where('business_id', $businessId)
            //     ->first();
            //
            // return $enrollment ? $enrollment->points : 0;
            
            return 0;
        });
    }

    /**
     * Get points history
     */
    public function getHistory(User $user, Business|string $business, int $limit = 50): Collection
    {
        $businessId = $business instanceof Business ? $business->id : $business;
        $cacheKey = "loyalty:history:{$user->id}:{$businessId}:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(5), function () use ($user, $businessId, $limit) {
            // Would query LoyaltyTransaction model
            // return LoyaltyTransaction::where('user_id', $user->id)
            //     ->where('business_id', $businessId)
            //     ->orderBy('created_at', 'desc')
            //     ->limit($limit)
            //     ->get();
            
            return collect([]);
        });
    }

    /**
     * Get user's loyalty programs
     */
    public function getUserPrograms(User $user): Collection
    {
        $cacheKey = "loyalty:programs:{$user->id}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($user) {
            // Would query LoyaltyEnrollment model
            // return LoyaltyEnrollment::where('user_id', $user->id)
            //     ->with('business')
            //     ->get();
            
            return collect([]);
        });
    }

    /**
     * Get business loyalty program stats
     */
    public function getBusinessStats(Business|string $business): array
    {
        $businessId = $business instanceof Business ? $business->id : $business;
        $cacheKey = "loyalty:stats:business:{$businessId}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($businessId) {
            // Would query LoyaltyEnrollment and LoyaltyTransaction models
            // return [
            //     'total_enrollments' => LoyaltyEnrollment::where('business_id', $businessId)->count(),
            //     'total_points_earned' => LoyaltyTransaction::where('business_id', $businessId)->where('type', 'earned')->sum('points'),
            //     'total_points_redeemed' => abs(LoyaltyTransaction::where('business_id', $businessId)->where('type', 'redeemed')->sum('points')),
            //     'active_points' => LoyaltyEnrollment::where('business_id', $businessId)->sum('points'),
            // ];
            
            return [
                'total_enrollments' => 0,
                'total_points_earned' => 0,
                'total_points_redeemed' => 0,
                'active_points' => 0,
            ];
        });
    }

    /**
     * Clear user-related cache
     */
    private function clearUserCache(User $user, ?string $businessId = null): void
    {
        if ($businessId) {
            $this->cacheService->forget("loyalty:balance:{$user->id}:{$businessId}");
            $this->cacheService->forget("loyalty:history:{$user->id}:{$businessId}:*");
        }
        
        $this->cacheService->forget("loyalty:programs:{$user->id}");
    }
}

```

### NewsService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\DayNewsPost;
use App\Models\User;
use App\Models\Region;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Pagination\LengthAwarePaginator;

final class NewsService
{
    public function __construct(
        private readonly CacheService $cacheService
    ) {}

    /**
     * Get published articles
     */
    public function getPublished(array $filters = [], int $perPage = 20): LengthAwarePaginator
    {
        $cacheKey = 'news:published:'.md5(serialize([$filters, $perPage]));
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(5), function () use ($filters, $perPage) {
            $query = DayNewsPost::published()
                ->with(['author', 'regions', 'tags']);

            // Filters
            if (isset($filters['category'])) {
                $query->where('category', $filters['category']);
            }

            if (isset($filters['type'])) {
                $query->where('type', $filters['type']);
            }

            if (isset($filters['region_id'])) {
                $query->whereHas('regions', function ($q) use ($filters) {
                    $q->where('regions.id', $filters['region_id']);
                });
            }

            if (isset($filters['author_id'])) {
                $query->where('author_id', $filters['author_id']);
            }

            if (isset($filters['tag'])) {
                $query->whereHas('tags', function ($q) use ($filters) {
                    $q->where('tags.slug', $filters['tag']);
                });
            }

            // Sorting
            $sortBy = $filters['sort_by'] ?? 'published_at';
            $sortOrder = $filters['sort_order'] ?? 'desc';
            $query->orderBy($sortBy, $sortOrder);

            return $query->paginate($perPage);
        });
    }

    /**
     * Get articles by category
     */
    public function getByCategory(string $category, int $limit = 20): Collection
    {
        $cacheKey = "news:category:{$category}:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($category, $limit) {
            return DayNewsPost::published()
                ->where('category', $category)
                ->with(['author', 'regions'])
                ->orderBy('published_at', 'desc')
                ->limit($limit)
                ->get();
        });
    }

    /**
     * Get articles by author
     */
    public function getByAuthor(User|string $author, int $perPage = 20): LengthAwarePaginator
    {
        $authorId = $author instanceof User ? $author->id : $author;
        $cacheKey = "news:author:{$authorId}:perPage:{$perPage}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($authorId, $perPage) {
            return DayNewsPost::published()
                ->where('author_id', $authorId)
                ->with(['regions', 'tags'])
                ->orderBy('published_at', 'desc')
                ->paginate($perPage);
        });
    }

    /**
     * Get related articles
     */
    public function getRelated(DayNewsPost $article, int $limit = 6): Collection
    {
        $cacheKey = "news:related:{$article->id}:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(30), function () use ($article, $limit) {
            $query = DayNewsPost::published()
                ->where('id', '!=', $article->id)
                ->with(['author', 'regions']);

            // Find articles with same category
            if ($article->category) {
                $query->where('category', $article->category);
            }

            // Find articles with same tags
            if ($article->tags->isNotEmpty()) {
                $tagIds = $article->tags->pluck('id');
                $query->whereHas('tags', function ($q) use ($tagIds) {
                    $q->whereIn('tags.id', $tagIds);
                });
            }

            // Find articles in same regions
            if ($article->regions->isNotEmpty()) {
                $regionIds = $article->regions->pluck('id');
                $query->whereHas('regions', function ($q) use ($regionIds) {
                    $q->whereIn('regions.id', $regionIds);
                });
            }

            return $query->orderBy('published_at', 'desc')
                ->limit($limit)
                ->get();
        });
    }

    /**
     * Get trending articles
     */
    public function getTrending(int $limit = 10, string $timePeriod = '7d'): Collection
    {
        $cacheKey = "news:trending:{$timePeriod}:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(5), function () use ($limit, $timePeriod) {
            $query = DayNewsPost::published()
                ->with(['author', 'regions']);

            // Time period filter
            match ($timePeriod) {
                '24h' => $query->where('published_at', '>=', now()->subDay()),
                '7d' => $query->where('published_at', '>=', now()->subWeek()),
                '30d' => $query->where('published_at', '>=', now()->subMonth()),
                default => null,
            };

            // Order by view count and recency
            return $query->orderBy('view_count', 'desc')
                ->orderBy('published_at', 'desc')
                ->limit($limit)
                ->get();
        });
    }

    /**
     * Get featured articles
     */
    public function getFeatured(int $limit = 6): Collection
    {
        $cacheKey = "news:featured:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(30), function () use ($limit) {
            return DayNewsPost::published()
                ->whereNotNull('featured_image')
                ->with(['author', 'regions'])
                ->orderBy('published_at', 'desc')
                ->limit($limit)
                ->get();
        });
    }

    /**
     * Get articles by region
     */
    public function getByRegion(Region|string $region, int $limit = 20): Collection
    {
        $regionId = $region instanceof Region ? $region->id : $region;
        $cacheKey = "news:region:{$regionId}:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($regionId, $limit) {
            return DayNewsPost::published()
                ->whereHas('regions', function ($q) use ($regionId) {
                    $q->where('regions.id', $regionId);
                })
                ->with(['author', 'tags'])
                ->orderBy('published_at', 'desc')
                ->limit($limit)
                ->get();
        });
    }

    /**
     * Increment view count
     */
    public function incrementViewCount(DayNewsPost $article): void
    {
        $article->increment('view_count');
        $this->cacheService->forget("news:trending:*");
    }

    /**
     * Clear news-related cache
     */
    public function clearCache(?DayNewsPost $article = null): void
    {
        $this->cacheService->forget('news:*');
        
        if ($article) {
            $this->cacheService->forget("news:related:{$article->id}:*");
            
            if ($article->category) {
                $this->cacheService->forget("news:category:{$article->category}:*");
            }
            
            if ($article->author_id) {
                $this->cacheService->forget("news:author:{$article->author_id}:*");
            }
            
            foreach ($article->regions as $region) {
                $this->cacheService->forget("news:region:{$region->id}:*");
            }
        }
    }
}

```

### NotificationIntegrationService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Jobs\SendNotificationJob;
use App\Models\NotificationSubscription;
use Illuminate\Support\Facades\Log;

/**
 * Helper service to integrate notification system with existing events
 */
final class NotificationIntegrationService
{
    private NotificationService $notificationService;
    private WebPushService $webPushService;

    public function __construct(
        NotificationService $notificationService,
        WebPushService $webPushService
    ) {
        $this->notificationService = $notificationService;
        $this->webPushService = $webPushService;
    }

    /**
     * Send notification for breaking news (Day.News)
     */
    public function sendBreakingNews(string $communityId, string $title, string $message, ?string $url = null): void
    {
        $this->sendNotification(
            platform: 'daynews',
            communityId: $communityId,
            type: 'breaking_news',
            title: $title,
            message: $message,
            url: $url,
            sendSms: true,
            sendPush: true
        );
    }

    /**
     * Send notification for event reminder (GoEventCity)
     */
    public function sendEventReminder(string $communityId, string $eventTitle, string $message, ?string $url = null): void
    {
        $this->sendNotification(
            platform: 'goeventcity',
            communityId: $communityId,
            type: 'events',
            title: "Event Reminder: {$eventTitle}",
            message: $message,
            url: $url,
            sendSms: false,
            sendPush: true
        );
    }

    /**
     * Send notification for order confirmation (GoEventCity)
     */
    public function sendOrderConfirmation(string $communityId, string $orderId, string $message, ?string $url = null): void
    {
        $this->sendNotification(
            platform: 'goeventcity',
            communityId: $communityId,
            type: 'events',
            title: 'Order Confirmation',
            message: $message,
            url: $url,
            sendSms: true,
            sendPush: true
        );
    }

    /**
     * Send notification for deal alert (DowntownsGuide)
     */
    public function sendDealAlert(string $communityId, string $title, string $message, ?string $url = null): void
    {
        $this->sendNotification(
            platform: 'downtownguide',
            communityId: $communityId,
            type: 'deals',
            title: $title,
            message: $message,
            url: $url,
            sendSms: false,
            sendPush: true
        );
    }

    /**
     * Send notification for booking confirmation (DowntownsGuide)
     */
    public function sendBookingConfirmation(string $communityId, string $title, string $message, ?string $url = null): void
    {
        $this->sendNotification(
            platform: 'downtownguide',
            communityId: $communityId,
            type: 'deals',
            title: $title,
            message: $message,
            url: $url,
            sendSms: true,
            sendPush: true
        );
    }

    /**
     * Send notification for business update (AlphaSite)
     */
    public function sendBusinessUpdate(string $businessId, string $title, string $message, ?string $url = null): void
    {
        // For AlphaSite, community_id is the business_id
        $this->sendNotification(
            platform: 'alphasite',
            communityId: $businessId,
            type: 'general',
            title: $title,
            message: $message,
            url: $url,
            sendSms: false,
            sendPush: true
        );
    }

    /**
     * Generic notification sender
     */
    public function sendNotification(
        string $platform,
        string $communityId,
        string $type,
        string $title,
        string $message,
        ?string $url = null,
        bool $sendSms = false,
        bool $sendPush = false
    ): void {
        // Queue the notification job
        SendNotificationJob::dispatch(
            platform: $platform,
            communityId: $communityId,
            notificationType: $type,
            title: $title,
            message: $message,
            url: $url,
            sendSms: $sendSms,
            sendPush: $sendPush
        );
    }

    /**
     * Check if user should receive notification (respects quiet hours and preferences)
     */
    public function shouldSendNotification(NotificationSubscription $subscription, string $type): bool
    {
        if ($subscription->status !== 'active') {
            return false;
        }

        if (!$subscription->wantsNotificationType($type)) {
            return false;
        }

        if ($subscription->isQuietHours()) {
            return false;
        }

        return true;
    }
}

```

### NotificationService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use Aws\Sns\SnsClient;
use Aws\Exception\AwsException;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;

final class NotificationService
{
    private SnsClient $snsClient;
    private string $topicPrefix;

    public function __construct()
    {
        $awsKey = config('services.sns.key', config('services.ses.key'));
        $awsSecret = config('services.sns.secret', config('services.ses.secret'));
        $awsRegion = config('services.sns.region', config('services.ses.region', 'us-east-1'));

        if (empty($awsKey) || empty($awsSecret)) {
            throw new \RuntimeException(
                'AWS SNS credentials not configured. Please set AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY in your .env file. ' .
                'For testing, you can use AWS IAM credentials with SNS permissions from https://console.aws.amazon.com/iam/'
            );
        }

        $this->snsClient = new SnsClient([
            'version' => 'latest',
            'region' => $awsRegion,
            'credentials' => [
                'key' => $awsKey,
                'secret' => $awsSecret,
            ],
        ]);

        $this->topicPrefix = config('services.sns.topic_prefix', 'shine-notifications');
    }

    /**
     * Get or create SNS topic for a platform/community combination
     */
    public function getOrCreateTopic(string $platform, string $communityId): string
    {
        $topicName = "{$this->topicPrefix}-{$platform}-{$communityId}";
        $cacheKey = "sns_topic_arn:{$topicName}";

        return Cache::remember($cacheKey, 86400, function () use ($topicName) {
            try {
                $result = $this->snsClient->createTopic([
                    'Name' => $topicName,
                    'Tags' => [
                        ['Key' => 'Platform', 'Value' => $platform],
                        ['Key' => 'Environment', 'Value' => app()->environment()],
                    ],
                ]);

                return $result['TopicArn'];
            } catch (AwsException $e) {
                // Topic might already exist, try to get it
                if (str_contains($e->getMessage(), 'already exists')) {
                    try {
                        $result = $this->snsClient->listTopics();
                        foreach ($result['Topics'] as $topic) {
                            if (str_contains($topic['TopicArn'], $topicName)) {
                                return $topic['TopicArn'];
                            }
                        }
                    } catch (AwsException $listException) {
                        Log::error('SNS Topic List Failed', [
                            'topic' => $topicName,
                            'error' => $listException->getMessage()
                        ]);
                    }
                }

                Log::error('SNS Topic Creation Failed', [
                    'topic' => $topicName,
                    'error' => $e->getMessage()
                ]);
                throw $e;
            }
        });
    }

    /**
     * Subscribe phone number to SMS notifications
     */
    public function subscribePhoneToSMS(string $phoneNumber, string $platform, string $communityId): ?string
    {
        $topicArn = $this->getOrCreateTopic($platform, $communityId);

        try {
            $result = $this->snsClient->subscribe([
                'TopicArn' => $topicArn,
                'Protocol' => 'sms',
                'Endpoint' => $phoneNumber,
                'ReturnSubscriptionArn' => true,
            ]);

            return $result['SubscriptionArn'];
        } catch (AwsException $e) {
            Log::error('SMS Subscription Failed', [
                'phone' => substr($phoneNumber, 0, 6) . '****',
                'platform' => $platform,
                'community' => $communityId,
                'error' => $e->getMessage()
            ]);
            return null;
        }
    }

    /**
     * Send SMS directly (for verification codes, urgent alerts)
     */
    public function sendDirectSMS(string $phoneNumber, string $message, ?string $senderId = null): bool
    {
        try {
            $params = [
                'PhoneNumber' => $phoneNumber,
                'Message' => $message,
                'MessageAttributes' => [
                    'AWS.SNS.SMS.SMSType' => [
                        'DataType' => 'String',
                        'StringValue' => config('services.sns.sms_type', 'Transactional'),
                    ],
                ],
            ];

            if ($senderId) {
                $params['MessageAttributes']['AWS.SNS.SMS.SenderID'] = [
                    'DataType' => 'String',
                    'StringValue' => $senderId,
                ];
            }

            $this->snsClient->publish($params);
            return true;
        } catch (AwsException $e) {
            Log::error('Direct SMS Failed', [
                'phone' => substr($phoneNumber, 0, 6) . '****',
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }

    /**
     * Publish notification to topic (broadcasts to all subscribers)
     */
    public function publishToTopic(
        string $platform,
        string $communityId,
        string $message,
        array $options = []
    ): ?string {
        $topicArn = $this->getOrCreateTopic($platform, $communityId);

        try {
            // Build message structure for multi-protocol delivery
            $messageStructure = [
                'default' => $message,
                'sms' => $this->truncateForSMS($message),
            ];

            // Add HTTPS/Lambda payload if provided
            if (isset($options['payload'])) {
                $messageStructure['https'] = json_encode($options['payload']);
                $messageStructure['lambda'] = json_encode($options['payload']);
            }

            $result = $this->snsClient->publish([
                'TopicArn' => $topicArn,
                'MessageStructure' => 'json',
                'Message' => json_encode($messageStructure),
                'Subject' => $options['subject'] ?? null,
                'MessageAttributes' => [
                    'notification_type' => [
                        'DataType' => 'String',
                        'StringValue' => $options['type'] ?? 'general',
                    ],
                    'platform' => [
                        'DataType' => 'String',
                        'StringValue' => $platform,
                    ],
                ],
            ]);

            return $result['MessageId'];
        } catch (AwsException $e) {
            Log::error('Topic Publish Failed', [
                'platform' => $platform,
                'community' => $communityId,
                'error' => $e->getMessage()
            ]);
            return null;
        }
    }

    /**
     * Unsubscribe from topic
     */
    public function unsubscribe(string $subscriptionArn): bool
    {
        try {
            $this->snsClient->unsubscribe([
                'SubscriptionArn' => $subscriptionArn,
            ]);
            return true;
        } catch (AwsException $e) {
            Log::error('Unsubscribe Failed', [
                'subscription_arn' => $subscriptionArn,
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }

    /**
     * Truncate message for SMS (160 chars for single segment)
     */
    protected function truncateForSMS(string $message, int $maxLength = 155): string
    {
        if (strlen($message) <= $maxLength) {
            return $message;
        }
        return substr($message, 0, $maxLength - 3) . '...';
    }
}

```

### OrganizationService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\Business;
use App\Models\OrganizationRelationship;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Support\Facades\DB;

final class OrganizationService
{
    public function __construct(
        private readonly CacheService $cacheService
    ) {}

    /**
     * Get all content related to an organization
     */
    public function getOrganizationContent(
        Business $organization,
        array $contentTypes = [],
        array $relationshipTypes = []
    ): array {
        $cacheKey = "org_content:{$organization->id}:".md5(serialize([$contentTypes, $relationshipTypes]));
        
        return $this->cacheService->remember($cacheKey, now()->addHours(1), function () use ($organization, $contentTypes, $relationshipTypes) {
            $query = OrganizationRelationship::where('organization_id', $organization->id);
            
            if (!empty($contentTypes)) {
                $query->whereIn('relatable_type', $contentTypes);
            }
            
            if (!empty($relationshipTypes)) {
                $query->whereIn('relationship_type', $relationshipTypes);
            }
            
            $relationships = $query->with('relatable')->get();
            
            return $relationships->groupBy('relatable_type')->map(function ($group) {
                return $group->pluck('relatable')->filter();
            })->toArray();
        });
    }

    /**
     * Get organization hierarchy (parent and children)
     */
    public function getOrganizationHierarchy(Business $organization): array
    {
        $cacheKey = "org_hierarchy:{$organization->id}";
        
        return $this->cacheService->remember($cacheKey, now()->addHours(6), function () use ($organization) {
            $hierarchy = [
                'organization' => $organization,
                'parent' => $organization->parentOrganization,
                'children' => $organization->childOrganizations,
                'ancestors' => $this->getAncestors($organization),
                'descendants' => $this->getDescendants($organization),
            ];
            
            return $hierarchy;
        });
    }

    /**
     * Get content for organization and all related organizations (hierarchy)
     */
    public function getOrganizationContentWithHierarchy(
        Business $organization,
        array $contentTypes = []
    ): array {
        $hierarchy = $this->getOrganizationHierarchy($organization);
        $organizationIds = collect([
            $organization->id,
            $hierarchy['parent']?->id,
            ...$hierarchy['children']->pluck('id'),
        ])->filter()->unique();
        
        $query = OrganizationRelationship::whereIn('organization_id', $organizationIds);
        
        if (!empty($contentTypes)) {
            $query->whereIn('relatable_type', $contentTypes);
        }
        
        $relationships = $query->with(['organization', 'relatable'])->get();
        
        return $relationships->groupBy('organization_id')->map(function ($group, $orgId) {
            return [
                'organization' => $group->first()->organization,
                'content' => $group->groupBy('relatable_type')->map(function ($items) {
                    return $items->pluck('relatable')->filter();
                }),
            ];
        })->toArray();
    }

    /**
     * Create organization relationship
     */
    public function createRelationship(
        \Illuminate\Database\Eloquent\Model $relatable,
        Business $organization,
        string $relationshipType = 'related',
        bool $isPrimary = false,
        array $metadata = []
    ): OrganizationRelationship {
        return $relatable->relateToOrganization($organization, $relationshipType, $isPrimary, $metadata);
    }

    /**
     * Get organizations by type and level
     */
    public function getOrganizationsByTypeAndLevel(
        string $type,
        string $level = null,
        int $limit = 50
    ): Collection {
        $query = Business::organizations()->byOrganizationType($type);
        
        if ($level) {
            $query->byOrganizationLevel($level);
        }
        
        return $query->limit($limit)->get();
    }

    /**
     * Search organizations
     */
    public function searchOrganizations(
        string $query,
        array $filters = []
    ): Collection {
        $searchQuery = Business::organizations()
            ->where(function ($q) use ($query) {
                $q->where('name', 'like', "%{$query}%")
                  ->orWhere('description', 'like', "%{$query}%");
            });
        
        if (isset($filters['type'])) {
            $searchQuery->byOrganizationType($filters['type']);
        }
        
        if (isset($filters['level'])) {
            $searchQuery->byOrganizationLevel($filters['level']);
        }
        
        if (isset($filters['category'])) {
            $searchQuery->where('organization_category', $filters['category']);
        }
        
        return $searchQuery->get();
    }

    /**
     * Get ancestors (parent organizations up the hierarchy)
     */
    private function getAncestors(Business $organization): Collection
    {
        $ancestors = collect();
        $current = $organization->parentOrganization;
        
        while ($current) {
            $ancestors->push($current);
            $current = $current->parentOrganization;
        }
        
        return $ancestors;
    }

    /**
     * Get descendants (child organizations down the hierarchy)
     */
    private function getDescendants(Business $organization): Collection
    {
        $descendants = collect();
        $children = $organization->childOrganizations;
        
        foreach ($children as $child) {
            $descendants->push($child);
            $descendants = $descendants->merge($this->getDescendants($child));
        }
        
        return $descendants;
    }
}

```

### PhoneVerificationService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\PhoneVerification;
use Carbon\Carbon;
use Illuminate\Support\Facades\Log;

final class PhoneVerificationService
{
    private NotificationService $notificationService;

    public function __construct(NotificationService $notificationService)
    {
        $this->notificationService = $notificationService;
    }

    /**
     * Send verification code to phone number
     */
    public function sendVerificationCode(string $phoneNumber, string $platform): bool
    {
        // Rate limit: max 3 codes per phone per hour
        $recentAttempts = PhoneVerification::where('phone_number', $phoneNumber)
            ->where('created_at', '>', Carbon::now()->subHour())
            ->count();

        if ($recentAttempts >= 3) {
            throw new \Exception('Too many verification attempts. Please try again later.');
        }

        // Generate 6-digit code
        $code = str_pad((string) random_int(0, 999999), 6, '0', STR_PAD_LEFT);

        // Store verification record
        PhoneVerification::create([
            'phone_number' => $phoneNumber,
            'code' => $code,
            'expires_at' => Carbon::now()->addMinutes(10),
        ]);

        // Send SMS
        $platformNames = [
            'daynews' => 'Day News',
            'goeventcity' => 'Go Event City',
            'downtownguide' => 'Downtown Guide',
            'alphasite' => 'Your Business Site',
        ];

        $platformName = $platformNames[$platform] ?? 'Shine';
        $message = "{$code} is your {$platformName} verification code. Expires in 10 minutes.";

        $sent = $this->notificationService->sendDirectSMS($phoneNumber, $message);

        if (!$sent) {
            Log::error('Verification code SMS send failed', [
                'phone' => substr($phoneNumber, 0, 6) . '****',
                'platform' => $platform,
            ]);
            throw new \Exception('Failed to send verification code. Please try again.');
        }

        return true;
    }

    /**
     * Verify code
     */
    public function verifyCode(string $phoneNumber, string $code): bool
    {
        $verification = PhoneVerification::where('phone_number', $phoneNumber)
            ->where('code', $code)
            ->where('expires_at', '>', Carbon::now())
            ->where('verified', false)
            ->where('attempts', '<', 5)
            ->first();

        if (!$verification) {
            // Increment attempts on most recent unverified record
            PhoneVerification::where('phone_number', $phoneNumber)
                ->where('verified', false)
                ->latest()
                ->first()
                ?->increment('attempts');

            return false;
        }

        $verification->update(['verified' => true]);

        return true;
    }
}

```

### ProfileService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\User;
use Illuminate\Support\Collection;

final class ProfileService
{
    public function __construct(
        private readonly CacheService $cacheService
    ) {}

    /**
     * Get user profile
     */
    public function getProfile(User|string $user): User
    {
        $userId = $user instanceof User ? $user->id : $user;
        $cacheKey = "profile:{$userId}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($userId) {
            return User::with([
                'workspaces',
                'currentWorkspace',
                'socialAccounts',
            ])->findOrFail($userId);
        });
    }

    /**
     * Update user profile
     */
    public function updateProfile(User $user, array $data): User
    {
        $user->update($data);

        // Clear cache
        $this->clearProfileCache($user);

        return $user->fresh();
    }

    /**
     * Get user statistics
     */
    public function getStats(User $user): array
    {
        $cacheKey = "profile:stats:{$user->id}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(5), function () use ($user) {
            return [
                'reviews_count' => $this->getReviewsCount($user),
                'ratings_count' => $this->getRatingsCount($user),
                'articles_count' => $this->getArticlesCount($user),
                'events_count' => $this->getEventsCount($user),
                'coupons_count' => $this->getCouponsCount($user),
                'followers_count' => $this->getFollowersCount($user),
                'following_count' => $this->getFollowingCount($user),
                'total_points' => $user->total_points ?? 0,
                'level' => $user->level ?? 1,
                'achievements_count' => $this->getAchievementsCount($user),
            ];
        });
    }

    /**
     * Get user activity feed
     */
    public function getActivity(User $user, int $limit = 20): Collection
    {
        $cacheKey = "profile:activity:{$user->id}:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(5), function () use ($user, $limit) {
            // This would typically query a social_activities table
            // For now, return empty collection - implement when activity tracking is available
            return collect([]);
        });
    }

    /**
     * Get user reviews count
     */
    private function getReviewsCount(User $user): int
    {
        return \App\Models\Review::where('user_id', $user->id)
            ->where('status', 'approved')
            ->count();
    }

    /**
     * Get user ratings count
     */
    private function getRatingsCount(User $user): int
    {
        return \App\Models\Rating::where('user_id', $user->id)->count();
    }

    /**
     * Get user articles count
     */
    private function getArticlesCount(User $user): int
    {
        return \App\Models\DayNewsPost::where('author_id', $user->id)
            ->where('status', 'published')
            ->count();
    }

    /**
     * Get user events count
     */
    private function getEventsCount(User $user): int
    {
        return \App\Models\Event::where('created_by', $user->id)
            ->where('status', 'published')
            ->count();
    }

    /**
     * Get user coupons count
     */
    private function getCouponsCount(User $user): int
    {
        return \App\Models\Coupon::where('user_id', $user->id)
            ->where('status', 'active')
            ->count();
    }

    /**
     * Get user followers count
     */
    private function getFollowersCount(User $user): int
    {
        return \App\Models\Follow::where('followable_type', User::class)
            ->where('followable_id', $user->id)
            ->count();
    }

    /**
     * Get user following count
     */
    private function getFollowingCount(User $user): int
    {
        return \App\Models\Follow::where('user_id', $user->id)->count();
    }

    /**
     * Get user achievements count
     */
    private function getAchievementsCount(User $user): int
    {
        // This would query an achievements table when it exists
        return 0;
    }

    /**
     * Clear profile-related cache
     */
    private function clearProfileCache(User $user): void
    {
        $this->cacheService->forget("profile:{$user->id}");
        $this->cacheService->forget("profile:stats:{$user->id}");
        $this->cacheService->forget("profile:activity:{$user->id}:*");
    }
}

```

### PromoCodeService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\PromoCode;
use App\Models\PromoCodeUsage;
use App\Models\TicketOrder;
use App\Models\User;

final class PromoCodeService
{
    public function validateCode(string $code, float $amount, ?string $eventId = null): array
    {
        $promoCode = PromoCode::where('code', strtoupper($code))->first();

        if (!$promoCode) {
            return [
                'valid' => false,
                'message' => 'Invalid promo code.',
            ];
        }

        if (!$promoCode->isValid()) {
            return [
                'valid' => false,
                'message' => 'This promo code is no longer valid.',
            ];
        }

        // Check if applicable to event
        if ($eventId && $promoCode->applicable_to) {
            if (!in_array($eventId, $promoCode->applicable_to)) {
                return [
                    'valid' => false,
                    'message' => 'This promo code is not applicable to this event.',
                ];
            }
        }

        $discount = $promoCode->calculateDiscount($amount);

        return [
            'valid' => true,
            'promo_code' => $promoCode,
            'discount' => $discount,
            'final_amount' => $amount - $discount,
        ];
    }

    public function applyCode(PromoCode $promoCode, TicketOrder $order, User $user): PromoCodeUsage
    {
        $discount = $promoCode->calculateDiscount((float) $order->subtotal);

        // Record usage
        $usage = PromoCodeUsage::create([
            'promo_code_id' => $promoCode->id,
            'user_id' => $user->id,
            'ticket_order_id' => $order->id,
            'discount_amount' => $discount,
            'original_amount' => $order->subtotal,
            'final_amount' => $order->subtotal - $discount,
            'used_at' => now(),
        ]);

        // Increment usage count
        $promoCode->increment('used_count');

        return $usage;
    }

    public function createCode(array $data): PromoCode
    {
        if (empty($data['code'])) {
            $data['code'] = PromoCode::generateUniqueCode();
        } else {
            $data['code'] = strtoupper($data['code']);
        }

        return PromoCode::create($data);
    }

    public function updateCode(PromoCode $promoCode, array $data): PromoCode
    {
        if (isset($data['code'])) {
            $data['code'] = strtoupper($data['code']);
        }

        $promoCode->update($data);

        return $promoCode;
    }
}

```

### QRCodeService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\TicketOrderItem;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Str;

final class QRCodeService
{
    /**
     * Generate QR code for a ticket order item
     */
    public function generateForTicketOrderItem(TicketOrderItem $ticketOrderItem): string
    {
        // Generate a unique ticket code
        $ticketCode = $this->generateTicketCode($ticketOrderItem);

        // Create QR code data URL
        $qrData = $this->generateQRCodeData($ticketCode, $ticketOrderItem);

        // Store QR code as image file
        $qrCodePath = $this->storeQRCode($ticketCode, $qrData);

        // Update ticket order item with QR code path
        $ticketOrderItem->update([
            'qr_code' => $qrCodePath,
            'ticket_code' => $ticketCode,
        ]);

        return $qrCodePath;
    }

    /**
     * Generate a unique ticket code
     */
    private function generateTicketCode(TicketOrderItem $ticketOrderItem): string
    {
        // Format: ORDER_ID-ITEM_ID-RANDOM
        $orderId = Str::substr($ticketOrderItem->ticket_order_id, 0, 8);
        $itemId = Str::substr($ticketOrderItem->id, 0, 8);
        $random = Str::random(8);

        return strtoupper("{$orderId}-{$itemId}-{$random}");
    }

    /**
     * Generate QR code data (URL or data string)
     */
    private function generateQRCodeData(string $ticketCode, TicketOrderItem $ticketOrderItem): string
    {
        // Create a verification URL for the ticket
        $baseUrl = config('app.url');
        $verificationUrl = "{$baseUrl}/tickets/verify/{$ticketCode}";

        return $verificationUrl;
    }

    /**
     * Store QR code image file
     */
    private function storeQRCode(string $ticketCode, string $data): string
    {
        // Use a simple QR code generation API (no external dependencies)
        // In production, you might want to use a library like simplesoftwareio/simple-qrcode
        $qrCodeUrl = "https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=".urlencode($data);

        // Download and store the QR code image
        $qrCodeImage = file_get_contents($qrCodeUrl);
        $filename = "tickets/qr-codes/{$ticketCode}.png";
        Storage::disk('public')->put($filename, $qrCodeImage);

        return $filename;
    }

    /**
     * Get QR code image URL
     */
    public function getQRCodeUrl(string $qrCodePath): string
    {
        return Storage::disk('public')->url($qrCodePath);
    }

    /**
     * Verify ticket code
     */
    public function verifyTicketCode(string $ticketCode): ?TicketOrderItem
    {
        $ticketOrderItem = TicketOrderItem::where('ticket_code', $ticketCode)
            ->with(['ticketOrder.event', 'ticketPlan'])
            ->first();

        if (!$ticketOrderItem) {
            return null;
        }

        // Check if ticket order is completed
        if ($ticketOrderItem->ticketOrder->status !== 'completed') {
            return null;
        }

        return $ticketOrderItem;
    }
}

```

### ReferralService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\User;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Str;

final class ReferralService
{
    public function __construct(
        private readonly CacheService $cacheService
    ) {}

    /**
     * Create referral code for user
     */
    public function createReferralCode(User $user): string
    {
        // Generate unique referral code if not exists
        if (!$user->referral_code) {
            do {
                $code = strtoupper(Str::random(8));
            } while (User::where('referral_code', $code)->exists());

            $user->update(['referral_code' => $code]);
            $this->clearUserCache($user);
        }

        return $user->referral_code;
    }

    /**
     * Track referral
     */
    public function trackReferral(User $referrer, User $referred, string $source = 'direct'): void
    {
        DB::beginTransaction();
        
        try {
            // Create referral record (would need Referral model)
            // Referral::create([
            //     'referrer_id' => $referrer->id,
            //     'referred_id' => $referred->id,
            //     'referral_code' => $referrer->referral_code,
            //     'source' => $source,
            //     'status' => 'pending',
            //     'referred_at' => now(),
            // ]);

            // Update referred user
            $referred->update(['referred_by_id' => $referrer->id]);

            DB::commit();

            // Clear cache
            $this->clearUserCache($referrer);
            $this->clearUserCache($referred);
        } catch (\Exception $e) {
            DB::rollBack();
            throw $e;
        }
    }

    /**
     * Get referrals for user
     */
    public function getReferrals(User $user, string $status = 'all'): Collection
    {
        $cacheKey = "referrals:{$user->id}:{$status}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($user, $status) {
            // Would query Referral model
            // $query = Referral::where('referrer_id', $user->id)
            //     ->with('referred');
            //
            // if ($status !== 'all') {
            //     $query->where('status', $status);
            // }
            //
            // return $query->orderBy('referred_at', 'desc')->get();
            
            return collect([]);
        });
    }

    /**
     * Get referral stats
     */
    public function getReferralStats(User $user): array
    {
        $cacheKey = "referrals:stats:{$user->id}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($user) {
            // Would query Referral model
            // return [
            //     'total_referrals' => Referral::where('referrer_id', $user->id)->count(),
            //     'active_referrals' => Referral::where('referrer_id', $user->id)->where('status', 'active')->count(),
            //     'pending_referrals' => Referral::where('referrer_id', $user->id)->where('status', 'pending')->count(),
            //     'total_rewards' => Referral::where('referrer_id', $user->id)->sum('reward_amount'),
            // ];
            
            return [
                'total_referrals' => 0,
                'active_referrals' => 0,
                'pending_referrals' => 0,
                'total_rewards' => 0,
            ];
        });
    }

    /**
     * Award referral bonus
     */
    public function awardReferralBonus(User $referrer, User $referred, int $points, string $reason = 'referral_bonus'): void
    {
        DB::beginTransaction();
        
        try {
            // Update referral status
            // $referral = Referral::where('referrer_id', $referrer->id)
            //     ->where('referred_id', $referred->id)
            //     ->first();
            //
            // if ($referral) {
            //     $referral->update([
            //         'status' => 'active',
            //         'reward_amount' => $points,
            //         'rewarded_at' => now(),
            //     ]);
            // }

            // Award points to referrer (using GamificationService if available)
            // app(GamificationService::class)->awardPoints($referrer, $points, $reason, 'referral', $referral->id ?? null);

            DB::commit();

            // Clear cache
            $this->clearUserCache($referrer);
        } catch (\Exception $e) {
            DB::rollBack();
            throw $e;
        }
    }

    /**
     * Validate referral code
     */
    public function validateReferralCode(string $code): ?User
    {
        return User::where('referral_code', $code)->first();
    }

    /**
     * Get referral chain (who referred this user and who they referred)
     */
    public function getReferralChain(User $user): array
    {
        $cacheKey = "referrals:chain:{$user->id}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($user) {
            $chain = [
                'referred_by' => null,
                'referred_users' => [],
            ];

            // Get who referred this user
            if ($user->referred_by_id) {
                $chain['referred_by'] = User::find($user->referred_by_id);
            }

            // Get users referred by this user
            // $chain['referred_users'] = Referral::where('referrer_id', $user->id)
            //     ->with('referred')
            //     ->get()
            //     ->pluck('referred');

            return $chain;
        });
    }

    /**
     * Clear user-related cache
     */
    private function clearUserCache(User $user): void
    {
        $this->cacheService->forget("referrals:{$user->id}:*");
        $this->cacheService->forget("referrals:stats:{$user->id}");
        $this->cacheService->forget("referrals:chain:{$user->id}");
    }
}

```

### ReviewService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\Review;
use App\Models\Rating;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\DB;

final class ReviewService
{
    public function __construct(
        private readonly CacheService $cacheService
    ) {}

    /**
     * Create a new review
     */
    public function create(Model $reviewable, array $data, int $userId): Review
    {
        DB::beginTransaction();
        
        try {
            // Create review
            $review = Review::create([
                'reviewable_type' => get_class($reviewable),
                'reviewable_id' => $reviewable->id,
                'user_id' => $userId,
                'title' => $data['title'] ?? null,
                'content' => $data['content'],
                'rating' => $data['rating'],
                'status' => $data['status'] ?? 'pending',
            ]);

            // Create rating if provided
            if (isset($data['rating'])) {
                $this->createRating($reviewable, $userId, $data['rating'], $data['context'] ?? null);
            }

            // Update reviewable's rating cache
            $this->updateReviewableRating($reviewable);

            DB::commit();

            // Clear cache
            $this->clearReviewCache($reviewable);

            return $review->fresh(['user']);
        } catch (\Exception $e) {
            DB::rollBack();
            throw $e;
        }
    }

    /**
     * Update an existing review
     */
    public function update(Review $review, array $data): Review
    {
        DB::beginTransaction();
        
        try {
            $review->update($data);

            // Update rating if changed
            if (isset($data['rating'])) {
                $rating = Rating::where('ratable_type', $review->reviewable_type)
                    ->where('ratable_id', $review->reviewable_id)
                    ->where('user_id', $review->user_id)
                    ->first();

                if ($rating) {
                    $rating->update(['rating' => $data['rating']]);
                } else {
                    $this->createRating($review->reviewable, $review->user_id, $data['rating']);
                }

                // Update reviewable's rating cache
                $this->updateReviewableRating($review->reviewable);
            }

            DB::commit();

            // Clear cache
            $this->clearReviewCache($review->reviewable);

            return $review->fresh(['user']);
        } catch (\Exception $e) {
            DB::rollBack();
            throw $e;
        }
    }

    /**
     * Approve a review
     */
    public function approve(Review $review, ?int $approvedBy = null): Review
    {
        $review->update([
            'status' => 'approved',
            'approved_at' => now(),
            'approved_by' => $approvedBy,
        ]);

        // Update reviewable's rating cache
        $this->updateReviewableRating($review->reviewable);

        // Clear cache
        $this->clearReviewCache($review->reviewable);

        return $review->fresh();
    }

    /**
     * Reject a review
     */
    public function reject(Review $review, string $reason, ?int $rejectedBy = null): Review
    {
        $review->update([
            'status' => 'rejected',
            'rejection_reason' => $reason,
            'approved_by' => $rejectedBy,
        ]);

        // Clear cache
        $this->clearReviewCache($review->reviewable);

        return $review->fresh();
    }

    /**
     * Get reviews for a model
     */
    public function getForModel(Model $reviewable, array $filters = [], int $perPage = 20): \Illuminate\Contracts\Pagination\LengthAwarePaginator
    {
        $cacheKey = 'reviews:'.get_class($reviewable).':'.$reviewable->id.':'.md5(serialize([$filters, $perPage]));
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(5), function () use ($reviewable, $filters, $perPage) {
            $query = Review::where('reviewable_type', get_class($reviewable))
                ->where('reviewable_id', $reviewable->id)
                ->with(['user']);

            // Filters
            if (isset($filters['status'])) {
                $query->where('status', $filters['status']);
            } else {
                $query->where('status', 'approved');
            }

            if (isset($filters['rating'])) {
                $query->where('rating', $filters['rating']);
            }

            if (isset($filters['is_featured'])) {
                $query->where('is_featured', $filters['is_featured']);
            }

            if (isset($filters['is_verified'])) {
                $query->where('is_verified', $filters['is_verified']);
            }

            // Sorting
            $sortBy = $filters['sort_by'] ?? 'created_at';
            $sortOrder = $filters['sort_order'] ?? 'desc';
            
            if ($sortBy === 'helpful') {
                $query->orderBy('helpful_count', $sortOrder);
            } else {
                $query->orderBy($sortBy, $sortOrder);
            }

            return $query->paginate($perPage);
        });
    }

    /**
     * Get average rating for a model
     */
    public function getAverageRating(Model $reviewable): float
    {
        $cacheKey = 'rating:avg:'.get_class($reviewable).':'.$reviewable->id;
        
        return (float) $this->cacheService->remember($cacheKey, now()->addHours(1), function () use ($reviewable) {
            return Review::where('reviewable_type', get_class($reviewable))
                ->where('reviewable_id', $reviewable->id)
                ->where('status', 'approved')
                ->avg('rating') ?? 0.0;
        });
    }

    /**
     * Get rating distribution for a model
     */
    public function getRatingDistribution(Model $reviewable): array
    {
        $cacheKey = 'rating:distribution:'.get_class($reviewable).':'.$reviewable->id;
        
        return $this->cacheService->remember($cacheKey, now()->addHours(1), function () use ($reviewable) {
            $distribution = Review::where('reviewable_type', get_class($reviewable))
                ->where('reviewable_id', $reviewable->id)
                ->where('status', 'approved')
                ->selectRaw('rating, COUNT(*) as count')
                ->groupBy('rating')
                ->orderBy('rating', 'desc')
                ->pluck('count', 'rating')
                ->toArray();

            // Ensure all ratings 1-5 are present
            $result = [];
            for ($i = 5; $i >= 1; $i--) {
                $result[$i] = $distribution[$i] ?? 0;
            }

            return $result;
        });
    }

    /**
     * Get review count for a model
     */
    public function getReviewCount(Model $reviewable, bool $approvedOnly = true): int
    {
        $cacheKey = 'reviews:count:'.get_class($reviewable).':'.$reviewable->id.':'.($approvedOnly ? 'approved' : 'all');
        
        return (int) $this->cacheService->remember($cacheKey, now()->addHours(1), function () use ($reviewable, $approvedOnly) {
            $query = Review::where('reviewable_type', get_class($reviewable))
                ->where('reviewable_id', $reviewable->id);

            if ($approvedOnly) {
                $query->where('status', 'approved');
            }

            return $query->count();
        });
    }

    /**
     * Mark review as helpful
     */
    public function markAsHelpful(Review $review, int $userId): Review
    {
        // Check if user already marked as helpful (would need a pivot table in production)
        $review->increment('helpful_count');
        $review->increment('helpful_votes');

        // Clear cache
        $this->clearReviewCache($review->reviewable);

        return $review->fresh();
    }

    /**
     * Feature a review
     */
    public function feature(Review $review): Review
    {
        $review->update(['is_featured' => true]);

        // Clear cache
        $this->clearReviewCache($review->reviewable);

        return $review->fresh();
    }

    /**
     * Unfeature a review
     */
    public function unfeature(Review $review): Review
    {
        $review->update(['is_featured' => false]);

        // Clear cache
        $this->clearReviewCache($review->reviewable);

        return $review->fresh();
    }

    /**
     * Create a rating
     */
    private function createRating(Model $ratable, int $userId, float $rating, ?string $context = null): Rating
    {
        return Rating::updateOrCreate(
            [
                'ratable_type' => get_class($ratable),
                'ratable_id' => $ratable->id,
                'user_id' => $userId,
            ],
            [
                'rating' => $rating,
                'context' => $context,
            ]
        );
    }

    /**
     * Update reviewable's rating cache
     */
    private function updateReviewableRating(Model $reviewable): void
    {
        if (method_exists($reviewable, 'updateRating')) {
            $averageRating = $this->getAverageRating($reviewable);
            $reviewCount = $this->getReviewCount($reviewable);

            $reviewable->updateRating($averageRating, $reviewCount);
        } elseif (property_exists($reviewable, 'rating') || $reviewable->getFillable() && in_array('rating', $reviewable->getFillable())) {
            $averageRating = $this->getAverageRating($reviewable);
            $reviewCount = $this->getReviewCount($reviewable);

            $reviewable->update([
                'rating' => $averageRating,
                'reviews_count' => $reviewCount,
            ]);
        }
    }

    /**
     * Clear review-related cache
     */
    private function clearReviewCache(Model $reviewable): void
    {
        $this->cacheService->forget('reviews:'.get_class($reviewable).':'.$reviewable->id.':*');
        $this->cacheService->forget('rating:avg:'.get_class($reviewable).':'.$reviewable->id);
        $this->cacheService->forget('rating:distribution:'.get_class($reviewable).':'.$reviewable->id);
        $this->cacheService->forget('reviews:count:'.get_class($reviewable).':'.$reviewable->id.':*');
    }
}

```

### SearchService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\Business;
use App\Models\DayNewsPost;
use App\Models\Event;
use App\Models\Coupon;
use App\Models\Tag;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\DB;

final class SearchService
{
    public function __construct(
        private readonly CacheService $cacheService
    ) {}

    /**
     * Unified search across all content types
     */
    public function search(
        string $query,
        array $filters = [],
        int $limit = 20
    ): array {
        $cacheKey = 'search:'.md5(serialize([$query, $filters, $limit]));
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(5), function () use ($query, $filters, $limit) {
            $results = [
                'articles' => [],
                'events' => [],
                'businesses' => [],
                'coupons' => [],
                'tags' => [],
            ];

            $contentTypes = $filters['types'] ?? ['articles', 'events', 'businesses', 'coupons', 'tags'];
            $perTypeLimit = (int) ceil($limit / count($contentTypes));

            // Search articles
            if (in_array('articles', $contentTypes)) {
                $results['articles'] = $this->searchArticles($query, $filters, $perTypeLimit);
            }

            // Search events
            if (in_array('events', $contentTypes)) {
                $results['events'] = $this->searchEvents($query, $filters, $perTypeLimit);
            }

            // Search businesses
            if (in_array('businesses', $contentTypes)) {
                $results['businesses'] = $this->searchBusinesses($query, $filters, $perTypeLimit);
            }

            // Search coupons
            if (in_array('coupons', $contentTypes)) {
                $results['coupons'] = $this->searchCoupons($query, $filters, $perTypeLimit);
            }

            // Search tags
            if (in_array('tags', $contentTypes)) {
                $results['tags'] = $this->searchTags($query, $filters, $perTypeLimit);
            }

            // Record search
            $this->recordSearch($query, $filters);

            return $results;
        });
    }

    /**
     * Search articles
     */
    private function searchArticles(string $query, array $filters, int $limit): Collection
    {
        $searchQuery = DayNewsPost::published()
            ->where(function ($q) use ($query) {
                $q->where('title', 'like', "%{$query}%")
                  ->orWhere('content', 'like', "%{$query}%")
                  ->orWhere('excerpt', 'like', "%{$query}%");
            });

        // Apply filters
        if (isset($filters['category'])) {
            $searchQuery->where('category', $filters['category']);
        }

        if (isset($filters['region_id'])) {
            $searchQuery->whereHas('regions', function ($q) use ($filters) {
                $q->where('regions.id', $filters['region_id']);
            });
        }

        if (isset($filters['author_id'])) {
            $searchQuery->where('author_id', $filters['author_id']);
        }

        // Apply time filter
        if (isset($filters['time_period'])) {
            $this->applyTimeFilter($searchQuery, $filters['time_period'], 'published_at');
        }

        // Apply sorting
        $this->applySorting($searchQuery, $filters['sort_by'] ?? 'published_at', $filters['sort_order'] ?? 'desc');

        return $searchQuery->with(['author', 'regions'])
            ->limit($limit)
            ->get();
    }

    /**
     * Search events
     */
    private function searchEvents(string $query, array $filters, int $limit): Collection
    {
        $searchQuery = Event::published()
            ->upcoming()
            ->where(function ($q) use ($query) {
                $q->where('title', 'like', "%{$query}%")
                  ->orWhere('description', 'like', "%{$query}%");
            });

        // Apply filters
        if (isset($filters['category'])) {
            $searchQuery->where('category', $filters['category']);
        }

        if (isset($filters['region_id'])) {
            $searchQuery->whereHas('regions', function ($q) use ($filters) {
                $q->where('regions.id', $filters['region_id']);
            });
        }

        if (isset($filters['venue_id'])) {
            $searchQuery->where('venue_id', $filters['venue_id']);
        }

        if (isset($filters['performer_id'])) {
            $searchQuery->where('performer_id', $filters['performer_id']);
        }

        if (isset($filters['is_free'])) {
            $searchQuery->where('is_free', $filters['is_free']);
        }

        // Apply time filter
        if (isset($filters['time_period'])) {
            $this->applyTimeFilter($searchQuery, $filters['time_period'], 'event_date');
        }

        // Apply sorting
        $this->applySorting($searchQuery, $filters['sort_by'] ?? 'event_date', $filters['sort_order'] ?? 'asc');

        return $searchQuery->with(['venue', 'performer', 'regions'])
            ->limit($limit)
            ->get();
    }

    /**
     * Search businesses
     */
    private function searchBusinesses(string $query, array $filters, int $limit): Collection
    {
        $searchQuery = Business::active()
            ->where(function ($q) use ($query) {
                $q->where('name', 'like', "%{$query}%")
                  ->orWhere('description', 'like', "%{$query}%")
                  ->orWhere('address', 'like', "%{$query}%")
                  ->orWhere('city', 'like', "%{$query}%");
            });

        // Apply filters
        if (isset($filters['region_id'])) {
            $searchQuery->whereHas('regions', function ($q) use ($filters) {
                $q->where('regions.id', $filters['region_id']);
            });
        }

        if (isset($filters['category'])) {
            $searchQuery->byCategory($filters['category']);
        }

        if (isset($filters['is_verified'])) {
            $searchQuery->where('is_verified', $filters['is_verified']);
        }

        if (isset($filters['is_organization'])) {
            $searchQuery->where('is_organization', $filters['is_organization']);
        }

        // Location filter
        if (isset($filters['latitude'], $filters['longitude'], $filters['radius'])) {
            $searchQuery->withinRadius(
                (float) $filters['latitude'],
                (float) $filters['longitude'],
                (float) $filters['radius']
            );
        }

        // Apply sorting
        $sortBy = $filters['sort_by'] ?? 'name';
        $sortOrder = $filters['sort_order'] ?? 'asc';
        
        if ($sortBy === 'rating') {
            $searchQuery->orderBy('rating', $sortOrder);
        } elseif ($sortBy === 'distance' && isset($filters['latitude'], $filters['longitude'])) {
            $searchQuery->orderBy('distance', $sortOrder);
        } else {
            $searchQuery->orderBy($sortBy, $sortOrder);
        }

        return $searchQuery->with(['regions'])
            ->limit($limit)
            ->get();
    }

    /**
     * Search coupons
     */
    private function searchCoupons(string $query, array $filters, int $limit): Collection
    {
        $searchQuery = Coupon::where('status', 'active')
            ->where(function ($q) use ($query) {
                $q->where('title', 'like', "%{$query}%")
                  ->orWhere('description', 'like', "%{$query}%")
                  ->orWhere('code', 'like', "%{$query}%");
            })
            ->where(function ($q) {
                $q->whereNull('start_date')
                  ->orWhere('start_date', '<=', now());
            })
            ->where(function ($q) {
                $q->whereNull('end_date')
                  ->orWhere('end_date', '>=', now());
            });

        // Apply filters
        if (isset($filters['business_id'])) {
            $searchQuery->where('business_id', $filters['business_id']);
        }

        if (isset($filters['region_id'])) {
            $searchQuery->whereHas('regions', function ($q) use ($filters) {
                $q->where('regions.id', $filters['region_id']);
            });
        }

        // Apply sorting
        $this->applySorting($searchQuery, $filters['sort_by'] ?? 'created_at', $filters['sort_order'] ?? 'desc');

        return $searchQuery->with(['business', 'regions'])
            ->limit($limit)
            ->get();
    }

    /**
     * Search tags
     */
    private function searchTags(string $query, array $filters, int $limit): Collection
    {
        $searchQuery = Tag::where('name', 'like', "%{$query}%");

        // Apply sorting
        $this->applySorting($searchQuery, $filters['sort_by'] ?? 'name', $filters['sort_order'] ?? 'asc');

        return $searchQuery->limit($limit)->get();
    }

    /**
     * Get search suggestions
     */
    public function getSuggestions(string $query, int $limit = 10): array
    {
        $cacheKey = 'search:suggestions:'.md5($query).':limit:'.$limit;
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(10), function () use ($query, $limit) {
            $suggestions = [];

            // Article titles
            $articles = DayNewsPost::published()
                ->where('title', 'like', "%{$query}%")
                ->limit(3)
                ->pluck('title')
                ->toArray();
            $suggestions = array_merge($suggestions, $articles);

            // Event titles
            $events = Event::published()
                ->upcoming()
                ->where('title', 'like', "%{$query}%")
                ->limit(3)
                ->pluck('title')
                ->toArray();
            $suggestions = array_merge($suggestions, $events);

            // Business names
            $businesses = Business::active()
                ->where('name', 'like', "%{$query}%")
                ->limit(3)
                ->pluck('name')
                ->toArray();
            $suggestions = array_merge($suggestions, $businesses);

            // Tags
            $tags = Tag::where('name', 'like', "%{$query}%")
                ->limit(3)
                ->pluck('name')
                ->toArray();
            $suggestions = array_merge($suggestions, $tags);

            return array_unique(array_slice($suggestions, 0, $limit));
        });
    }

    /**
     * Get trending searches
     */
    public function getTrendingSearches(int $limit = 10, string $timePeriod = '24h'): array
    {
        $cacheKey = "search:trending:{$timePeriod}:limit:{$limit}";
        
        return $this->cacheService->remember($cacheKey, now()->addMinutes(5), function () use ($limit, $timePeriod) {
            // This would typically query a search_history table
            // For now, return empty array - implement when search_history table exists
            return [];
        });
    }

    /**
     * Record a search query
     */
    public function recordSearch(string $query, array $filters = []): void
    {
        // This would typically insert into a search_history table
        // For now, just log it
        \Log::info('Search performed', [
            'query' => $query,
            'filters' => $filters,
            'ip' => request()->ip(),
            'user_id' => auth()->id(),
        ]);
    }

    /**
     * Apply time filter to query
     */
    private function applyTimeFilter($query, string $timePeriod, string $dateColumn): void
    {
        match ($timePeriod) {
            'today' => $query->whereDate($dateColumn, today()),
            'week' => $query->whereBetween($dateColumn, [now()->startOfWeek(), now()->endOfWeek()]),
            'month' => $query->whereBetween($dateColumn, [now()->startOfMonth(), now()->endOfMonth()]),
            'year' => $query->whereBetween($dateColumn, [now()->startOfYear(), now()->endOfYear()]),
            default => null,
        };
    }

    /**
     * Apply sorting to query
     */
    private function applySorting($query, string $sortBy, string $sortOrder): void
    {
        $query->orderBy($sortBy, $sortOrder);
    }
}

```

### SeoService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

final class SeoService
{
    /**
     * Get site configuration based on domain.
     */
    public static function getSiteConfig(string $site): array
    {
        $configs = [
            'day-news' => [
                'name' => 'Day News',
                'defaultImage' => '/images/day-news-logo.png',
            ],
            'event-city' => [
                'name' => 'Go Event City',
                'defaultImage' => '/images/event-city-logo.png',
            ],
            'downtown-guide' => [
                'name' => 'Downtown Guide',
                'defaultImage' => '/images/downtown-guide-logo.png',
            ],
        ];

        return $configs[$site] ?? $configs['event-city'];
    }

    /**
     * Build canonical URL.
     */
    public static function buildCanonicalUrl(string $path): string
    {
        $baseUrl = mb_rtrim(config('app.url'), '/');

        return $baseUrl.'/'.mb_ltrim($path, '/');
    }

    /**
     * Get image URL with fallback to site default.
     */
    public static function getImageUrl(?string $image, string $site): string
    {
        if ($image) {
            if (str_starts_with($image, 'http')) {
                return $image;
            }

            return self::buildCanonicalUrl($image);
        }

        $config = self::getSiteConfig($site);

        return self::buildCanonicalUrl($config['defaultImage']);
    }

    /**
     * Build NewsArticle JSON-LD schema.
     */
    public static function buildArticleSchema(array $data, string $site): array
    {
        $config = self::getSiteConfig($site);
        $canonicalUrl = self::buildCanonicalUrl($data['url'] ?? '/');
        $imageUrl = self::getImageUrl($data['image'] ?? null, $site);

        $schema = [
            '@context' => 'https://schema.org',
            '@type' => 'NewsArticle',
            'headline' => $data['title'],
            'description' => $data['description'] ?? '',
            'image' => $imageUrl,
            'url' => $canonicalUrl,
            'datePublished' => $data['publishedAt'] ?? null,
            'dateModified' => $data['modifiedAt'] ?? $data['publishedAt'] ?? null,
            'publisher' => [
                '@type' => 'Organization',
                'name' => $config['name'],
                'logo' => [
                    '@type' => 'ImageObject',
                    'url' => self::buildCanonicalUrl($config['defaultImage']),
                ],
            ],
            'mainEntityOfPage' => [
                '@type' => 'WebPage',
                '@id' => $canonicalUrl,
            ],
        ];

        if (! empty($data['articleBody'])) {
            $schema['articleBody'] = $data['articleBody'];
        }

        if (! empty($data['section'])) {
            $schema['articleSection'] = $data['section'];
        }

        if (! empty($data['author'])) {
            $schema['author'] = [
                '@type' => 'Person',
                'name' => $data['author'],
            ];
        }

        return $schema;
    }

    /**
     * Build Event JSON-LD schema.
     */
    public static function buildEventSchema(array $data, string $site): array
    {
        $config = self::getSiteConfig($site);
        $canonicalUrl = self::buildCanonicalUrl($data['url'] ?? '/');
        $imageUrl = self::getImageUrl($data['image'] ?? null, $site);

        $schema = [
            '@context' => 'https://schema.org',
            '@type' => 'Event',
            'name' => $data['title'],
            'description' => $data['description'] ?? '',
            'image' => $imageUrl,
            'url' => $canonicalUrl,
            'startDate' => $data['startDate'],
            'endDate' => $data['endDate'] ?? $data['startDate'],
            'offers' => [
                '@type' => 'Offer',
                'url' => $canonicalUrl,
                'price' => ($data['isFree'] ?? false) ? '0' : (string) ($data['price'] ?? '0'),
                'priceCurrency' => $data['priceCurrency'] ?? 'USD',
                'availability' => 'https://schema.org/'.($data['availability'] ?? 'InStock'),
            ],
            'organizer' => [
                '@type' => 'Organization',
                'name' => $config['name'],
            ],
        ];

        if (! empty($data['location'])) {
            $location = [
                '@type' => 'Place',
                'name' => $data['location']['name'] ?? '',
            ];

            if (! empty($data['location']['address'])) {
                $location['address'] = [
                    '@type' => 'PostalAddress',
                    'streetAddress' => $data['location']['address'],
                ];
            }

            if (! empty($data['location']['latitude']) && ! empty($data['location']['longitude'])) {
                $location['geo'] = [
                    '@type' => 'GeoCoordinates',
                    'latitude' => $data['location']['latitude'],
                    'longitude' => $data['location']['longitude'],
                ];
            }

            $schema['location'] = $location;
        }

        if (! empty($data['performer'])) {
            $schema['performer'] = [
                '@type' => 'Person',
                'name' => $data['performer'],
            ];
        }

        if (! empty($data['category'])) {
            $schema['eventCategory'] = $data['category'];
        }

        return $schema;
    }

    /**
     * Build Place JSON-LD schema for venues.
     */
    public static function buildVenueSchema(array $data, string $site): array
    {
        $canonicalUrl = self::buildCanonicalUrl($data['url'] ?? '/');
        $imageUrl = self::getImageUrl($data['image'] ?? null, $site);

        $schema = [
            '@context' => 'https://schema.org',
            '@type' => 'Place',
            'name' => $data['name'],
            'description' => $data['description'] ?? '',
            'image' => $imageUrl,
            'url' => $canonicalUrl,
        ];

        if (! empty($data['address'])) {
            $address = [
                '@type' => 'PostalAddress',
                'streetAddress' => $data['address'],
            ];

            if (! empty($data['neighborhood'])) {
                $address['addressLocality'] = $data['neighborhood'];
            }

            $schema['address'] = $address;
        }

        if (! empty($data['latitude']) && ! empty($data['longitude'])) {
            $schema['geo'] = [
                '@type' => 'GeoCoordinates',
                'latitude' => $data['latitude'],
                'longitude' => $data['longitude'],
            ];
        }

        if (! empty($data['capacity'])) {
            $schema['maximumAttendeeCapacity'] = $data['capacity'];
        }

        if (! empty($data['rating']) && ! empty($data['reviewCount'])) {
            $schema['aggregateRating'] = [
                '@type' => 'AggregateRating',
                'ratingValue' => $data['rating'],
                'reviewCount' => $data['reviewCount'],
            ];
        }

        return $schema;
    }

    /**
     * Build Person JSON-LD schema for performers.
     */
    public static function buildPerformerSchema(array $data, string $site): array
    {
        $canonicalUrl = self::buildCanonicalUrl($data['url'] ?? '/');
        $imageUrl = self::getImageUrl($data['image'] ?? null, $site);

        $schema = [
            '@context' => 'https://schema.org',
            '@type' => 'Person',
            'name' => $data['name'],
            'description' => $data['bio'] ?? $data['description'] ?? '',
            'image' => $imageUrl,
            'url' => $canonicalUrl,
        ];

        if (! empty($data['homeCity'])) {
            $schema['homeLocation'] = [
                '@type' => 'Place',
                'name' => $data['homeCity'],
            ];
        }

        if (! empty($data['genres']) && is_array($data['genres'])) {
            $schema['knowsAbout'] = $data['genres'];
        }

        return $schema;
    }

    /**
     * Build LocalBusiness JSON-LD schema.
     */
    public static function buildBusinessSchema(array $data, string $site): array
    {
        $canonicalUrl = self::buildCanonicalUrl($data['url'] ?? '/');
        $imageUrl = self::getImageUrl($data['image'] ?? null, $site);

        $schema = [
            '@context' => 'https://schema.org',
            '@type' => 'LocalBusiness',
            'name' => $data['name'],
            'description' => $data['description'] ?? '',
            'image' => $imageUrl,
            'url' => $canonicalUrl,
        ];

        if (! empty($data['address'])) {
            $address = [
                '@type' => 'PostalAddress',
                'streetAddress' => $data['address'],
            ];

            if (! empty($data['city'])) {
                $address['addressLocality'] = $data['city'];
            }
            if (! empty($data['state'])) {
                $address['addressRegion'] = $data['state'];
            }
            if (! empty($data['postalCode'])) {
                $address['postalCode'] = $data['postalCode'];
            }
            if (! empty($data['country'])) {
                $address['addressCountry'] = $data['country'];
            }

            $schema['address'] = $address;
        }

        if (! empty($data['latitude']) && ! empty($data['longitude'])) {
            $schema['geo'] = [
                '@type' => 'GeoCoordinates',
                'latitude' => $data['latitude'],
                'longitude' => $data['longitude'],
            ];
        }

        if (! empty($data['phone'])) {
            $schema['telephone'] = $data['phone'];
        }

        if (! empty($data['website'])) {
            $schema['sameAs'] = [$data['website']];
        }

        if (! empty($data['rating']) && ! empty($data['reviewCount'])) {
            $schema['aggregateRating'] = [
                '@type' => 'AggregateRating',
                'ratingValue' => $data['rating'],
                'reviewCount' => $data['reviewCount'],
            ];
        }

        return $schema;
    }

    /**
     * Build WebSite JSON-LD schema for homepages.
     */
    public static function buildWebsiteSchema(array $data, string $site): array
    {
        $config = self::getSiteConfig($site);
        $canonicalUrl = self::buildCanonicalUrl($data['url'] ?? '/');

        return [
            '@context' => 'https://schema.org',
            '@type' => 'WebSite',
            'name' => $data['siteName'] ?? $config['name'],
            'description' => $data['description'] ?? '',
            'url' => $canonicalUrl,
            'publisher' => [
                '@type' => 'Organization',
                'name' => $config['name'],
                'logo' => [
                    '@type' => 'ImageObject',
                    'url' => self::buildCanonicalUrl($config['defaultImage']),
                ],
            ],
        ];
    }

    /**
     * Build JSON-LD schema based on content type.
     */
    public static function buildJsonLd(string $type, array $data, string $site): array
    {
        return match ($type) {
            'article' => self::buildArticleSchema($data, $site),
            'event' => self::buildEventSchema($data, $site),
            'venue' => self::buildVenueSchema($data, $site),
            'performer' => self::buildPerformerSchema($data, $site),
            'business' => self::buildBusinessSchema($data, $site),
            'website' => self::buildWebsiteSchema($data, $site),
            default => [],
        };
    }

    /**
     * Generate SEO metadata for a business (for AlphaSite)
     */
    public static function generateBusinessSeo(\App\Models\Business $business): array
    {
        $url = $business->alphasite_subdomain 
            ? "https://{$business->alphasite_subdomain}.alphasite.com"
            : "https://alphasite.com/business/{$business->slug}";

        return [
            'title' => "{$business->name} - {$business->industry?->name} in {$business->city}, {$business->state} | AlphaSite",
            'description' => $business->description ?? "{$business->name} located in {$business->city}, {$business->state}. " . 
                ($business->industry ? "Find {$business->industry->name} services near you." : "Local business directory."),
            'canonical' => $url,
            'image' => $business->images[0] ?? null,
        ];
    }
}
```

### SmsService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\EmergencyAlert;
use Aws\Sns\SnsClient;
use Aws\Exception\AwsException;
use Illuminate\Support\Facades\Log;

final class SmsService
{
    private SnsClient $sns;

    public function __construct()
    {
        $this->sns = new SnsClient([
            'version' => 'latest',
            'region' => config('services.sns.region', config('services.ses.region', 'us-east-1')),
            'credentials' => [
                'key' => config('services.sns.key', config('services.ses.key')),
                'secret' => config('services.sns.secret', config('services.ses.secret')),
            ],
        ]);
    }

    /**
     * Send emergency alert SMS
     */
    public function sendEmergencyAlert(string $phoneNumber, EmergencyAlert $alert): string
    {
        $message = $this->formatEmergencyMessage($alert);

        try {
            $result = $this->sns->publish([
                'PhoneNumber' => $phoneNumber,
                'Message' => $message,
                'MessageAttributes' => [
                    'AWS.SNS.SMS.SMSType' => [
                        'DataType' => 'String',
                        'StringValue' => config('services.sns.sms_type', 'Transactional'),
                    ],
                ],
            ]);

            return $result->get('MessageId');
        } catch (AwsException $e) {
            Log::error('SMS send failed', [
                'phone' => $phoneNumber,
                'alert_id' => $alert->id,
                'error' => $e->getMessage(),
            ]);

            throw $e;
        }
    }

    /**
     * Send verification code
     */
    public function sendVerificationCode(string $phoneNumber, string $code): string
    {
        $message = "Your verification code is: {$code}";

        try {
            $result = $this->sns->publish([
                'PhoneNumber' => $phoneNumber,
                'Message' => $message,
                'MessageAttributes' => [
                    'AWS.SNS.SMS.SMSType' => [
                        'DataType' => 'String',
                        'StringValue' => config('services.sns.sms_type', 'Transactional'),
                    ],
                ],
            ]);

            return $result->get('MessageId');
        } catch (AwsException $e) {
            Log::error('SMS verification code send failed', [
                'phone' => $phoneNumber,
                'error' => $e->getMessage(),
            ]);

            throw $e;
        }
    }

    /**
     * Format emergency message for SMS (160 char limit)
     */
    protected function formatEmergencyMessage(EmergencyAlert $alert): string
    {
        $priority = strtoupper($alert->priority);
        $title = substr($alert->title, 0, 50);
        $message = substr($alert->message, 0, 80);
        $url = $alert->source_url ? ' More: ' . substr($alert->source_url, 0, 20) : '';

        return "[{$priority}] {$title}: {$message}{$url}";
    }
}

```

### SocialFeedAlgorithmService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\SocialPost;
use App\Models\User;
use Carbon\Carbon;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Pagination\LengthAwarePaginator;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\DB;

final class SocialFeedAlgorithmService
{
    private const LIKE_WEIGHT = 1.0;

    private const COMMENT_WEIGHT = 2.0;

    private const RECENT_ENGAGEMENT_HOURS = 12; // Boost for recent engagement

    private const POST_AGE_DECAY_HOURS = 48; // How quickly post score decays

    private const NEW_POST_BOOST_HOURS = 6; // Give new posts a boost for their first 6 hours

    private const NEW_POST_BOOST_SCORE = 10; // Base score boost for new posts

    public function getForYouFeed(User $user, int $page = 1, int $perPage = 20): LengthAwarePaginator
    {
        $posts = $this->buildForYouQuery($user)
            ->with(['user.socialProfile', 'likes.user', 'comments.user'])
            ->get()
            ->map(function ($post) use ($user) {
                return $this->enrichPostData($post, $user);
            });

        if ($posts->isEmpty()) {
            return $this->getFallbackFeed($user, $page, $perPage);
        }

        $rankedPosts = $this->scorePostsWithUserBoost($posts, $user);

        return $this->paginateResults($rankedPosts, $page, $perPage);
    }

    public function getFollowedFeed(User $user, int $page = 1, int $perPage = 20): LengthAwarePaginator
    {
        $friendIds = $user->acceptedFriends()->pluck('friend_id')
            ->merge($user->friendshipRequests()->where('status', 'accepted')->pluck('user_id'))
            ->unique();

        // Include user's own posts alongside friends' posts
        $userIds = $friendIds->push($user->id);

        $posts = SocialPost::whereIn('user_id', $userIds)
            ->where('is_active', true)
            ->where('created_at', '>=', now()->subDays(7))
            ->where(function ($query) use ($user) {
                $query->where('visibility', 'public')
                    ->orWhere('visibility', 'friends')
                    ->orWhere('user_id', $user->id); // Always show user's own posts
            })
            ->with(['user.socialProfile', 'likes.user', 'comments.user'])
            ->get()
            ->map(function ($post) use ($user) {
                return $this->enrichPostData($post, $user);
            });

        if ($posts->isEmpty()) {
            return $this->getEmptyFeed($page, $perPage);
        }

        $rankedPosts = $this->scorePostsWithUserBoost($posts, $user);

        return $this->paginateResults($rankedPosts, $page, $perPage);
    }

    public function getFallbackFeed(User $user, int $page = 1, int $perPage = 20): LengthAwarePaginator
    {
        $posts = SocialPost::query()
            ->where('is_active', true)
            ->where('visibility', 'public')
            ->where('user_id', '!=', $user->id)
            ->where('created_at', '>=', now()->subDays(7))
            ->where(function ($profileQuery) {
                $profileQuery->whereDoesntHave('user.socialProfile')
                    ->orWhereHas('user.socialProfile', function ($socialProfileQuery) {
                        $socialProfileQuery->where('profile_visibility', '!=', 'private');
                    });
            })
            ->with(['user.socialProfile', 'likes.user', 'comments.user'])
            ->get()
            ->map(function ($post) use ($user) {
                return $this->enrichPostData($post, $user);
            });

        $rankedPosts = $this->scorePostsSimply($posts);

        return $this->paginateResults($rankedPosts, $page, $perPage);
    }

    private function scorePostsSimply(Collection $posts): Collection
    {
        return $posts->map(function ($post) {
            $postModel = is_array($post) ? SocialPost::find($post['id']) : $post;
            $score = $this->calculateSimpleScore($postModel);

            if (is_array($post)) {
                $post['algorithm_score'] = $score;

                return $post;
            }
            $postArray = $post->toArray();
            $postArray['algorithm_score'] = $score;

            return $postArray;

        })->sortByDesc('algorithm_score')->values();
    }

    private function scorePostsWithUserBoost(Collection $posts, User $user): Collection
    {
        return $posts->map(function ($post) use ($user) {
            $postModel = is_array($post) ? SocialPost::find($post['id']) : $post;
            $score = $this->calculateSimpleScore($postModel);

            // Give user's own posts a boost to prioritize them
            if ($postModel->user_id === $user->id) {
                $score *= 1.5; // 50% boost for user's own posts
            }

            if (is_array($post)) {
                $post['algorithm_score'] = $score;

                return $post;
            }
            $postArray = $post->toArray();
            $postArray['algorithm_score'] = $score;

            return $postArray;

        })->sortByDesc('algorithm_score')->values();
    }

    private function calculateSimpleScore(SocialPost $post): float
    {
        $now = now();
        $postAge = $post->created_at->diffInHours($now);

        // Get like and comment counts with timestamps
        $likes = DB::table('social_post_likes')
            ->where('post_id', $post->id)
            ->select('created_at')
            ->get();

        $comments = DB::table('social_post_comments')
            ->where('post_id', $post->id)
            ->where('is_active', true)
            ->select('created_at')
            ->get();

        // Calculate engagement score with time-based weighting
        $engagementScore = 0;

        // Score likes - more recent likes get higher weight
        foreach ($likes as $like) {
            $likeAge = $now->diffInHours(Carbon::parse($like->created_at));
            $timeWeight = $likeAge <= self::RECENT_ENGAGEMENT_HOURS ? 2.0 : 1.0;
            $engagementScore += self::LIKE_WEIGHT * $timeWeight;
        }

        // Score comments - they get higher base weight and time bonus
        foreach ($comments as $comment) {
            $commentAge = $now->diffInHours(Carbon::parse($comment->created_at));
            $timeWeight = $commentAge <= self::RECENT_ENGAGEMENT_HOURS ? 2.0 : 1.0;
            $engagementScore += self::COMMENT_WEIGHT * $timeWeight;
        }

        // Apply post age decay - newer posts get a boost
        $ageDecay = max(0.1, 1 - ($postAge / self::POST_AGE_DECAY_HOURS));

        // Give new posts a boost to prevent them getting lost without engagement
        $newPostBoost = $postAge <= self::NEW_POST_BOOST_HOURS
            ? self::NEW_POST_BOOST_SCORE * (1 - ($postAge / self::NEW_POST_BOOST_HOURS))
            : 0;

        $finalScore = ($engagementScore * $ageDecay) + $newPostBoost;

        return $finalScore;
    }

    private function buildForYouQuery(User $user): Builder
    {
        $friendIds = $user->acceptedFriends()->pluck('friend_id')
            ->merge($user->friendshipRequests()->where('status', 'accepted')->pluck('user_id'))
            ->unique();

        return SocialPost::query()
            ->where('is_active', true)
            ->where('created_at', '>=', now()->subDays(7))
            ->where(function ($query) use ($friendIds, $user) {
                // Show user's own posts
                $query->where('user_id', $user->id)
                    // Show public posts from non-private profiles
                    ->orWhere(function ($publicQuery) use ($user) {
                        $publicQuery->where('visibility', 'public')
                            ->where('user_id', '!=', $user->id)
                            ->where(function ($profileQuery) {
                                $profileQuery->whereDoesntHave('user.socialProfile')
                                    ->orWhereHas('user.socialProfile', function ($socialProfileQuery) {
                                        $socialProfileQuery->where('profile_visibility', '!=', 'private');
                                    });
                            });
                    })
                    // Show friends-only posts from actual friends
                    ->orWhere(function ($friendsQuery) use ($friendIds) {
                        $friendsQuery->where('visibility', 'friends')
                            ->whereIn('user_id', $friendIds);
                    });
            });
    }

    private function paginateResults(Collection $posts, int $page, int $perPage): LengthAwarePaginator
    {
        $total = $posts->count();
        $items = $posts->forPage($page, $perPage)->values();

        return new LengthAwarePaginator(
            $items,
            $total,
            $perPage,
            $page,
            [
                'path' => request()->url(),
                'pageName' => 'page',
            ]
        );
    }

    private function getEmptyFeed(int $page, int $perPage): LengthAwarePaginator
    {
        return new LengthAwarePaginator(
            collect([]),
            0,
            $perPage,
            $page,
            [
                'path' => request()->url(),
                'pageName' => 'page',
            ]
        );
    }

    private function enrichPostData(SocialPost $post, User $user): array
    {
        return array_merge($post->toArray(), [
            'likes_count' => $post->likesCount(),
            'comments_count' => $post->commentsCount(),
            'shares_count' => $post->sharesCount(),
            'is_liked_by_user' => $post->isLikedBy($user),
            'recent_comments' => $post->comments()->with('user')->latest()->limit(3)->get()->toArray(),
        ]);
    }
}
```

### StripeConnectService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\Workspace;
use Exception;
use Log;
use Stripe\Account;
use Stripe\AccountLink;
use Stripe\Checkout\Session;
use Stripe\PaymentIntent;
use Stripe\Stripe;
use Stripe\StripeClient;

/**
 * Note: This class is not final to allow mocking in tests
 *
 * @phpstan-ignore-next-line
 */
class StripeConnectService
{
    private StripeClient $stripe;

    public function __construct()
    {
        $secret = config('services.stripe.secret');
        
        if (empty($secret)) {
            throw new \RuntimeException(
                'Stripe API secret not configured. Please set STRIPE_SECRET in your .env file. ' .
                'For testing, you can use a test key from https://dashboard.stripe.com/test/apikeys'
            );
        }
        
        Stripe::setApiKey($secret);
        $this->stripe = new StripeClient($secret);
    }

    /**
     * Create a Stripe Connect Express account for a workspace
     */
    public function createConnectAccount(Workspace $workspace): Account
    {
        $appUrl = config('app.url');

        // Only include business URL if it's not a localhost URL (Stripe rejects localhost)
        $businessProfile = ['name' => $workspace->name];
        if (! str_contains($appUrl, 'localhost') && ! str_contains($appUrl, '127.0.0.1')) {
            $businessProfile['url'] = $appUrl;
        }

        Log::info('StripeConnectService: Creating account', [
            'workspace_id' => $workspace->id,
            'email' => $workspace->owner->email,
            'name' => $workspace->name,
            'includes_url' => isset($businessProfile['url']),
        ]);

        $account = $this->stripe->accounts->create([
            'type' => 'express',
            'country' => 'US',
            'email' => $workspace->owner->email,
            'capabilities' => [
                'card_payments' => ['requested' => true],
                'transfers' => ['requested' => true],
            ],
            'business_type' => 'individual',
            'business_profile' => $businessProfile,
        ]);

        Log::info('StripeConnectService: Account created successfully', [
            'workspace_id' => $workspace->id,
            'account_id' => $account->id,
        ]);

        $workspace->update(['stripe_connect_id' => $account->id]);

        return $account;
    }

    /**
     * Create an account link for onboarding
     */
    public function createAccountLink(Workspace $workspace, string $refreshUrl, string $returnUrl): AccountLink
    {
        if (! $workspace->stripe_connect_id) {
            throw new Exception('Workspace does not have a Stripe Connect account');
        }

        Log::info('StripeConnectService: Creating account link', [
            'workspace_id' => $workspace->id,
            'account_id' => $workspace->stripe_connect_id,
            'refresh_url' => $refreshUrl,
            'return_url' => $returnUrl,
        ]);

        $accountLink = $this->stripe->accountLinks->create([
            'account' => $workspace->stripe_connect_id,
            'refresh_url' => $refreshUrl,
            'return_url' => $returnUrl,
            'type' => 'account_onboarding',
        ]);

        Log::info('StripeConnectService: Account link created successfully', [
            'workspace_id' => $workspace->id,
            'url_length' => mb_strlen($accountLink->url),
            'expires_at' => $accountLink->expires_at,
        ]);

        return $accountLink;
    }

    /**
     * Get account details
     */
    public function getAccount(string $accountId): Account
    {
        return $this->stripe->accounts->retrieve($accountId);
    }

    /**
     * Update workspace's Stripe capabilities based on account status
     * Note: stripe_charges_enabled is now controlled by admin approval, not Stripe's status
     */
    public function updateWorkspaceCapabilities(Workspace $workspace): void
    {
        if (! $workspace->stripe_connect_id) {
            return;
        }

        $account = $this->getAccount($workspace->stripe_connect_id);

        // Only update payouts_enabled from Stripe
        // charges_enabled requires admin approval via stripe_admin_approved
        $workspace->update([
            'stripe_payouts_enabled' => $account->payouts_enabled ?? false,
        ]);

        // Set stripe_charges_enabled to match Stripe's status, but it won't enable payments
        // without admin approval (stripe_admin_approved)
        $workspace->update([
            'stripe_charges_enabled' => $account->charges_enabled ?? false,
        ]);
    }

    /**
     * Create a checkout session for a workspace's products/services
     */
    public function createCheckoutSession(Workspace $workspace, array $lineItems, string $successUrl, string $cancelUrl): Session
    {
        if (! $workspace->canAcceptPayments()) {
            throw new Exception('Workspace cannot accept payments');
        }

        return $this->stripe->checkout->sessions->create([
            'mode' => 'payment',
            'line_items' => $lineItems,
            'success_url' => $successUrl,
            'cancel_url' => $cancelUrl,
            'payment_intent_data' => [
                'application_fee_amount' => $this->calculatePlatformFee($lineItems),
                'transfer_data' => [
                    'destination' => $workspace->stripe_connect_id,
                ],
            ],
        ]);
    }

    /**
     * Create a payment intent for direct charges
     */
    public function createPaymentIntent(Workspace $workspace, int $amount, string $currency = 'usd', array $metadata = []): PaymentIntent
    {
        if (! $workspace->canAcceptPayments()) {
            throw new Exception('Workspace cannot accept payments');
        }

        $platformFee = (int) ($amount * 0.10); // 10% platform fee

        return $this->stripe->paymentIntents->create([
            'amount' => $amount,
            'currency' => $currency,
            'application_fee_amount' => $platformFee,
            'transfer_data' => [
                'destination' => $workspace->stripe_connect_id,
            ],
            'metadata' => $metadata,
        ]);
    }

    /**
     * Create a product in Stripe
     */
    public function createProduct(Workspace $workspace, string $name, ?string $description = null): \Stripe\Product
    {
        if (! $workspace->stripe_connect_id) {
            throw new Exception('Workspace does not have a Stripe Connect account');
        }

        return $this->stripe->products->create([
            'name' => $name,
            'description' => $description,
        ], [
            'stripe_account' => $workspace->stripe_connect_id,
        ]);
    }

    /**
     * Create a price for a product in Stripe
     */
    public function createPrice(Workspace $workspace, string $productId, int $unitAmount, string $currency = 'usd'): \Stripe\Price
    {
        if (! $workspace->stripe_connect_id) {
            throw new Exception('Workspace does not have a Stripe Connect account');
        }

        return $this->stripe->prices->create([
            'product' => $productId,
            'unit_amount' => $unitAmount,
            'currency' => $currency,
        ], [
            'stripe_account' => $workspace->stripe_connect_id,
        ]);
    }

    /**
     * Create a dashboard login link for the connected account
     */
    public function createDashboardLink(Workspace $workspace): string
    {
        if (! $workspace->stripe_connect_id) {
            throw new Exception('Workspace does not have a Stripe Connect account');
        }

        $loginLink = $this->stripe->accounts->createLoginLink($workspace->stripe_connect_id);

        return $loginLink->url;
    }

    /**
     * Create an onboarding session (account + account link)
     */
    public function createOnboardingSession(Workspace $workspace, string $refreshUrl, string $returnUrl): string
    {
        // Create account if it doesn't exist
        if (! $workspace->stripe_connect_id) {
            $this->createConnectAccount($workspace);
            $workspace->refresh();
        }

        // Create account link for onboarding
        $accountLink = $this->createAccountLink($workspace, $refreshUrl, $returnUrl);

        return $accountLink->url;
    }

    /**
     * Handle return from Stripe onboarding
     */
    public function handleOnboardingReturn(Workspace $workspace): void
    {
        // Update workspace capabilities based on current account status
        $this->updateWorkspaceCapabilities($workspace);
    }

    /**
     * Calculate platform fee (10% of total)
     */
    private function calculatePlatformFee(array $lineItems): int
    {
        $total = 0;
        foreach ($lineItems as $item) {
            $total += $item['price_data']['unit_amount'] * $item['quantity'];
        }

        return (int) ($total * 0.10);
    }
}
```

### TicketGiftService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\TicketOrderItem;
use App\Models\TicketGift;
use App\Models\User;
use Illuminate\Support\Str;

final class TicketGiftService
{
    public function createGift(TicketOrderItem $ticketOrderItem, User $gifter, string $recipientEmail, array $data = []): TicketGift
    {
        // Verify ownership
        if ($ticketOrderItem->ticketOrder->user_id !== $gifter->id) {
            throw new \Exception('You do not own this ticket.');
        }

        // Check for existing pending gift
        $existingGift = TicketGift::where('ticket_order_item_id', $ticketOrderItem->id)
            ->where('gifter_id', $gifter->id)
            ->pending()
            ->first();

        if ($existingGift) {
            throw new \Exception('You already have a pending gift for this ticket.');
        }

        // Check if recipient is a user
        $recipient = User::where('email', $recipientEmail)->first();

        return TicketGift::create([
            'ticket_order_item_id' => $ticketOrderItem->id,
            'gifter_id' => $gifter->id,
            'recipient_email' => $recipientEmail,
            'recipient_name' => $data['recipient_name'] ?? null,
            'recipient_user_id' => $recipient?->id,
            'status' => TicketGift::STATUS_PENDING,
            'gift_token' => Str::random(64),
            'message' => $data['message'] ?? null,
            'gifted_at' => now(),
            'expires_at' => $data['expires_at'] ?? now()->addDays(30),
        ]);
    }

    public function redeemGift(TicketGift $gift, User $recipient): bool
    {
        if ($gift->status !== TicketGift::STATUS_PENDING) {
            return false;
        }

        if ($gift->recipient_email !== $recipient->email) {
            return false;
        }

        $gift->redeem($recipient->id);

        return true;
    }

    public function cancelGift(TicketGift $gift): bool
    {
        if ($gift->status !== TicketGift::STATUS_PENDING) {
            return false;
        }

        $gift->update(['status' => TicketGift::STATUS_CANCELLED]);

        return true;
    }
}

```

### TicketMarketplaceService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\TicketListing;
use App\Models\TicketOrderItem;
use App\Models\User;
use Illuminate\Support\Facades\DB;

final class TicketMarketplaceService
{
    public function createListing(TicketOrderItem $ticketOrderItem, User $seller, array $data): TicketListing
    {
        // Verify ownership
        if ($ticketOrderItem->ticketOrder->user_id !== $seller->id) {
            throw new \Exception('You do not own this ticket.');
        }

        // Check for existing active listing
        $existingListing = TicketListing::where('ticket_order_item_id', $ticketOrderItem->id)
            ->where('seller_id', $seller->id)
            ->where('status', TicketListing::STATUS_ACTIVE)
            ->first();

        if ($existingListing) {
            throw new \Exception('You already have an active listing for this ticket.');
        }

        return TicketListing::create([
            'ticket_order_item_id' => $ticketOrderItem->id,
            'seller_id' => $seller->id,
            'event_id' => $ticketOrderItem->ticketOrder->event_id,
            'price' => $data['price'],
            'quantity' => $data['quantity'],
            'description' => $data['description'] ?? null,
            'expires_at' => $data['expires_at'] ?? null,
            'status' => TicketListing::STATUS_ACTIVE,
        ]);
    }

    public function purchaseListing(TicketListing $listing, User $buyer, int $quantity): \App\Models\TicketOrder
    {
        if ($listing->status !== TicketListing::STATUS_ACTIVE) {
            throw new \Exception('This listing is no longer available.');
        }

        if ($listing->seller_id === $buyer->id) {
            throw new \Exception('You cannot purchase your own listing.');
        }

        if ($quantity > $listing->quantity) {
            throw new \Exception('Requested quantity exceeds available tickets.');
        }

        return DB::transaction(function () use ($listing, $buyer, $quantity) {
            $totalPrice = $listing->price * $quantity;

            // Create new ticket order for buyer
            $buyerOrder = \App\Models\TicketOrder::create([
                'event_id' => $listing->event_id,
                'user_id' => $buyer->id,
                'status' => 'completed',
                'subtotal' => $totalPrice,
                'fees' => 0,
                'discount' => 0,
                'total' => $totalPrice,
                'payment_status' => 'completed',
                'completed_at' => now(),
            ]);

            // Create ticket order item for buyer
            $buyerOrder->items()->create([
                'ticket_plan_id' => $listing->ticketOrderItem->ticket_plan_id,
                'quantity' => $quantity,
                'unit_price' => $listing->price,
                'total_price' => $totalPrice,
            ]);

            // Update listing
            if ($quantity >= $listing->quantity) {
                $listing->markAsSold($buyer->id);
            } else {
                $listing->decrement('quantity', $quantity);
            }

            return $buyerOrder;
        });
    }

    public function cancelListing(TicketListing $listing): bool
    {
        $listing->update(['status' => TicketListing::STATUS_CANCELLED]);

        return true;
    }
}

```

### TicketPaymentService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\TicketOrder;
use App\Services\StripeConnectService;
use Stripe\Exception\ApiErrorException;
use Stripe\StripeClient;

final class TicketPaymentService
{
    public function __construct(
        private readonly StripeConnectService $stripeConnect
    ) {}

    public function createCheckoutSession(TicketOrder $order, string $successUrl, string $cancelUrl): \Stripe\Checkout\Session
    {
        $stripe = new StripeClient(config('services.stripe.key'));

        $lineItems = [];
        foreach ($order->items as $item) {
            $lineItems[] = [
                'price_data' => [
                    'currency' => 'usd',
                    'product_data' => [
                        'name' => $item->ticketPlan->name,
                        'description' => $item->ticketPlan->description,
                    ],
                    'unit_amount' => (int) ($item->unit_price * 100),
                ],
                'quantity' => $item->quantity,
            ];
        }

        // Add fees as separate line item
        if ($order->fees > 0) {
            $lineItems[] = [
                'price_data' => [
                    'currency' => 'usd',
                    'product_data' => [
                        'name' => 'Service Fee',
                    ],
                    'unit_amount' => (int) ($order->fees * 100),
                ],
                'quantity' => 1,
            ];
        }

        // Add discount as negative line item if applicable
        if ($order->discount > 0) {
            $lineItems[] = [
                'price_data' => [
                    'currency' => 'usd',
                    'product_data' => [
                        'name' => 'Discount',
                    ],
                    'unit_amount' => (int) (-$order->discount * 100), // Negative amount for discount
                ],
                'quantity' => 1,
            ];
        }

        try {
            $session = $stripe->checkout->sessions->create([
                'payment_method_types' => ['card'],
                'line_items' => $lineItems,
                'mode' => 'payment',
                'success_url' => $successUrl,
                'cancel_url' => $cancelUrl,
                'metadata' => [
                    'ticket_order_id' => $order->id,
                    'event_id' => $order->event_id,
                    'user_id' => $order->user_id,
                ],
            ]);

            // Update order with payment intent
            $order->update([
                'payment_intent_id' => $session->payment_intent,
            ]);

            return $session;
        } catch (ApiErrorException $e) {
            throw new \Exception('Failed to create checkout session: '.$e->getMessage());
        }
    }

    public function confirmPayment(TicketOrder $order, string $paymentIntentId): bool
    {
        $stripe = new StripeClient(config('services.stripe.key'));

        try {
            $paymentIntent = $stripe->paymentIntents->retrieve($paymentIntentId);

            if ($paymentIntent->status === 'succeeded') {
                $order->update([
                    'status' => 'completed',
                    'payment_status' => 'completed',
                    'payment_intent_id' => $paymentIntentId,
                    'completed_at' => now(),
                ]);

                return true;
            }

            return false;
        } catch (ApiErrorException $e) {
            throw new \Exception('Failed to confirm payment: '.$e->getMessage());
        }
    }
}

```

### TicketTransferService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\TicketOrderItem;
use App\Models\TicketTransfer;
use App\Models\User;
use Illuminate\Support\Str;

final class TicketTransferService
{
    public function createTransfer(TicketOrderItem $ticketOrderItem, User $fromUser, string $toEmail, array $data = []): TicketTransfer
    {
        // Verify ownership
        if ($ticketOrderItem->ticketOrder->user_id !== $fromUser->id) {
            throw new \Exception('You do not own this ticket.');
        }

        // Check for existing pending transfer
        $existingTransfer = TicketTransfer::where('ticket_order_item_id', $ticketOrderItem->id)
            ->where('from_user_id', $fromUser->id)
            ->pending()
            ->first();

        if ($existingTransfer) {
            throw new \Exception('You already have a pending transfer for this ticket.');
        }

        // Check if recipient is a user
        $recipient = User::where('email', $toEmail)->first();

        return TicketTransfer::create([
            'ticket_order_item_id' => $ticketOrderItem->id,
            'from_user_id' => $fromUser->id,
            'to_user_id' => $recipient?->id,
            'to_email' => $toEmail,
            'status' => TicketTransfer::STATUS_PENDING,
            'transfer_token' => Str::random(64),
            'message' => $data['message'] ?? null,
            'expires_at' => $data['expires_at'] ?? now()->addDays(7),
        ]);
    }

    public function acceptTransfer(TicketTransfer $transfer, User $recipient): bool
    {
        if ($transfer->status !== TicketTransfer::STATUS_PENDING) {
            return false;
        }

        if ($transfer->to_email !== $recipient->email) {
            return false;
        }

        $transfer->update(['to_user_id' => $recipient->id]);
        $transfer->complete();

        return true;
    }

    public function cancelTransfer(TicketTransfer $transfer): bool
    {
        if ($transfer->status !== TicketTransfer::STATUS_PENDING) {
            return false;
        }

        $transfer->update(['status' => TicketTransfer::STATUS_CANCELLED]);

        return true;
    }
}

```

### WeatherService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use App\Models\Event;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;

final class WeatherService
{
    private readonly string $apiKey;
    private readonly string $baseUrl;

    public function __construct()
    {
        $apiKey = config('services.openweather.api_key');
        if (empty($apiKey)) {
            throw new \RuntimeException('OpenWeather API key not configured. Please set OPENWEATHER_API_KEY in your .env file.');
        }
        $this->apiKey = $apiKey;
        $this->baseUrl = 'https://api.openweathermap.org/data/2.5';
    }

    public function getWeatherForEvent(Event $event): ?array
    {
        if (!$event->latitude || !$event->longitude) {
            return null;
        }

        $cacheKey = "weather:event:{$event->id}:".$event->event_date->format('Y-m-d');

        return Cache::remember($cacheKey, now()->addHours(6), function () use ($event) {
            try {
                $response = Http::get("{$this->baseUrl}/forecast", [
                    'lat' => $event->latitude,
                    'lon' => $event->longitude,
                    'appid' => $this->apiKey,
                    'units' => 'imperial',
                ]);

                if ($response->successful()) {
                    $data = $response->json();

                    // Find forecast for event date/time
                    $eventDateTime = $event->event_date->copy();
                    if ($event->time) {
                        $timeParts = explode(':', $event->time);
                        $eventDateTime->setTime((int) $timeParts[0], (int) $timeParts[1]);
                    }

                    $forecast = $this->findClosestForecast($data['list'] ?? [], $eventDateTime);

                    if ($forecast) {
                        return [
                            'temperature' => $forecast['main']['temp'] ?? null,
                            'feels_like' => $forecast['main']['feels_like'] ?? null,
                            'condition' => $forecast['weather'][0]['main'] ?? null,
                            'description' => $forecast['weather'][0]['description'] ?? null,
                            'icon' => $forecast['weather'][0]['icon'] ?? null,
                            'humidity' => $forecast['main']['humidity'] ?? null,
                            'wind_speed' => $forecast['wind']['speed'] ?? null,
                            'wind_direction' => $forecast['wind']['deg'] ?? null,
                        ];
                    }
                }

                return null;
            } catch (\Exception $e) {
                Log::error('Weather API error', [
                    'event_id' => $event->id,
                    'error' => $e->getMessage(),
                ]);

                return null;
            }
        });
    }

    public function getWeatherForCoordinates(float $latitude, float $longitude, ?\Carbon\Carbon $dateTime = null): ?array
    {
        return $this->getWeatherForLocation($latitude, $longitude, $dateTime);
    }

    public function getWeatherForLocation(float $latitude, float $longitude, ?\Carbon\Carbon $dateTime = null): ?array
    {
        $cacheKey = "weather:location:{$latitude}:{$longitude}:".($dateTime ? $dateTime->format('Y-m-d-H') : 'current');

        return Cache::remember($cacheKey, now()->addHours(1), function () use ($latitude, $longitude, $dateTime) {
            try {
                if ($dateTime && $dateTime->isFuture() && $dateTime->diffInHours(now()) <= 120) {
                    // Use forecast API for future dates
                    $response = Http::get("{$this->baseUrl}/forecast", [
                        'lat' => $latitude,
                        'lon' => $longitude,
                        'appid' => $this->apiKey,
                        'units' => 'imperial',
                    ]);

                    if ($response->successful()) {
                        $data = $response->json();
                        $forecast = $this->findClosestForecast($data['list'] ?? [], $dateTime);

                        if ($forecast) {
                            return $this->formatWeatherData($forecast);
                        }
                    }
                } else {
                    // Use current weather API
                    $response = Http::get("{$this->baseUrl}/weather", [
                        'lat' => $latitude,
                        'lon' => $longitude,
                        'appid' => $this->apiKey,
                        'units' => 'imperial',
                    ]);

                    if ($response->successful()) {
                        return $this->formatWeatherData($response->json());
                    }
                }

                return null;
            } catch (\Exception $e) {
                Log::error('Weather API error', [
                    'latitude' => $latitude,
                    'longitude' => $longitude,
                    'error' => $e->getMessage(),
                ]);

                return null;
            }
        });
    }

    private function findClosestForecast(array $forecasts, \Carbon\Carbon $targetDateTime): ?array
    {
        $closest = null;
        $minDiff = PHP_INT_MAX;

        foreach ($forecasts as $forecast) {
            $forecastTime = \Carbon\Carbon::parse($forecast['dt_txt']);
            $diff = abs($targetDateTime->diffInMinutes($forecastTime));

            if ($diff < $minDiff) {
                $minDiff = $diff;
                $closest = $forecast;
            }
        }

        return $closest;
    }

    private function formatWeatherData(array $data): array
    {
        return [
            'temperature' => $data['main']['temp'] ?? null,
            'feels_like' => $data['main']['feels_like'] ?? null,
            'condition' => $data['weather'][0]['main'] ?? null,
            'description' => $data['weather'][0]['description'] ?? null,
            'icon' => $data['weather'][0]['icon'] ?? null,
            'humidity' => $data['main']['humidity'] ?? null,
            'wind_speed' => $data['wind']['speed'] ?? null,
            'wind_direction' => $data['wind']['deg'] ?? null,
            'pressure' => $data['main']['pressure'] ?? null,
            'visibility' => $data['visibility'] ?? null,
        ];
    }
}

```

### WebPushService.php
```php
<?php

declare(strict_types=1);

namespace App\Services;

use Minishlink\WebPush\WebPush;
use Minishlink\WebPush\Subscription;
use App\Models\NotificationSubscription;
use Illuminate\Support\Facades\Log;

final class WebPushService
{
    private WebPush $webPush;

    public function __construct()
    {
        $vapidPublicKey = config('services.webpush.public_key');
        $vapidPrivateKey = config('services.webpush.private_key');
        $vapidSubject = config('services.webpush.subject', 'mailto:notifications@shine.com');

        if (!$vapidPublicKey || !$vapidPrivateKey) {
            throw new \RuntimeException('Web Push VAPID keys not configured. Please set VAPID_PUBLIC_KEY and VAPID_PRIVATE_KEY in .env');
        }

        $this->webPush = new WebPush([
            'VAPID' => [
                'subject' => $vapidSubject,
                'publicKey' => $vapidPublicKey,
                'privateKey' => $vapidPrivateKey,
            ],
        ]);

        // Enable automatic padding for security
        $this->webPush->setAutomaticPadding(true);
    }

    /**
     * Send push notification to a single subscription
     */
    public function sendToSubscription(NotificationSubscription $sub, array $payload): bool
    {
        if (!$sub->web_push_endpoint) {
            return false;
        }

        $subscription = Subscription::create([
            'endpoint' => $sub->web_push_endpoint,
            'publicKey' => $sub->web_push_p256dh,
            'authToken' => $sub->web_push_auth,
        ]);

        try {
            $result = $this->webPush->sendOneNotification(
                $subscription,
                json_encode($payload)
            );

            if ($result->isSuccess()) {
                return true;
            }

            // Handle expired subscription
            if ($result->isSubscriptionExpired()) {
                $sub->update([
                    'web_push_endpoint' => null,
                    'web_push_p256dh' => null,
                    'web_push_auth' => null,
                ]);
            }

            return false;
        } catch (\Exception $e) {
            Log::error('Web Push Failed', [
                'subscription_id' => $sub->id,
                'error' => $e->getMessage()
            ]);
            return false;
        }
    }

    /**
     * Send to multiple subscriptions (batched)
     */
    public function sendToMany(array $subscriptions, array $payload): array
    {
        $results = ['success' => 0, 'failed' => 0, 'expired' => []];

        foreach ($subscriptions as $sub) {
            if (!$sub->web_push_endpoint) {
                continue;
            }

            $subscription = Subscription::create([
                'endpoint' => $sub->web_push_endpoint,
                'publicKey' => $sub->web_push_p256dh,
                'authToken' => $sub->web_push_auth,
            ]);

            $this->webPush->queueNotification($subscription, json_encode($payload));
        }

        foreach ($this->webPush->flush() as $report) {
            if ($report->isSuccess()) {
                $results['success']++;
            } else {
                $results['failed']++;
                if ($report->isSubscriptionExpired()) {
                    $results['expired'][] = $report->getEndpoint();
                }
            }
        }

        return $results;
    }
}

```

---
## API Resources

(no API Resources)
---
## Form Requests

### app/Http/Requests/Settings/ProfileUpdateRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\Settings;

use App\Models\User;
use Illuminate\Contracts\Validation\ValidationRule;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

final class ProfileUpdateRequest extends FormRequest
{
    /**
     * Get the validation rules that apply to the request.
     *
     * @return array<string, ValidationRule|array<mixed>|string>
     */
    public function rules(): array
    {
        return [
            'name' => ['required', 'string', 'max:255'],

            'email' => [
                'required',
                'string',
                'lowercase',
                'email',
                'max:255',
                Rule::unique(User::class)->ignore($this->user()->id),
            ],
        ];
    }
}
```

### app/Http/Requests/StorePerformerRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests;

use App\Rules\FreeIfWorkspaceNotApproved;
use Illuminate\Foundation\Http\FormRequest;

final class StorePerformerRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        $workspace = $this->user()?->currentWorkspace;

        $rules = [
            'name' => ['required', 'string', 'max:255'],
            'images' => ['sometimes', 'array', 'max:10'],
            'images.*' => ['file', 'image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
            'genres' => ['required', 'array', 'min:1'],
            'genres.*' => ['string', 'max:100'],
            'bio' => ['required', 'string', 'max:2000'],
            'years_active' => ['nullable', 'integer', 'min:0'],
            'shows_played' => ['nullable', 'integer', 'min:0'],
            'home_city' => ['nullable', 'string', 'max:100'],
            'available_for_booking' => ['boolean'],
            'has_merchandise' => ['boolean'],
            'has_original_music' => ['boolean'],
            'offers_meet_and_greet' => ['boolean'],
            'takes_requests' => ['boolean'],
            'available_for_private_events' => ['boolean'],
            'is_family_friendly' => ['boolean'],
            'has_samples' => ['boolean'],
            'base_price' => ['nullable', 'numeric', 'min:0'],
            'currency' => ['nullable', 'string', 'max:3'],
            'minimum_booking_hours' => ['nullable', 'integer', 'min:1'],
            'travel_fee_per_mile' => ['nullable', 'numeric', 'min:0'],
            'setup_fee' => ['nullable', 'numeric', 'min:0'],
            'cancellation_policy' => ['nullable', 'string', 'max:1000'],
        ];

        // Add workspace approval check for pricing
        if ($workspace) {
            $rules['base_price'][] = new FreeIfWorkspaceNotApproved($workspace);
            $rules['travel_fee_per_mile'][] = new FreeIfWorkspaceNotApproved($workspace);
            $rules['setup_fee'][] = new FreeIfWorkspaceNotApproved($workspace);
        }

        return $rules;
    }

    public function messages(): array
    {
        return [
            'name.required' => 'Performer name is required.',
            'genres.required' => 'At least one genre is required.',
            'genres.min' => 'At least one genre must be selected.',
            'bio.required' => 'Bio is required.',
            'bio.max' => 'Bio cannot exceed 2000 characters.',
        ];
    }

    protected function prepareForValidation(): void
    {
        // Parse JSON strings to arrays for genres
        if ($this->has('genres') && is_string($this->genres)) {
            $this->merge([
                'genres' => json_decode($this->genres, true) ?? [],
            ]);
        }

        // Set default price values to 0.00 if not provided or empty
        $workspace = $this->user()?->currentWorkspace;
        $canAcceptPayments = $workspace && $workspace->canAcceptPayments();

        $priceFields = ['base_price', 'travel_fee_per_mile', 'setup_fee'];
        $priceMerge = [];

        foreach ($priceFields as $field) {
            if (! $canAcceptPayments) {
                // Force to 0.00 if workspace cannot accept payments
                $priceMerge[$field] = '0.00';
            } elseif (! $this->filled($field)) {
                // Default to 0.00 if not provided
                $priceMerge[$field] = '0.00';
            }
        }

        if (! empty($priceMerge)) {
            $this->merge($priceMerge);
        }
    }
}
```

### app/Http/Requests/Auth/LoginRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\Auth;

use Illuminate\Auth\Events\Lockout;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\RateLimiter;
use Illuminate\Support\Str;
use Illuminate\Validation\ValidationException;

final class LoginRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return true;
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array<string, \Illuminate\Contracts\Validation\ValidationRule|array<mixed>|string>
     */
    public function rules(): array
    {
        return [
            'email' => ['required', 'string', 'email'],
            'password' => ['required', 'string'],
            'invitation' => ['nullable', 'string', 'max:255'],
        ];
    }

    /**
     * Attempt to authenticate the request's credentials.
     *
     * @throws ValidationException
     */
    public function authenticate(): void
    {
        $this->ensureIsNotRateLimited();

        if (! Auth::attempt($this->only('email', 'password'), $this->boolean('remember'))) {
            RateLimiter::hit($this->throttleKey());

            throw ValidationException::withMessages([
                'email' => __('auth.failed'),
            ]);
        }

        RateLimiter::clear($this->throttleKey());
    }

    /**
     * Ensure the login request is not rate limited.
     *
     * @throws ValidationException
     */
    public function ensureIsNotRateLimited(): void
    {
        if (! RateLimiter::tooManyAttempts($this->throttleKey(), 5)) {
            return;
        }

        event(new Lockout($this));

        $seconds = RateLimiter::availableIn($this->throttleKey());

        throw ValidationException::withMessages([
            'email' => __('auth.throttle', [
                'seconds' => $seconds,
                'minutes' => ceil($seconds / 60),
            ]),
        ]);
    }

    /**
     * Get the rate limiting throttle key for the request.
     */
    public function throttleKey(): string
    {
        return Str::transliterate(Str::lower($this->string('email')).'|'.$this->ip());
    }
}
```

### app/Http/Requests/StoreCalendarRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests;

use App\Rules\FreeIfWorkspaceNotApproved;
use Illuminate\Foundation\Http\FormRequest;

final class StoreCalendarRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        $workspace = $this->user()?->currentWorkspace;

        $rules = [
            'title' => ['required', 'string', 'max:255'],
            'description' => ['required', 'string', 'max:1000'],
            'category' => ['required', 'string', 'in:jazz,kids,fitness,seniors,schools,sports,arts,food,professional'],
            'image' => ['nullable', 'file', 'image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
            'about' => ['nullable', 'string', 'max:5000'],
            'location' => ['nullable', 'string', 'max:255'],
            'update_frequency' => ['required', 'string', 'in:daily,weekly,bi-weekly,monthly'],
            'subscription_price' => ['required', 'numeric', 'min:0', 'max:999.99'],
            'is_private' => ['boolean'],
        ];

        // Add workspace approval check for pricing
        if ($workspace) {
            $rules['subscription_price'][] = new FreeIfWorkspaceNotApproved($workspace);
        }

        return $rules;
    }

    public function messages(): array
    {
        return [
            'title.required' => 'Calendar title is required.',
            'description.required' => 'Calendar description is required.',
            'category.required' => 'Calendar category is required.',
            'category.in' => 'Invalid calendar category selected.',
            'update_frequency.required' => 'Update frequency is required.',
            'update_frequency.in' => 'Invalid update frequency selected.',
            'subscription_price.required' => 'Subscription price is required.',
            'subscription_price.min' => 'Subscription price cannot be negative.',
            'subscription_price.max' => 'Subscription price cannot exceed $999.99.',
        ];
    }

    protected function prepareForValidation(): void
    {
        // Set default subscription price to 0.00 if not provided or workspace cannot accept payments
        $workspace = $this->user()?->currentWorkspace;
        $canAcceptPayments = $workspace && $workspace->canAcceptPayments();

        if (! $canAcceptPayments) {
            // Force to 0.00 if workspace cannot accept payments
            $this->merge(['subscription_price' => '0.00']);
        } elseif (! $this->filled('subscription_price')) {
            // Default to 0.00 if not provided
            $this->merge(['subscription_price' => '0.00']);
        }
    }
}
```

### app/Http/Requests/StoreEventRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests;

use App\Rules\FreeIfWorkspaceNotApproved;
use Illuminate\Foundation\Http\FormRequest;

final class StoreEventRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        $workspace = $this->user()?->currentWorkspace;

        $rules = [
            'title' => ['required', 'string', 'max:255'],
            'images' => ['sometimes', 'array', 'max:5'],
            'images.*' => ['file', 'image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
            'event_date' => ['required', 'date', 'after:now'],
            'time' => ['required', 'date_format:H:i'],
            'description' => ['required', 'string', 'max:5000'],
            'category' => ['required', 'string', 'max:100'],
            'subcategories' => ['nullable', 'array'],
            'subcategories.*' => ['string', 'max:100'],
            'badges' => ['nullable', 'array'],
            'badges.*' => ['string', 'max:50'],
            'is_free' => ['boolean'],
            'price_min' => ['required_if:is_free,false', 'nullable', 'numeric', 'min:0'],
            'price_max' => ['required_if:is_free,false', 'nullable', 'numeric', 'min:0', 'gte:price_min'],
            'latitude' => ['required', 'numeric', 'between:-90,90'],
            'longitude' => ['required', 'numeric', 'between:-180,180'],
            'google_place_id' => ['nullable', 'string', 'max:255'],
            'postal_code' => ['nullable', 'string', 'max:20'],
            'venue_id' => ['nullable', 'exists:venues,id'],
            'performer_id' => ['nullable', 'exists:performers,id'],
            'new_venue' => ['nullable', 'array'],
            'new_venue.name' => ['required_with:new_venue', 'string', 'max:255'],
            'new_venue.description' => ['required_with:new_venue', 'string', 'max:2000'],
            'new_venue.venue_type' => ['required_with:new_venue', 'string', 'max:100'],
            'new_venue.capacity' => ['required_with:new_venue', 'integer', 'min:1'],
            'new_venue.address' => ['required_with:new_venue', 'string', 'max:500'],
            'new_performer' => ['nullable', 'array'],
            'new_performer.name' => ['required_with:new_performer', 'string', 'max:255'],
            'new_performer.bio' => ['required_with:new_performer', 'string', 'max:2000'],
            'new_performer.genres' => ['required_with:new_performer', 'array', 'min:1'],
            'curator_notes' => ['nullable', 'string', 'max:1000'],
        ];

        // Add workspace approval check for pricing
        if ($workspace) {
            $rules['price_min'][] = new FreeIfWorkspaceNotApproved($workspace);
            $rules['price_max'][] = new FreeIfWorkspaceNotApproved($workspace);
        }

        return $rules;
    }

    public function messages(): array
    {
        return [
            'title.required' => 'Event title is required.',
            'event_date.required' => 'Event date is required.',
            'event_date.after' => 'Event date must be in the future.',
            'time.required' => 'Event time is required.',
            'description.required' => 'Event description is required.',
            'category.required' => 'Event category is required.',
            'price_min.required_if' => 'Minimum price is required for paid events.',
            'price_max.gte' => 'Maximum price must be greater than or equal to minimum price.',
            'venue_id.exists' => 'Selected venue does not exist.',
            'performer_id.exists' => 'Selected performer does not exist.',
        ];
    }

    protected function prepareForValidation(): void
    {
        // Parse JSON strings to arrays
        if ($this->has('subcategories') && is_string($this->subcategories)) {
            $this->merge([
                'subcategories' => json_decode($this->subcategories, true) ?? [],
            ]);
        }

        if ($this->has('badges') && is_string($this->badges)) {
            $this->merge([
                'badges' => json_decode($this->badges, true) ?? [],
            ]);
        }

        if ($this->has('new_venue') && is_string($this->new_venue)) {
            $this->merge([
                'new_venue' => json_decode($this->new_venue, true),
            ]);
        }

        if ($this->has('new_performer') && is_string($this->new_performer)) {
            $this->merge([
                'new_performer' => json_decode($this->new_performer, true),
            ]);
        }
    }
}
```

### app/Http/Requests/StoreStoreRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Support\Str;

final class StoreStoreRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        return [
            'name' => ['required', 'string', 'max:255'],
            'description' => ['nullable', 'string', 'max:5000'],
            'logo' => ['nullable', 'image', 'max:2048', 'mimes:jpeg,jpg,png,gif,webp'],
            'banner' => ['nullable', 'image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
            'slug' => ['sometimes', 'string'],
            'workspace_id' => ['sometimes', 'exists:workspaces,id'],
        ];
    }

    public function messages(): array
    {
        return [
            'name.required' => 'Store name is required.',
            'name.max' => 'Store name cannot exceed 255 characters.',
            'logo.max' => 'Logo file size cannot exceed 2MB.',
            'banner.max' => 'Banner file size cannot exceed 5MB.',
        ];
    }

    protected function prepareForValidation(): void
    {
        $this->merge([
            'slug' => Str::slug($this->name ?? ''),
            'workspace_id' => $this->user()->current_workspace_id,
        ]);
    }
}
```

### app/Http/Requests/UpdateProductRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests;

use App\Rules\FreeIfWorkspaceNotApproved;
use Illuminate\Foundation\Http\FormRequest;

final class UpdateProductRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        $rules = [
            'name' => ['sometimes', 'string', 'max:255'],
            'description' => ['nullable', 'string', 'max:5000'],
            'images' => ['nullable', 'array', 'max:5'],
            'images.*' => ['file', 'image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
            'price' => ['sometimes', 'numeric', 'min:0'],
            'compare_at_price' => ['nullable', 'numeric', 'min:0', 'gt:price'],
            'quantity' => ['sometimes', 'integer', 'min:0'],
            'track_inventory' => ['boolean'],
            'sku' => ['nullable', 'string', 'max:100'],
            'is_active' => ['boolean'],
            'is_featured' => ['boolean'],
        ];

        // Add workspace approval check for pricing if price is being updated
        if ($this->has('price')) {
            $product = $this->route('product');
            if ($product && $product->store && $product->store->workspace) {
                $rules['price'][] = new FreeIfWorkspaceNotApproved($product->store->workspace);
            }
        }

        return $rules;
    }

    public function messages(): array
    {
        return [
            'name.max' => 'Product name cannot exceed 255 characters.',
            'price.min' => 'Price must be at least 0.',
            'compare_at_price.gt' => 'Compare at price must be greater than the regular price.',
            'images.max' => 'Maximum 5 images allowed.',
        ];
    }

    protected function prepareForValidation(): void
    {
        // Set default price to 0.00 if workspace cannot accept payments
        if ($this->has('price')) {
            $product = $this->route('product');
            if ($product && $product->store && $product->store->workspace) {
                $canAcceptPayments = $product->store->workspace->canAcceptPayments();

                if (! $canAcceptPayments) {
                    // Force to 0.00 if workspace cannot accept payments
                    $this->merge(['price' => '0.00']);
                }
            }
        }
    }
}
```

### app/Http/Requests/UpdateCalendarRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests;

use App\Rules\FreeIfWorkspaceNotApproved;
use Illuminate\Foundation\Http\FormRequest;

final class UpdateCalendarRequest extends FormRequest
{
    public function authorize(): bool
    {
        $calendar = $this->route('calendar');

        return $this->user() !== null && (
            $calendar->user_id === $this->user()->id ||
            $calendar->editors()->where('user_id', $this->user()->id)->exists()
        );
    }

    public function rules(): array
    {
        $workspace = $this->user()?->currentWorkspace;

        $rules = [
            'title' => ['sometimes', 'string', 'max:255'],
            'description' => ['sometimes', 'string', 'max:1000'],
            'category' => ['sometimes', 'string', 'in:jazz,kids,fitness,seniors,schools,sports,arts,food,professional'],
            'image' => ['nullable', 'file', 'image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
            'about' => ['nullable', 'string', 'max:5000'],
            'location' => ['nullable', 'string', 'max:255'],
            'update_frequency' => ['sometimes', 'string', 'in:daily,weekly,bi-weekly,monthly'],
            'subscription_price' => ['sometimes', 'numeric', 'min:0', 'max:999.99'],
            'is_private' => ['boolean'],
        ];

        // Add workspace approval check for pricing if subscription_price is being updated
        if ($this->has('subscription_price') && $workspace) {
            $rules['subscription_price'][] = new FreeIfWorkspaceNotApproved($workspace);
        }

        return $rules;
    }

    public function messages(): array
    {
        return [
            'category.in' => 'Invalid calendar category selected.',
            'update_frequency.in' => 'Invalid update frequency selected.',
            'subscription_price.min' => 'Subscription price cannot be negative.',
            'subscription_price.max' => 'Subscription price cannot exceed $999.99.',
        ];
    }

    protected function prepareForValidation(): void
    {
        // Set default subscription price to 0.00 if workspace cannot accept payments
        if ($this->has('subscription_price')) {
            $workspace = $this->user()?->currentWorkspace;
            $canAcceptPayments = $workspace && $workspace->canAcceptPayments();

            if (! $canAcceptPayments) {
                // Force to 0.00 if workspace cannot accept payments
                $this->merge(['subscription_price' => '0.00']);
            } elseif (! $this->filled('subscription_price')) {
                // Default to 0.00 if empty
                $this->merge(['subscription_price' => '0.00']);
            }
        }
    }
}
```

### app/Http/Requests/Social/CreateCommentRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\Social;

use Illuminate\Foundation\Http\FormRequest;

final class CreateCommentRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        return [
            'content' => ['required', 'string', 'max:2000'],
            'parent_id' => ['nullable', 'string', 'exists:social_post_comments,id'],
        ];
    }

    public function messages(): array
    {
        return [
            'content.required' => 'Comment content is required.',
            'content.max' => 'Comment cannot exceed 2000 characters.',
            'parent_id.exists' => 'The parent comment does not exist.',
        ];
    }
}
```

### app/Http/Requests/Social/UpdateProfileRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\Social;

use Illuminate\Foundation\Http\FormRequest;

final class UpdateProfileRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        return [
            'bio' => ['nullable', 'string', 'max:500'],
            'website' => ['nullable', 'url', 'max:255'],
            'location' => ['nullable', 'string', 'max:255'],
            'birth_date' => ['nullable', 'date', 'before:today'],
            'profile_visibility' => ['required', 'in:public,friends,private'],
            'interests' => ['nullable', 'array', 'max:10'],
            'interests.*' => ['string', 'max:50'],
            'cover_photo' => ['nullable', 'string', 'url'],
            'social_links' => ['nullable', 'array'],
            'social_links.*' => ['url'],
            'show_email' => ['required', 'boolean'],
            'show_location' => ['required', 'boolean'],
        ];
    }

    public function messages(): array
    {
        return [
            'bio.max' => 'Bio cannot exceed 500 characters.',
            'website.url' => 'Please enter a valid website URL.',
            'birth_date.before' => 'Birth date must be in the past.',
            'profile_visibility.required' => 'Profile visibility is required.',
            'profile_visibility.in' => 'Invalid profile visibility option.',
            'interests.max' => 'You can have a maximum of 10 interests.',
            'interests.*.max' => 'Each interest cannot exceed 50 characters.',
        ];
    }
}
```

### app/Http/Requests/Social/CreateGroupRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\Social;

use Illuminate\Foundation\Http\FormRequest;

final class CreateGroupRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        return [
            'name' => ['required', 'string', 'max:100'],
            'description' => ['nullable', 'string', 'max:1000'],
            'privacy' => ['required', 'in:public,private,secret'],
            'cover_image' => ['nullable', 'string', 'url'],
        ];
    }

    public function messages(): array
    {
        return [
            'name.required' => 'Group name is required.',
            'name.max' => 'Group name cannot exceed 100 characters.',
            'description.max' => 'Description cannot exceed 1000 characters.',
            'privacy.required' => 'Group privacy setting is required.',
            'privacy.in' => 'Invalid privacy option.',
        ];
    }
}
```

### app/Http/Requests/Social/CreatePostRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\Social;

use Illuminate\Foundation\Http\FormRequest;

final class CreatePostRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        return [
            'content' => ['required', 'string', 'max:5000'],
            'media' => ['nullable', 'array', 'max:4'],
            'media.*' => ['string', 'url'],
            'visibility' => ['required', 'in:public,friends,private'],
            'location' => ['nullable', 'array'],
            'location.name' => ['required_with:location', 'string', 'max:255'],
            'location.lat' => ['required_with:location', 'numeric', 'between:-90,90'],
            'location.lng' => ['required_with:location', 'numeric', 'between:-180,180'],
        ];
    }

    public function messages(): array
    {
        return [
            'content.required' => 'Post content is required.',
            'content.max' => 'Post content cannot exceed 5000 characters.',
            'media.max' => 'You can upload a maximum of 4 media files.',
            'visibility.required' => 'Please select post visibility.',
            'visibility.in' => 'Invalid visibility option.',
        ];
    }
}
```

### app/Http/Requests/SendMessageRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

final class SendMessageRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'message' => ['required', 'string', 'max:1000'],
            'type' => ['sometimes', 'string', 'in:text,image,file'],
            'metadata' => ['sometimes', 'array'],
        ];
    }

    public function messages(): array
    {
        return [
            'message.required' => 'Message content is required.',
            'message.max' => 'Message cannot be longer than 1000 characters.',
            'type.in' => 'Message type must be text, image, or file.',
        ];
    }
}
```

### app/Http/Requests/UpdateStoreRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

final class UpdateStoreRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        return [
            'name' => ['sometimes', 'string', 'max:255'],
            'description' => ['nullable', 'string', 'max:5000'],
            'logo' => ['nullable', 'file', 'image', 'max:2048', 'mimes:jpeg,jpg,png,gif,webp'],
            'banner' => ['nullable', 'file', 'image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
        ];
    }

    public function messages(): array
    {
        return [
            'name.max' => 'Store name cannot exceed 255 characters.',
            'logo.max' => 'Logo file size cannot exceed 2MB.',
            'banner.max' => 'Banner file size cannot exceed 5MB.',
        ];
    }
}
```

### app/Http/Requests/StoreCommunityThreadReplyRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

final class StoreCommunityThreadReplyRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        return auth()->check();
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array<string, \Illuminate\Contracts\Validation\ValidationRule|array<mixed>|string>
     */
    public function rules(): array
    {
        return [
            'content' => ['required', 'string', 'min:3', 'max:10000'],
            'reply_to_id' => ['nullable', 'uuid', 'exists:community_thread_replies,id'],
        ];
    }

    /**
     * Get custom error messages for validator errors.
     *
     * @return array<string, string>
     */
    public function messages(): array
    {
        return [
            'content.required' => 'Reply content is required.',
            'content.min' => 'Reply must be at least 3 characters long.',
            'content.max' => 'Reply cannot exceed 10,000 characters.',
            'reply_to_id.exists' => 'The reply you are responding to does not exist.',
        ];
    }
}
```

### app/Http/Requests/DayNews/StoreLegalNoticeRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\DayNews;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

final class StoreLegalNoticeRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        return [
            'type' => ['required', 'string', Rule::in(['foreclosure', 'probate', 'name_change', 'business_formation', 'public_hearing', 'zoning', 'tax_sale', 'other'])],
            'case_number' => ['nullable', 'string', 'max:255'],
            'title' => ['required', 'string', 'max:255'],
            'content' => ['required', 'string', 'max:10000'],
            'court' => ['nullable', 'string', 'max:255'],
            'publish_date' => ['required', 'date'],
            'expiry_date' => ['nullable', 'date', 'after:publish_date'],
            'region_ids' => ['nullable', 'array'],
            'region_ids.*' => ['exists:regions,id'],
            'metadata' => ['nullable', 'array'],
        ];
    }

    public function messages(): array
    {
        return [
            'type.required' => 'Notice type is required.',
            'type.in' => 'Invalid notice type selected.',
            'title.required' => 'Notice title is required.',
            'title.max' => 'Title cannot exceed 255 characters.',
            'content.required' => 'Notice content is required.',
            'content.max' => 'Content cannot exceed 10,000 characters.',
            'publish_date.required' => 'Publish date is required.',
            'publish_date.date' => 'Publish date must be a valid date.',
            'expiry_date.date' => 'Expiry date must be a valid date.',
            'expiry_date.after' => 'Expiry date must be after publish date.',
            'region_ids.*.exists' => 'One or more selected regions are invalid.',
        ];
    }
}

```

### app/Http/Requests/DayNews/StoreAuthorProfileRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\DayNews;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

final class StoreAuthorProfileRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        $userId = $this->user()->id;

        return [
            'bio' => ['nullable', 'string', 'max:2000'],
            'author_slug' => [
                'nullable',
                'string',
                'max:255',
                'alpha_dash',
                Rule::unique('users', 'author_slug')->ignore($userId),
            ],
        ];
    }

    public function messages(): array
    {
        return [
            'bio.max' => 'Bio cannot exceed 2,000 characters.',
            'author_slug.max' => 'Author slug cannot exceed 255 characters.',
            'author_slug.alpha_dash' => 'Author slug can only contain letters, numbers, dashes, and underscores.',
            'author_slug.unique' => 'This author slug is already taken.',
        ];
    }
}

```

### app/Http/Requests/DayNews/StorePhotoAlbumRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\DayNews;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

final class StorePhotoAlbumRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        return [
            'title' => ['required', 'string', 'max:255'],
            'description' => ['nullable', 'string', 'max:2000'],
            'visibility' => ['required', 'string', Rule::in(['public', 'private', 'community'])],
            'cover_image_id' => ['nullable', 'uuid', 'exists:photos,id'],
        ];
    }

    public function messages(): array
    {
        return [
            'title.required' => 'Album title is required.',
            'title.max' => 'Title cannot exceed 255 characters.',
            'visibility.required' => 'Please select album visibility.',
            'visibility.in' => 'Invalid visibility option selected.',
            'cover_image_id.exists' => 'Selected cover image does not exist.',
        ];
    }
}

```

### app/Http/Requests/DayNews/UpdateClassifiedRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\DayNews;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

final class UpdateClassifiedRequest extends FormRequest
{
    public function authorize(): bool
    {
        $classified = $this->route('classified');
        return $this->user() !== null && $this->user()->id === $classified->user_id;
    }

    public function rules(): array
    {
        return [
            'category' => ['sometimes', 'required', 'string', Rule::in([
                'for_sale',
                'housing',
                'jobs',
                'services',
                'community',
                'personals',
            ])],
            'subcategory' => ['nullable', 'string', 'max:100'],
            'title' => ['sometimes', 'required', 'string', 'max:255'],
            'description' => ['sometimes', 'required', 'string', 'max:5000'],
            'price' => ['nullable', 'numeric', 'min:0'],
            'price_type' => ['nullable', 'string', Rule::in(['fixed', 'negotiable', 'contact_for_pricing'])],
            'condition' => ['nullable', 'string', 'max:50'],
            'location' => ['sometimes', 'required', 'string', 'max:255'],
            'images' => ['nullable', 'array', 'max:5'],
            'images.*' => ['image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
        ];
    }

    public function messages(): array
    {
        return [
            'category.required' => 'Category is required.',
            'category.in' => 'Invalid category selected.',
            'title.required' => 'Title is required.',
            'title.max' => 'Title cannot exceed 255 characters.',
            'description.required' => 'Description is required.',
            'description.max' => 'Description cannot exceed 5,000 characters.',
            'price.numeric' => 'Price must be a valid number.',
            'price.min' => 'Price cannot be negative.',
            'price_type.in' => 'Invalid price type selected.',
            'location.required' => 'Location is required.',
            'location.max' => 'Location cannot exceed 255 characters.',
            'images.max' => 'You can upload a maximum of 5 images.',
            'images.*.image' => 'All files must be images.',
            'images.*.max' => 'Each image file size cannot exceed 5MB.',
            'images.*.mimes' => 'Images must be JPEG, PNG, GIF, or WebP files.',
        ];
    }
}

```

### app/Http/Requests/DayNews/UpdateCouponRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\DayNews;

use App\Models\Coupon;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

final class UpdateCouponRequest extends FormRequest
{
    public function authorize(): bool
    {
        $coupon = $this->route('coupon');
        return $this->user() !== null && $this->user()->id === $coupon->user_id;
    }

    public function rules(): array
    {
        $coupon = $this->route('coupon');

        return [
            'title' => ['sometimes', 'required', 'string', 'max:255'],
            'description' => ['nullable', 'string', 'max:2000'],
            'discount_type' => ['sometimes', 'required', 'string', Rule::in([
                'percentage',
                'fixed_amount',
                'buy_one_get_one',
                'free_item',
            ])],
            'discount_value' => ['nullable', 'numeric', 'min:0', 'required_if:discount_type,percentage,fixed_amount'],
            'terms' => ['nullable', 'string', 'max:1000'],
            'code' => ['nullable', 'string', 'max:50', Rule::unique('coupons', 'code')->ignore($coupon->id)],
            'image' => ['nullable', 'image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
            'business_name' => ['sometimes', 'required', 'string', 'max:255'],
            'business_id' => ['nullable', 'exists:businesses,id'],
            'business_location' => ['nullable', 'string', 'max:255'],
            'start_date' => ['sometimes', 'required', 'date'],
            'end_date' => ['sometimes', 'required', 'date', 'after:start_date'],
            'usage_limit' => ['nullable', 'integer', 'min:1'],
            'region_ids' => ['nullable', 'array'],
            'region_ids.*' => ['exists:regions,id'],
        ];
    }

    public function messages(): array
    {
        return [
            'title.required' => 'Coupon title is required.',
            'title.max' => 'Title cannot exceed 255 characters.',
            'description.max' => 'Description cannot exceed 2,000 characters.',
            'discount_type.required' => 'Discount type is required.',
            'discount_type.in' => 'Invalid discount type selected.',
            'discount_value.required_if' => 'Discount value is required for percentage and fixed amount discounts.',
            'discount_value.numeric' => 'Discount value must be a valid number.',
            'discount_value.min' => 'Discount value cannot be negative.',
            'terms.max' => 'Terms cannot exceed 1,000 characters.',
            'code.max' => 'Code cannot exceed 50 characters.',
            'code.unique' => 'This coupon code is already in use.',
            'image.image' => 'The file must be an image.',
            'image.max' => 'Image file size cannot exceed 5MB.',
            'image.mimes' => 'Image must be a JPEG, PNG, GIF, or WebP file.',
            'business_name.required' => 'Business name is required.',
            'business_name.max' => 'Business name cannot exceed 255 characters.',
            'business_id.exists' => 'Selected business does not exist.',
            'business_location.max' => 'Business location cannot exceed 255 characters.',
            'start_date.required' => 'Start date is required.',
            'start_date.date' => 'Start date must be a valid date.',
            'end_date.required' => 'End date is required.',
            'end_date.date' => 'End date must be a valid date.',
            'end_date.after' => 'End date must be after start date.',
            'usage_limit.integer' => 'Usage limit must be a valid number.',
            'usage_limit.min' => 'Usage limit must be at least 1.',
            'region_ids.*.exists' => 'One or more selected regions are invalid.',
        ];
    }
}

```

### app/Http/Requests/DayNews/UpdateDayNewsPostRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\DayNews;

use App\Models\DayNewsPost;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

final class UpdateDayNewsPostRequest extends FormRequest
{
    public function authorize(): bool
    {
        $post = $this->route('post');

        if (! $post instanceof DayNewsPost) {
            return false;
        }

        return $this->user() !== null
            && $this->user()->current_workspace_id === $post->workspace_id
            && $post->status === 'draft';
    }

    public function rules(): array
    {
        return [
            'type' => ['sometimes', 'string', Rule::in(['article', 'announcement', 'notice', 'ad', 'schedule'])],
            'category' => ['nullable', 'string', Rule::in(['demise', 'missing_person', 'emergency'])],
            'title' => ['sometimes', 'string', 'max:255'],
            'content' => ['sometimes', 'string'],
            'excerpt' => ['nullable', 'string', 'max:500'],
            'featured_image' => ['nullable', 'image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
            'region_ids' => ['nullable', 'array'],
            'region_ids.*' => ['exists:regions,id'],
            'metadata' => ['nullable', 'array'],
            'metadata.ad_days' => ['required_if:type,ad', 'integer', 'min:1', 'max:90'],
            'metadata.ad_placement' => ['nullable', 'string', Rule::in(['sidebar', 'banner', 'inline', 'featured'])],
        ];
    }

    public function messages(): array
    {
        return [
            'type.in' => 'Invalid post type selected.',
            'category.in' => 'Invalid category selected.',
            'title.max' => 'Title cannot exceed 255 characters.',
            'excerpt.max' => 'Excerpt cannot exceed 500 characters.',
            'featured_image.max' => 'Featured image file size cannot exceed 5MB.',
            'region_ids.*.exists' => 'One or more selected regions are invalid.',
            'metadata.ad_days.required_if' => 'Ad duration in days is required for advertisements.',
            'metadata.ad_days.min' => 'Ad duration must be at least 1 day.',
            'metadata.ad_days.max' => 'Ad duration cannot exceed 90 days.',
        ];
    }
}
```

### app/Http/Requests/DayNews/StoreCreatorProfileRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\DayNews;

use Illuminate\Foundation\Http\FormRequest;

final class StoreCreatorProfileRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        return [
            'display_name' => ['required', 'string', 'max:255'],
            'bio' => ['nullable', 'string', 'max:2000'],
            'avatar' => ['nullable', 'image', 'max:2048', 'mimes:jpeg,jpg,png,gif,webp'],
            'cover_image' => ['nullable', 'image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
            'social_links' => ['nullable', 'array'],
            'social_links.twitter' => ['nullable', 'url', 'max:255'],
            'social_links.instagram' => ['nullable', 'url', 'max:255'],
            'social_links.facebook' => ['nullable', 'url', 'max:255'],
            'social_links.youtube' => ['nullable', 'url', 'max:255'],
        ];
    }

    public function messages(): array
    {
        return [
            'display_name.required' => 'Display name is required.',
            'display_name.max' => 'Display name cannot exceed 255 characters.',
            'bio.max' => 'Bio cannot exceed 2,000 characters.',
            'avatar.max' => 'Avatar file size cannot exceed 2MB.',
            'cover_image.max' => 'Cover image file size cannot exceed 5MB.',
            'social_links.*.url' => 'Social media links must be valid URLs.',
        ];
    }
}

```

### app/Http/Requests/DayNews/StorePodcastEpisodeRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\DayNews;

use Illuminate\Foundation\Http\FormRequest;

final class StorePodcastEpisodeRequest extends FormRequest
{
    public function authorize(): bool
    {
        $podcast = $this->route('podcast');
        
        if (!$podcast instanceof \App\Models\Podcast) {
            return false;
        }

        return $podcast->creator->user_id === $this->user()->id;
    }

    public function rules(): array
    {
        return [
            'title' => ['required', 'string', 'max:255'],
            'description' => ['nullable', 'string', 'max:5000'],
            'show_notes' => ['nullable', 'string', 'max:10000'],
            'audio_file' => ['required', 'file', 'mimes:mp3,wav,m4a', 'max:102400'], // 100MB max
            'episode_number' => ['nullable', 'string', 'max:50'],
        ];
    }

    public function messages(): array
    {
        return [
            'title.required' => 'Episode title is required.',
            'title.max' => 'Title cannot exceed 255 characters.',
            'description.max' => 'Description cannot exceed 5,000 characters.',
            'show_notes.max' => 'Show notes cannot exceed 10,000 characters.',
            'audio_file.required' => 'Please select an audio file to upload.',
            'audio_file.mimes' => 'Audio file must be MP3, WAV, or M4A format.',
            'audio_file.max' => 'Audio file size cannot exceed 100MB.',
        ];
    }
}

```

### app/Http/Requests/DayNews/StoreAnnouncementRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\DayNews;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

final class StoreAnnouncementRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        return [
            'type' => ['required', 'string', Rule::in([
                'wedding',
                'engagement',
                'birth',
                'graduation',
                'anniversary',
                'celebration',
                'general',
                'community_event',
                'public_notice',
                'emergency_alert',
                'meeting',
                'volunteer_opportunity',
                'road_closure',
                'school_announcement',
            ])],
            'title' => ['required', 'string', 'max:255'],
            'content' => ['required', 'string', 'max:5000'],
            'image' => ['nullable', 'image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
            'location' => ['nullable', 'string', 'max:255'],
            'event_date' => ['nullable', 'date'],
            'region_ids' => ['nullable', 'array'],
            'region_ids.*' => ['exists:regions,id'],
        ];
    }

    public function messages(): array
    {
        return [
            'type.required' => 'Announcement type is required.',
            'type.in' => 'Invalid announcement type selected.',
            'title.required' => 'Title is required.',
            'title.max' => 'Title cannot exceed 255 characters.',
            'content.required' => 'Content is required.',
            'content.max' => 'Content cannot exceed 5,000 characters.',
            'image.image' => 'The file must be an image.',
            'image.max' => 'Image file size cannot exceed 5MB.',
            'image.mimes' => 'Image must be a JPEG, PNG, GIF, or WebP file.',
            'location.max' => 'Location cannot exceed 255 characters.',
            'event_date.date' => 'Event date must be a valid date.',
            'region_ids.*.exists' => 'One or more selected regions are invalid.',
        ];
    }
}

```

### app/Http/Requests/DayNews/StoreDayNewsPostRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\DayNews;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Support\Str;
use Illuminate\Validation\Rule;

final class StoreDayNewsPostRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null && $this->user()->current_workspace_id !== null;
    }

    public function rules(): array
    {
        return [
            'type' => ['required', 'string', Rule::in(['article', 'announcement', 'notice', 'ad', 'schedule'])],
            'category' => ['nullable', 'string', Rule::in(['demise', 'missing_person', 'emergency'])],
            'title' => ['required', 'string', 'max:255'],
            'content' => ['required', 'string'],
            'excerpt' => ['nullable', 'string', 'max:500'],
            'featured_image' => ['nullable', 'image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
            'region_ids' => ['nullable', 'array'],
            'region_ids.*' => ['exists:regions,id'],
            'metadata' => ['nullable', 'array'],
            'metadata.ad_days' => ['required_if:type,ad', 'integer', 'min:1', 'max:90'],
            'metadata.ad_placement' => ['nullable', 'string', Rule::in(['sidebar', 'banner', 'inline', 'featured'])],
        ];
    }

    public function messages(): array
    {
        return [
            'type.required' => 'Post type is required.',
            'type.in' => 'Invalid post type selected.',
            'category.in' => 'Invalid category selected.',
            'title.required' => 'Title is required.',
            'title.max' => 'Title cannot exceed 255 characters.',
            'content.required' => 'Content is required.',
            'excerpt.max' => 'Excerpt cannot exceed 500 characters.',
            'featured_image.max' => 'Featured image file size cannot exceed 5MB.',
            'region_ids.*.exists' => 'One or more selected regions are invalid.',
            'metadata.ad_days.required_if' => 'Ad duration in days is required for advertisements.',
            'metadata.ad_days.min' => 'Ad duration must be at least 1 day.',
            'metadata.ad_days.max' => 'Ad duration cannot exceed 90 days.',
        ];
    }

    protected function prepareForValidation(): void
    {
        $this->merge([
            'slug' => Str::slug($this->title ?? ''),
            'workspace_id' => $this->user()->current_workspace_id,
        ]);
    }
}
```

### app/Http/Requests/DayNews/StorePhotoRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\DayNews;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

final class StorePhotoRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        return [
            'title' => ['required', 'string', 'max:255'],
            'description' => ['nullable', 'string', 'max:2000'],
            'image' => ['required', 'image', 'max:10240', 'mimes:jpeg,jpg,png,gif,webp'],
            'category' => ['nullable', 'string', Rule::in(['Nature', 'Events', 'Recreation', 'Community', 'Sports', 'Environment', 'Other'])],
            'album_id' => ['nullable', 'uuid', 'exists:photo_albums,id'],
            'region_ids' => ['nullable', 'array'],
            'region_ids.*' => ['exists:regions,id'],
        ];
    }

    public function messages(): array
    {
        return [
            'title.required' => 'Photo title is required.',
            'title.max' => 'Title cannot exceed 255 characters.',
            'image.required' => 'Please select an image to upload.',
            'image.image' => 'The file must be an image.',
            'image.max' => 'Image file size cannot exceed 10MB.',
            'image.mimes' => 'Image must be a JPEG, PNG, GIF, or WebP file.',
            'album_id.exists' => 'Selected album does not exist.',
            'region_ids.*.exists' => 'One or more selected regions are invalid.',
        ];
    }
}

```

### app/Http/Requests/DayNews/StoreClassifiedRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\DayNews;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

final class StoreClassifiedRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        return [
            'category' => ['required', 'string', Rule::in([
                'for_sale',
                'housing',
                'jobs',
                'services',
                'community',
                'personals',
            ])],
            'subcategory' => ['nullable', 'string', 'max:100'],
            'title' => ['required', 'string', 'max:255'],
            'description' => ['required', 'string', 'max:5000'],
            'price' => ['nullable', 'numeric', 'min:0'],
            'price_type' => ['nullable', 'string', Rule::in(['fixed', 'negotiable', 'contact_for_pricing'])],
            'condition' => ['nullable', 'string', 'max:50'],
            'location' => ['required', 'string', 'max:255'],
            'images' => ['nullable', 'array', 'max:5'],
            'images.*' => ['image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
        ];
    }

    public function messages(): array
    {
        return [
            'category.required' => 'Category is required.',
            'category.in' => 'Invalid category selected.',
            'title.required' => 'Title is required.',
            'title.max' => 'Title cannot exceed 255 characters.',
            'description.required' => 'Description is required.',
            'description.max' => 'Description cannot exceed 5,000 characters.',
            'price.numeric' => 'Price must be a valid number.',
            'price.min' => 'Price cannot be negative.',
            'price_type.in' => 'Invalid price type selected.',
            'location.required' => 'Location is required.',
            'location.max' => 'Location cannot exceed 255 characters.',
            'images.max' => 'You can upload a maximum of 5 images.',
            'images.*.image' => 'All files must be images.',
            'images.*.max' => 'Each image file size cannot exceed 5MB.',
            'images.*.mimes' => 'Images must be JPEG, PNG, GIF, or WebP files.',
        ];
    }
}

```

### app/Http/Requests/DayNews/UpdateAnnouncementRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\DayNews;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

final class UpdateAnnouncementRequest extends FormRequest
{
    public function authorize(): bool
    {
        $announcement = $this->route('announcement');
        return $this->user() !== null && $this->user()->id === $announcement->user_id;
    }

    public function rules(): array
    {
        return [
            'type' => ['sometimes', 'required', 'string', Rule::in([
                'wedding',
                'engagement',
                'birth',
                'graduation',
                'anniversary',
                'celebration',
                'general',
                'community_event',
                'public_notice',
                'emergency_alert',
                'meeting',
                'volunteer_opportunity',
                'road_closure',
                'school_announcement',
            ])],
            'title' => ['sometimes', 'required', 'string', 'max:255'],
            'content' => ['sometimes', 'required', 'string', 'max:5000'],
            'image' => ['nullable', 'image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
            'location' => ['nullable', 'string', 'max:255'],
            'event_date' => ['nullable', 'date'],
            'region_ids' => ['nullable', 'array'],
            'region_ids.*' => ['exists:regions,id'],
        ];
    }

    public function messages(): array
    {
        return [
            'type.required' => 'Announcement type is required.',
            'type.in' => 'Invalid announcement type selected.',
            'title.required' => 'Title is required.',
            'title.max' => 'Title cannot exceed 255 characters.',
            'content.required' => 'Content is required.',
            'content.max' => 'Content cannot exceed 5,000 characters.',
            'image.image' => 'The file must be an image.',
            'image.max' => 'Image file size cannot exceed 5MB.',
            'image.mimes' => 'Image must be a JPEG, PNG, GIF, or WebP file.',
            'location.max' => 'Location cannot exceed 255 characters.',
            'event_date.date' => 'Event date must be a valid date.',
            'region_ids.*.exists' => 'One or more selected regions are invalid.',
        ];
    }
}

```

### app/Http/Requests/DayNews/StoreCouponRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\DayNews;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;

final class StoreCouponRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        return [
            'title' => ['required', 'string', 'max:255'],
            'description' => ['nullable', 'string', 'max:2000'],
            'discount_type' => ['required', 'string', Rule::in([
                'percentage',
                'fixed_amount',
                'buy_one_get_one',
                'free_item',
            ])],
            'discount_value' => ['nullable', 'numeric', 'min:0', 'required_if:discount_type,percentage,fixed_amount'],
            'terms' => ['nullable', 'string', 'max:1000'],
            'code' => ['nullable', 'string', 'max:50', 'unique:coupons,code'],
            'image' => ['nullable', 'image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
            'business_name' => ['required', 'string', 'max:255'],
            'business_id' => ['nullable', 'exists:businesses,id'],
            'business_location' => ['nullable', 'string', 'max:255'],
            'start_date' => ['required', 'date', 'after_or_equal:today'],
            'end_date' => ['required', 'date', 'after:start_date'],
            'usage_limit' => ['nullable', 'integer', 'min:1'],
            'region_ids' => ['nullable', 'array'],
            'region_ids.*' => ['exists:regions,id'],
        ];
    }

    public function messages(): array
    {
        return [
            'title.required' => 'Coupon title is required.',
            'title.max' => 'Title cannot exceed 255 characters.',
            'description.max' => 'Description cannot exceed 2,000 characters.',
            'discount_type.required' => 'Discount type is required.',
            'discount_type.in' => 'Invalid discount type selected.',
            'discount_value.required_if' => 'Discount value is required for percentage and fixed amount discounts.',
            'discount_value.numeric' => 'Discount value must be a valid number.',
            'discount_value.min' => 'Discount value cannot be negative.',
            'terms.max' => 'Terms cannot exceed 1,000 characters.',
            'code.max' => 'Code cannot exceed 50 characters.',
            'code.unique' => 'This coupon code is already in use.',
            'image.image' => 'The file must be an image.',
            'image.max' => 'Image file size cannot exceed 5MB.',
            'image.mimes' => 'Image must be a JPEG, PNG, GIF, or WebP file.',
            'business_name.required' => 'Business name is required.',
            'business_name.max' => 'Business name cannot exceed 255 characters.',
            'business_id.exists' => 'Selected business does not exist.',
            'business_location.max' => 'Business location cannot exceed 255 characters.',
            'start_date.required' => 'Start date is required.',
            'start_date.date' => 'Start date must be a valid date.',
            'start_date.after_or_equal' => 'Start date must be today or later.',
            'end_date.required' => 'End date is required.',
            'end_date.date' => 'End date must be a valid date.',
            'end_date.after' => 'End date must be after start date.',
            'usage_limit.integer' => 'Usage limit must be a valid number.',
            'usage_limit.min' => 'Usage limit must be at least 1.',
            'region_ids.*.exists' => 'One or more selected regions are invalid.',
        ];
    }
}

```

### app/Http/Requests/DayNews/StorePodcastRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\DayNews;

use Illuminate\Foundation\Http\FormRequest;

final class StorePodcastRequest extends FormRequest
{
    public function authorize(): bool
    {
        $profile = \App\Models\CreatorProfile::where('user_id', $this->user()->id)
            ->approved()
            ->first();

        return $profile !== null;
    }

    public function rules(): array
    {
        return [
            'title' => ['required', 'string', 'max:255'],
            'description' => ['nullable', 'string', 'max:5000'],
            'category' => ['nullable', 'string', 'max:100'],
            'cover_image' => ['nullable', 'image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
            'region_ids' => ['nullable', 'array'],
            'region_ids.*' => ['exists:regions,id'],
        ];
    }

    public function messages(): array
    {
        return [
            'title.required' => 'Podcast title is required.',
            'title.max' => 'Title cannot exceed 255 characters.',
            'description.max' => 'Description cannot exceed 5,000 characters.',
            'cover_image.max' => 'Cover image file size cannot exceed 5MB.',
            'region_ids.*.exists' => 'One or more selected regions are invalid.',
        ];
    }
}

```

### app/Http/Requests/DayNews/StoreMemorialRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests\DayNews;

use Illuminate\Foundation\Http\FormRequest;

final class StoreMemorialRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        return [
            'name' => ['required', 'string', 'max:255'],
            'years' => ['required', 'string', 'max:50'],
            'date_of_passing' => ['required', 'date'],
            'obituary' => ['required', 'string', 'max:5000'],
            'image' => ['nullable', 'image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
            'location' => ['nullable', 'string', 'max:255'],
            'service_date' => ['nullable', 'date'],
            'service_location' => ['nullable', 'string', 'max:255'],
            'service_details' => ['nullable', 'string', 'max:2000'],
            'region_ids' => ['nullable', 'array'],
            'region_ids.*' => ['exists:regions,id'],
        ];
    }

    public function messages(): array
    {
        return [
            'name.required' => 'Name is required.',
            'name.max' => 'Name cannot exceed 255 characters.',
            'years.required' => 'Years are required (e.g., "1932 - 2023").',
            'years.max' => 'Years cannot exceed 50 characters.',
            'date_of_passing.required' => 'Date of passing is required.',
            'date_of_passing.date' => 'Date of passing must be a valid date.',
            'obituary.required' => 'Obituary is required.',
            'obituary.max' => 'Obituary cannot exceed 5,000 characters.',
            'image.max' => 'Image file size cannot exceed 5MB.',
            'image.mimes' => 'Image must be a JPEG, PNG, GIF, or WebP file.',
            'service_date.date' => 'Service date must be a valid date.',
            'region_ids.*.exists' => 'One or more selected regions are invalid.',
        ];
    }
}

```

### app/Http/Requests/StoreProductRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests;

use App\Models\Store;
use App\Rules\FreeIfWorkspaceNotApproved;
use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Support\Str;

final class StoreProductRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        $rules = [
            'store_id' => ['required', 'exists:stores,id'],
            'name' => ['required', 'string', 'max:255'],
            'slug' => ['required', 'string', 'max:255'],
            'description' => ['nullable', 'string', 'max:5000'],
            'images' => ['nullable', 'array', 'max:5'],
            'images.*' => ['file', 'image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
            'price' => ['required', 'numeric', 'min:0'],
            'compare_at_price' => ['nullable', 'numeric', 'min:0', 'gt:price'],
            'quantity' => ['required', 'integer', 'min:0'],
            'track_inventory' => ['boolean'],
            'sku' => ['nullable', 'string', 'max:100'],
            'is_active' => ['boolean'],
            'is_featured' => ['boolean'],
        ];

        // Add workspace approval check for pricing
        if ($this->store_id) {
            $store = Store::with('workspace')->find($this->store_id);
            if ($store && $store->workspace) {
                $rules['price'][] = new FreeIfWorkspaceNotApproved($store->workspace);
            }
        }

        return $rules;
    }

    public function messages(): array
    {
        return [
            'store_id.required' => 'Store is required.',
            'store_id.exists' => 'Selected store does not exist.',
            'name.required' => 'Product name is required.',
            'price.required' => 'Product price is required.',
            'price.min' => 'Price must be at least 0.',
            'compare_at_price.gt' => 'Compare at price must be greater than the regular price.',
            'quantity.required' => 'Quantity is required.',
            'images.max' => 'Maximum 5 images allowed.',
        ];
    }

    protected function prepareForValidation(): void
    {
        $this->merge([
            'slug' => Str::slug($this->name ?? ''),
        ]);

        // Set default price to 0.00 if workspace cannot accept payments
        if ($this->store_id) {
            $store = Store::with('workspace')->find($this->store_id);
            if ($store && $store->workspace) {
                $canAcceptPayments = $store->workspace->canAcceptPayments();

                if (! $canAcceptPayments) {
                    // Force to 0.00 if workspace cannot accept payments
                    $this->merge(['price' => '0.00']);
                }
            }
        }
    }
}
```

### app/Http/Requests/StoreVenueRequest.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Requests;

use App\Rules\FreeIfWorkspaceNotApproved;
use Illuminate\Foundation\Http\FormRequest;

final class StoreVenueRequest extends FormRequest
{
    public function authorize(): bool
    {
        return $this->user() !== null;
    }

    public function rules(): array
    {
        $workspace = $this->user()?->currentWorkspace;

        $rules = [
            'name' => ['required', 'string', 'max:255'],
            'description' => ['required', 'string', 'max:2000'],
            'images' => ['sometimes', 'array', 'max:10'],
            'images.*' => ['file', 'image', 'max:5120', 'mimes:jpeg,jpg,png,gif,webp'],
            'venue_type' => ['required', 'string', 'max:100'],
            'capacity' => ['required', 'integer', 'min:1'],
            'price_per_hour' => ['nullable', 'numeric', 'min:0'],
            'price_per_event' => ['nullable', 'numeric', 'min:0'],
            'price_per_day' => ['nullable', 'numeric', 'min:0'],
            'address' => ['required', 'string', 'max:500'],
            'neighborhood' => ['nullable', 'string', 'max:100'],
            'latitude' => ['required', 'numeric', 'between:-90,90'],
            'longitude' => ['required', 'numeric', 'between:-180,180'],
            'google_place_id' => ['nullable', 'string', 'max:255'],
            'postal_code' => ['nullable', 'string', 'max:20'],
            'amenities' => ['nullable', 'array'],
            'amenities.*' => ['string', 'max:100'],
            'event_types' => ['nullable', 'array'],
            'event_types.*' => ['string', 'max:100'],
            'unavailable_dates' => ['nullable', 'array'],
            'unavailable_dates.*' => ['date'],
        ];

        // Add workspace approval check for pricing
        if ($workspace) {
            $rules['price_per_hour'][] = new FreeIfWorkspaceNotApproved($workspace);
            $rules['price_per_event'][] = new FreeIfWorkspaceNotApproved($workspace);
            $rules['price_per_day'][] = new FreeIfWorkspaceNotApproved($workspace);
        }

        return $rules;
    }

    public function messages(): array
    {
        return [
            'name.required' => 'Venue name is required.',
            'description.required' => 'Venue description is required.',
            'venue_type.required' => 'Venue type is required.',
            'capacity.required' => 'Venue capacity is required.',
            'capacity.min' => 'Capacity must be at least 1.',
            'address.required' => 'Venue address is required.',
            'latitude.required' => 'Latitude is required.',
            'longitude.required' => 'Longitude is required.',
            'latitude.between' => 'Invalid latitude value.',
            'longitude.between' => 'Invalid longitude value.',
        ];
    }

    protected function prepareForValidation(): void
    {
        // Parse JSON strings to arrays for amenities and event_types
        if ($this->has('amenities') && is_string($this->amenities)) {
            $this->merge([
                'amenities' => json_decode($this->amenities, true) ?? [],
            ]);
        }

        if ($this->has('event_types') && is_string($this->event_types)) {
            $this->merge([
                'event_types' => json_decode($this->event_types, true) ?? [],
            ]);
        }

        // Set default price values to 0.00 if not provided or empty
        $workspace = $this->user()?->currentWorkspace;
        $canAcceptPayments = $workspace && $workspace->canAcceptPayments();

        $priceFields = ['price_per_hour', 'price_per_event', 'price_per_day'];
        $priceMerge = [];

        foreach ($priceFields as $field) {
            if (! $canAcceptPayments) {
                // Force to 0.00 if workspace cannot accept payments
                $priceMerge[$field] = '0.00';
            } elseif (! $this->filled($field)) {
                // Default to 0.00 if not provided
                $priceMerge[$field] = '0.00';
            }
        }

        if (! empty($priceMerge)) {
            $this->merge($priceMerge);
        }
    }
}
```

---
## Jobs

### SendEmail.php
```php
<?php

declare(strict_types=1);

namespace App\Jobs;

use App\Models\EmailSend;
use App\Services\EmailDeliveryService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

final class SendEmail implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $tries = 3;
    public int $backoff = 30;

    public function __construct(
        public EmailSend $send
    ) {}

    public function handle(EmailDeliveryService $emailService): void
    {
        try {
            $emailService->sendCampaignEmail($this->send);
        } catch (\Exception $e) {
            $this->send->update([
                'status' => 'failed',
                'error_message' => $e->getMessage(),
            ]);

            throw $e;
        }
    }
}
```

### SendEmergencyEmail.php
```php
<?php

declare(strict_types=1);

namespace App\Jobs;

use App\Models\EmergencyDelivery;
use App\Services\EmailDeliveryService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

final class SendEmergencyEmail implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $tries = 3;
    public int $backoff = 30;

    public function __construct(
        public EmergencyDelivery $delivery
    ) {}

    public function handle(EmailDeliveryService $emailService): void
    {
        $alert = $this->delivery->alert;
        $subscriber = $this->delivery->subscription->subscriber;

        try {
            $messageId = $emailService->sendEmergencyAlert($subscriber, $alert);
            $this->delivery->update([
                'status' => 'sent',
                'external_id' => $messageId,
                'sent_at' => now(),
            ]);
        } catch (\Exception $e) {
            $this->delivery->update([
                'status' => 'failed',
                'error_message' => $e->getMessage(),
            ]);

            throw $e;
        }
    }
}
```

### SendEmergencySms.php
```php
<?php

declare(strict_types=1);

namespace App\Jobs;

use App\Models\EmergencyDelivery;
use App\Services\SmsService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

final class SendEmergencySms implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public int $tries = 3;
    public int $backoff = 10;

    public function __construct(
        public EmergencyDelivery $delivery
    ) {}

    public function handle(SmsService $smsService): void
    {
        $alert = $this->delivery->alert;
        $subscription = $this->delivery->subscription;

        if (!$subscription->canReceiveSms()) {
            $this->delivery->update([
                'status' => 'failed',
                'error_message' => 'SMS not enabled or verified',
            ]);

            return;
        }

        try {
            $messageId = $smsService->sendEmergencyAlert(
                $subscription->phone_number,
                $alert
            );
            $this->delivery->update([
                'status' => 'sent',
                'external_id' => $messageId,
                'sent_at' => now(),
            ]);
        } catch (\Exception $e) {
            $this->delivery->update([
                'status' => 'failed',
                'error_message' => $e->getMessage(),
            ]);

            throw $e;
        }
    }
}
```

### SendNotificationJob.php
```php
<?php

declare(strict_types=1);

namespace App\Jobs;

use App\Models\NotificationLog;
use App\Models\NotificationSubscription;
use App\Services\NotificationService;
use App\Services\WebPushService;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;

final class SendNotificationJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    public function __construct(
        private string $platform,
        private string $communityId,
        private string $notificationType,
        private string $title,
        private string $message,
        private ?string $url = null,
        private bool $sendSms = false,
        private bool $sendPush = false
    ) {}

    public function handle(NotificationService $snsService, WebPushService $webPushService): void
    {
        // Get subscribers
        $subscribers = NotificationSubscription::where('platform', $this->platform)
            ->where('community_id', $this->communityId)
            ->where('status', 'active')
            ->whereJsonContains('notification_types', $this->notificationType)
            ->get();

        // Log notification
        $log = NotificationLog::create([
            'platform' => $this->platform,
            'community_id' => $this->communityId,
            'notification_type' => $this->notificationType,
            'channel' => $this->sendSms && $this->sendPush ? 'sms' : ($this->sendSms ? 'sms' : 'web_push'),
            'title' => $this->title,
            'message' => $this->message,
            'payload' => ['url' => $this->url],
            'recipient_count' => $subscribers->count(),
        ]);

        // Send SMS via SNS Topic
        if ($this->sendSms) {
            $messageId = $snsService->publishToTopic($this->platform, $this->communityId, $this->message, [
                'subject' => $this->title,
                'type' => $this->notificationType,
                'payload' => ['url' => $this->url],
            ]);

            if ($messageId) {
                $log->update(['sns_message_id' => $messageId]);
            } else {
                $log->markAsFailed('SMS sending failed');
            }
        }

        // Send Web Push
        if ($this->sendPush) {
            $pushSubscribers = $subscribers->filter(fn($s) => $s->web_push_endpoint);

            $results = $webPushService->sendToMany($pushSubscribers->all(), [
                'title' => $this->title,
                'body' => $this->message,
                'url' => $this->url,
                'platform' => $this->platform,
                'notification_id' => $log->id,
            ]);

            // Clean up expired subscriptions
            if (!empty($results['expired'])) {
                NotificationSubscription::whereIn('web_push_endpoint', $results['expired'])
                    ->update(['web_push_endpoint' => null]);
            }

            if ($results['failed'] > 0 && $results['success'] === 0) {
                $log->markAsFailed('All web push notifications failed');
            } elseif ($results['failed'] > 0) {
                $log->markAsPartial();
            }
        }

        if ($log->status === 'queued') {
            $log->markAsSent();
        }
    }
}
```

---
## Config (Auth)

```php
<?php

declare(strict_types=1);

return [

    /*
    |--------------------------------------------------------------------------
    | Authentication Defaults
    |--------------------------------------------------------------------------
    |
    | This option defines the default authentication "guard" and password
    | reset "broker" for your application. You may change these values
    | as required, but they're a perfect start for most applications.
    |
    */

    'defaults' => [
        'guard' => env('AUTH_GUARD', 'web'),
        'passwords' => env('AUTH_PASSWORD_BROKER', 'users'),
    ],

    /*
    |--------------------------------------------------------------------------
    | Authentication Guards
    |--------------------------------------------------------------------------
    |
    | Next, you may define every authentication guard for your application.
    | Of course, a great default configuration has been defined for you
    | which utilizes session storage plus the Eloquent user provider.
    |
    | All authentication guards have a user provider, which defines how the
    | users are actually retrieved out of your database or other storage
    | system used by the application. Typically, Eloquent is utilized.
    |
    | Supported: "session"
    |
    */

    'guards' => [
        'web' => [
            'driver' => 'session',
            'provider' => 'users',
        ],
    ],

    /*
    |--------------------------------------------------------------------------
    | User Providers
    |--------------------------------------------------------------------------
    |
    | All authentication guards have a user provider, which defines how the
    | users are actually retrieved out of your database or other storage
    | system used by the application. Typically, Eloquent is utilized.
    |
    | If you have multiple user tables or models you may configure multiple
    | providers to represent the model / table. These providers may then
    | be assigned to any extra authentication guards you have defined.
    |
    | Supported: "database", "eloquent"
    |
    */

    'providers' => [
        'users' => [
            'driver' => 'eloquent',
            'model' => env('AUTH_MODEL', App\Models\User::class),
        ],

        // 'users' => [
        //     'driver' => 'database',
        //     'table' => 'users',
        // ],
    ],

    /*
    |--------------------------------------------------------------------------
    | Resetting Passwords
    |--------------------------------------------------------------------------
    |
    | These configuration options specify the behavior of Laravel's password
    | reset functionality, including the table utilized for token storage
    | and the user provider that is invoked to actually retrieve users.
    |
    | The expiry time is the number of minutes that each reset token will be
    | considered valid. This security feature keeps tokens short-lived so
    | they have less time to be guessed. You may change this as needed.
    |
    | The throttle setting is the number of seconds a user must wait before
    | generating more password reset tokens. This prevents the user from
    | quickly generating a very large amount of password reset tokens.
    |
    */

    'passwords' => [
        'users' => [
            'provider' => 'users',
            'table' => env('AUTH_PASSWORD_RESET_TOKEN_TABLE', 'password_reset_tokens'),
            'expire' => 60,
            'throttle' => 60,
        ],
    ],

    /*
    |--------------------------------------------------------------------------
    | Password Confirmation Timeout
    |--------------------------------------------------------------------------
    |
    | Here you may define the amount of seconds before a password confirmation
    | window expires and users are asked to re-enter their password via the
    | confirmation screen. By default, the timeout lasts for three hours.
    |
    */

    'password_timeout' => env('AUTH_PASSWORD_TIMEOUT', 10800),

    /*
    |--------------------------------------------------------------------------
    | Cross-Domain Authentication Token Expiration
    |--------------------------------------------------------------------------
    |
    | This option defines the number of minutes that cross-domain authentication
    | tokens remain valid. Extended for testing purposes. Default is 24 hours
    | (1440 minutes). For production, consider shorter durations.
    |
    */

    'cross_domain_token_expiration' => env('CROSS_DOMAIN_TOKEN_EXPIRATION', 1440), // 24 hours

];
```

---
## Middleware

### DetectAppDomain.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

final class DetectAppDomain
{
    /**
     * Handle an incoming request.
     */
    public function handle(Request $request, Closure $next): Response
    {
        $host = $request->getHost();

        // Detect the app based on configured domain
        $appType = match ($host) {
            config('domains.day-news') => 'day-news',
            config('domains.downtown-guide') => 'downtown-guide',
            config('domains.event-city') => 'event-city',
            default => 'event-city', // Default to event-city for any unmatched domain
        };

        // Store in config for use throughout the application
        config(['app.current_domain' => $appType]);

        // Also store in request for easy access
        $request->attributes->set('app_domain', $appType);

        return $next($request);
    }
}
```

### DetectUserLocation.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Middleware;

use App\Services\LocationService;
use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

final class DetectUserLocation
{
    public function __construct(
        private readonly LocationService $locationService
    ) {}

    /**
     * Handle an incoming request and detect user's location
     */
    public function handle(Request $request, Closure $next): Response
    {
        $region = $this->locationService->detectUserRegion();

        $request->attributes->set('detected_region', $region);

        config([
            'app.current_region' => $region,
        ]);

        return $next($request);
    }
}
```

### HandleAppearance.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\View;
use Symfony\Component\HttpFoundation\Response;

final class HandleAppearance
{
    /**
     * Handle an incoming request.
     *
     * @param  Closure(Request): (Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        View::share('appearance', $request->cookie('appearance') ?? 'system');

        return $next($request);
    }
}
```

### HandleInertiaRequests.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Middleware;

use App\Models\Notification;
use App\Models\Region;
use App\Models\User;
use App\Services\LocationService;
use Illuminate\Foundation\Inspiring;
use Illuminate\Http\Request;
use Inertia\Middleware;
use Tighten\Ziggy\Ziggy;

final class HandleInertiaRequests extends Middleware
{
    /**
     * The root template that's loaded on the first page visit.
     *
     * @see https://inertiajs.com/server-side-setup#root-template
     *
     * @var string
     */
    protected $rootView = 'app';

    public function __construct(
        private readonly LocationService $locationService
    ) {}

    /**
     * Determines the current asset version.
     *
     * @see https://inertiajs.com/asset-versioning
     */
    public function version(Request $request): ?string
    {
        return parent::version($request);
    }

    /**
     * Define the props that are shared by default.
     *
     * @see https://inertiajs.com/shared-data
     *
     * @return array<string, mixed>
     */
    public function share(Request $request): array
    {
        [$message, $author] = str(Inspiring::quotes()->random())->explode('-');

        $user = $request->user();
        $workspaces = $this->getUserWorkspacesData($user);

        return [
            ...parent::share($request),
            'name' => config('app.name'),
            'quote' => ['message' => mb_trim($message), 'author' => mb_trim($author)],
            'auth' => [
                'user' => $request->user(),
                'passwordEnabled' => config('makerkit.auth.password.enabled'),
                'magicLinkEnabled' => config('makerkit.auth.magiclink.enabled'),
            ],
            'workspaces' => $workspaces,
            'notifications' => fn () => $this->getUserNotifications($user),
            'ziggy' => fn (): array => [
                ...(new Ziggy)->toArray(),
                'location' => $request->url(),
            ],
            'sidebarOpen' => ! $request->hasCookie('sidebar_state') || $request->cookie('sidebar_state') === 'true',
            'appDomain' => config('app.current_domain', 'event-city'),
            'analytics' => [
                'ga4Id' => config('analytics.ga4.'.config('app.current_domain', 'event-city')),
            ],
            'location' => $this->getLocationData($request),
            'crossDomainAuth' => [
                'urls' => $request->session()->get('cross_domain_auth_urls', []),
                'logoutUrls' => $request->session()->get('cross_domain_logout_urls', []),
            ],
        ];
    }

    private function getUserWorkspacesData(?User $user): array
    {
        if (! $user) {
            return [[], null];
        }

        $memberships = $user->workspaceMemberships()
            ->with('workspace')
            ->get();

        $workspaces = $memberships->map(fn ($membership) => [
            'id' => $membership->workspace->id,
            'name' => $membership->workspace->name,
            'role' => $membership->role,
            'logo' => $membership->workspace->logo,
        ])->toArray();

        $currentWorkspace = null;
        if ($user->current_workspace_id && $user->currentWorkspace) {
            $currentMembership = $memberships->firstWhere('workspace_id', $user->currentWorkspace->id);

            $currentWorkspace = [
                'id' => $user->currentWorkspace->id,
                'name' => $user->currentWorkspace->name,
                'role' => $currentMembership ? $currentMembership->role : null,
                'logo' => $user->currentWorkspace->logo,
                'permissions' => $currentMembership ? $currentMembership->permissions : [],
            ];
        }

        return [
            'enabled' => config('makerkit.workspaces.enabled'),
            'all' => $workspaces,
            'current' => $currentWorkspace,
            'canCreateWorkspaces' => config('makerkit.workspaces.can_create_workspaces'),
        ];
    }

    private function getUserNotifications(?User $user): ?array
    {
        if (! $user) {
            return null;
        }

        $notifications = Notification::forUser($user->id)
            ->unread()
            ->latest()
            ->limit(10)
            ->get();

        $unreadCount = Notification::forUser($user->id)->unread()->count();

        return [
            'notifications' => $notifications->toArray(),
            'unread_count' => $unreadCount,
        ];
    }

    private function getLocationData(Request $request): array
    {
        $region = $request->attributes->get('detected_region');
        $confirmed = $this->locationService->hasUserConfirmedLocation();

        return [
            'current_region' => $region ? $this->formatRegion($region) : null,
            'confirmed' => $confirmed,
        ];
    }

    private function formatRegion(Region $region): array
    {
        return [
            'id' => $region->id,
            'name' => $region->name,
            'slug' => $region->slug,
            'type' => $region->type,
            'full_name' => $region->full_name,
            'latitude' => $region->latitude,
            'longitude' => $region->longitude,
        ];
    }
}
```

### VerifyN8nApiKey.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;

final class VerifyN8nApiKey
{
    /**
     * Handle an incoming request.
     *
     * Verifies that the request contains a valid N8N API key in the
     * X-N8N-API-Key header or Authorization header (Bearer token).
     */
    public function handle(Request $request, Closure $next): Response
    {
        $apiKey = config('services.n8n.api_key');

        // If no API key is configured, allow the request (for local development)
        if (empty($apiKey)) {
            return $next($request);
        }

        // Check for API key in X-N8N-API-Key header (preferred)
        $providedKey = $request->header('X-N8N-API-Key');

        // Fallback to Authorization Bearer token
        if (empty($providedKey)) {
            $authHeader = $request->header('Authorization');
            if ($authHeader !== null && str_starts_with($authHeader, 'Bearer ')) {
                $providedKey = mb_substr($authHeader, 7);
            }
        }

        // Verify the API key matches
        if ($providedKey === null || ! hash_equals($apiKey, $providedKey)) {
            return response()->json([
                'success' => false,
                'message' => 'Unauthorized. Invalid or missing API key.',
            ], 401);
        }

        return $next($request);
    }
}
```

### WorkspaceMiddleware.php
```php
<?php

declare(strict_types=1);

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Context;
use Symfony\Component\HttpFoundation\Response;

final class WorkspaceMiddleware
{
    /**
     * Handle an incoming request.
     *
     * @param  Closure(Request): (Response)  $next
     */
    public function handle(Request $request, Closure $next): Response
    {
        if (Auth::check()) {
            /** @var \App\Models\User $user */
            $user = Auth::user();

            // Set the current workspace context if user has a current workspace
            if ($user->current_workspace_id) {
                Context::add('workspace_id', $user->current_workspace_id);
            }
        }

        return $next($request);
    }
}
```

---
## Composer Dependencies

```json
{
    "$schema": "https://getcomposer.org/schema.json",
    "name": "laravel/react-starter-kit",
    "type": "project",
    "description": "The skeleton application for the Laravel framework.",
    "keywords": [
        "laravel",
        "framework"
    ],
    "license": "MIT",
    "require": {
        "php": "^8.2",
        "aws/aws-sdk-php": "^3.369",
        "cesargb/laravel-magiclink": "^2.24.1",
        "climactic/laravel-credits": "^1.4.0",
        "filament/filament": "^4.3.1",
        "inertiajs/inertia-laravel": "^2.0.16",
        "laravel/framework": "^12.43.1",
        "laravel/horizon": "^5.41.0",
        "laravel/nightwatch": "^1.21.1",
        "laravel/socialite": "^5.24.0",
        "laravel/tinker": "^2.10.2",
        "league/flysystem-aws-s3-v3": "^3.30.1",
        "minishlink/web-push": "^10.0",
        "nunomaduro/essentials": "^1.0.1",
        "predis/predis": "^3.3.0",
        "prism-php/prism": "^0.99.2",
        "sentry/sentry-laravel": "^4.20.0",
        "spatie/laravel-sitemap": "^7.3.8",
        "stevebauman/location": "^7.6.0",
        "stripe/stripe-php": "^19.1.0",
        "tightenco/ziggy": "^2.6.0"
    },
    "require-dev": {
        "fakerphp/faker": "^1.24.1",
        "laravel/boost": "^1.8.5",
        "laravel/pail": "^1.2.4",
        "laravel/pint": "^1.26.0",
        "laravel/sail": "^1.51.0",
        "mockery/mockery": "^1.6.12",
        "nunomaduro/collision": "^8.8.3",
        "pestphp/pest": "^4.2.0",
        "pestphp/pest-plugin-laravel": "^4.0.0"
    },
    "autoload": {
        "psr-4": {
            "App\\": "app/",
            "Database\\Factories\\": "database/factories/",
            "Database\\Seeders\\": "database/seeders/"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "Tests\\": "tests/"
        }
    },
    "scripts": {
        "post-autoload-dump": [
            "Illuminate\\Foundation\\ComposerScripts::postAutoloadDump",
            "@php artisan package:discover --ansi",
            "@php artisan filament:upgrade"
        ],
        "post-update-cmd": [
            "@php artisan vendor:publish --tag=laravel-assets --ansi --force"
        ],
        "post-root-package-install": [
            "@php -r \"file_exists('.env') || copy('.env.example', '.env');\""
        ],
        "post-create-project-cmd": [
            "@php artisan key:generate --ansi",
            "@php -r \"file_exists('database/database.sqlite') || touch('database/database.sqlite');\"",
            "@php artisan migrate --graceful --ansi"
        ],
        "dev": [
            "Composer\\Config::disableProcessTimeout",
            "npx concurrently -c \"#93c5fd,#c4b5fd,#fb7185,#fdba74\" \"php artisan serve --host=127.0.0.1\" \"php artisan horizon\" \"php artisan pail --timeout=0\" \"bun run dev\" --names=server,horizon,logs,vite"
        ],
        "dev:ssr": [
            "bun --bun run build:ssr",
            "Composer\\Config::disableProcessTimeout",
            "bunx concurrently -c \"#93c5fd,#c4b5fd,#fb7185,#fdba74,#f97316\" \"php artisan serve\" \"php artisan horizon\" \"php artisan pail --timeout=0\" \"php artisan inertia:start-ssr\" --names=server,horizon,logs,ssr"
        ],
        "lint": [
            "./vendor/bin/pint --parallel --dirty"
        ],
        "test": [
            "@php artisan config:clear --ansi",
            "./vendor/bin/pest"
        ]
    },
    "extra": {
        "laravel": {
            "dont-discover": []
        }
    },
    "config": {
        "optimize-autoloader": true,
        "preferred-install": "dist",
        "sort-packages": true,
        "allow-plugins": {
            "pestphp/pest-plugin": true,
            "php-http/discovery": true
        }
    },
    "minimum-stability": "stable",
    "prefer-stable": true
}
```
